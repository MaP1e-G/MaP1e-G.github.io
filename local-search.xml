<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>力扣-13.罗马数字转整数</title>
    <link href="/2022/09/30/leetcode-13/"/>
    <url>/2022/09/30/leetcode-13/</url>
    
    <content type="html"><![CDATA[<h1>题目描述</h1><p><a href="http://imagehost.map1e-g.cn/leetcode/leetcode_13_1.png"></a><br><a href="http://imagehost.map1e-g.cn/leetcode/leetcode_13_2.png"></a></p><h1>实现</h1><p>其实自己并没有想到好的实现，索性就直接暴力遍历然后分情况讨论了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">romanToInt</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">char</span> tmp;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">cursor</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; cursor &lt; s.length(); cursor++)&#123;<br>            tmp = s.charAt(cursor);<br>            <span class="hljs-keyword">if</span> (tmp == <span class="hljs-string">&#x27;M&#x27;</span>)&#123;<br>                result += <span class="hljs-number">1000</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tmp == <span class="hljs-string">&#x27;D&#x27;</span>)&#123;<br>                result += <span class="hljs-number">500</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tmp == <span class="hljs-string">&#x27;C&#x27;</span>)&#123;<br>                <span class="hljs-keyword">if</span> (cursor &lt; s.length() - <span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-keyword">if</span>(s.charAt(cursor + <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;M&#x27;</span>)&#123;<br>                        result += <span class="hljs-number">900</span>;<br>                        cursor++;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.charAt(cursor + <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;D&#x27;</span>)&#123;<br>                        result += <span class="hljs-number">400</span>;<br>                        cursor++;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span>&#123;<br>                        result += <span class="hljs-number">100</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    result += <span class="hljs-number">100</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tmp == <span class="hljs-string">&#x27;L&#x27;</span>)&#123;<br>                result += <span class="hljs-number">50</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tmp == <span class="hljs-string">&#x27;X&#x27;</span>)&#123;<br>                <span class="hljs-keyword">if</span> (cursor &lt; s.length() - <span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-keyword">if</span>(s.charAt(cursor + <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;C&#x27;</span>)&#123;<br>                        result += <span class="hljs-number">90</span>;<br>                        cursor++;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.charAt(cursor + <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;L&#x27;</span>)&#123;<br>                        result += <span class="hljs-number">40</span>;<br>                        cursor++;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span>&#123;<br>                        result += <span class="hljs-number">10</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    result += <span class="hljs-number">10</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tmp == <span class="hljs-string">&#x27;V&#x27;</span>)&#123;<br>                result += <span class="hljs-number">5</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (cursor &lt; s.length() - <span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-keyword">if</span>(s.charAt(cursor + <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;X&#x27;</span>)&#123;<br>                        result += <span class="hljs-number">9</span>;<br>                        cursor++;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.charAt(cursor + <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;V&#x27;</span>)&#123;<br>                        result += <span class="hljs-number">4</span>;<br>                        cursor++;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span>&#123;<br>                        result += <span class="hljs-number">1</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    result += <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>太久没写了，写得太久了，写的挺急的，就想着怎么写出来其他都没管了，看上去挺笨重的（<br>我就没多想，转就转呗，那我就嗯遍历一遍字符串，特殊情况拿出来特殊讨论就好了。一开始是往前看的，发现不对劲，往前看结果不对，只好往后看顺便多加一条条件防止索引出界（好笨啊好笨啊好笨啊）<br>行吧，毕竟我现在水平感觉跟刚学编程的没什么差别，只能说慢慢来了（倒</p><hr>]]></content>
    
    
    <categories>
      
      <category>Solution</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Java</tag>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python随笔-5</title>
    <link href="/2022/09/22/python-essay-5/"/>
    <url>/2022/09/22/python-essay-5/</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>文章未完成</p>          </div><h1><code>__future__</code>模块</h1><p>说白了就是把新版本的特性导入到当前Python版本。<br>然后程序里是这个东西：<code>from __future__ import annotations</code><br>额，这条语句其实搞不是很懂，参考了下别人的博文，大概有这么两种解释得好的：</p><blockquote><p>加入以下语句，解释器将不再构造这些复合类型。<br><code>from __future__ import annotations</code><br>一旦解释器解析脚本语法树后，它会识别类型提示并绕过评估它，将其保留为原始字符串。这种机制使得类型提示发生在需要它们的地方：由linter来进行类型检查。 在Python 4中，这种机制将成为默认行为。<br>原文链接：<a href="https://sikasjc.github.io/2018/07/14/type-hint-in-python/">全面理解Python中的类型提示（Type Hints）</a><br>还有一个是代码例子:(原文链接：<a href="https://www.jtr109.com/posts/python-self-typing-annotation/">Python Class 定义时声明当前 Class 类型</a>)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span>:<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self: Foo, bar: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        self.bar = bar<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    Foo(<span class="hljs-string">&#x27;bar&#x27;</span>)<br></code></pre></td></tr></table></figure><p>但是上面的代码是会报错的，原因就在于<code>self: Foo</code>。因为在类<code>Foo</code>定义前就已经被自己的方法<code>__init__</code>使用了，解释器无法理解，报出<code>NameError: name 'Foo' is not defined</code>错误。<br>这个时候这条语句就有用了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> __future__ <span class="hljs-keyword">import</span> annotations<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span>:<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self: Foo, bar: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        self.bar = bar<br></code></pre></td></tr></table></figure><h1><code>typing</code>模块——类型注解支持</h1><p>这个模块提供对类型提示的运行时支持。下边详细介绍一下程序里边的从typing导入的各种东西：</p><h2 id="TypeVar">TypeVar</h2><p>类型变量的缩写。类型变量主要是为静态类型检查器提供支持，用于泛型类型与泛型函数定义的参数。有关泛型类型，详见<code>Generic</code>。<br>其实就是定义一个泛型变量，然后你就能把这个泛型变量用在泛型类型或者泛型函数定义的参数中了。直接上例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Python">T = TypeVar(<span class="hljs-string">&#x27;T&#x27;</span>)  <span class="hljs-comment"># Can be anything</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">repeat</span>(<span class="hljs-params">x: T, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Sequence</span>[T]:  <span class="hljs-comment"># 这里的 Sequence[T] 就是把泛型变量用在泛型类型中，x: T 就是把泛型变量用在泛型函数定义的参数中。</span><br>    <span class="hljs-string">&quot;&quot;&quot;Return a list containing n references to x.&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> [x]*n<br></code></pre></td></tr></table></figure><p>你也可以对类型变量进行<strong>绑定(bound)</strong>，或者<strong>约束</strong>类型变量，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Python">S = TypeVar(<span class="hljs-string">&#x27;S&#x27;</span>, bound=<span class="hljs-built_in">str</span>)  <span class="hljs-comment"># Can be any subtype of str</span><br>A = TypeVar(<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-built_in">str</span>, <span class="hljs-built_in">bytes</span>)  <span class="hljs-comment"># Must be exactly str or bytes</span><br></code></pre></td></tr></table></figure><p>但是要注意的是，类型变量不能既是被绑定的又是被约束的。</p><h2 id="Generic">Generic</h2><p>用于泛型类型的抽象基类。<br><strong>泛型类型一般通过继承含一个或多个类型变量的类实例进行声明</strong>。官方文档给出的例子是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mapping</span>(<span class="hljs-type">Generic</span>[KT, VT]):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self, key: KT</span>) -&gt; VT:<br>        ...<br>        <span class="hljs-comment"># Etc.</span><br><br>X = TypeVar(<span class="hljs-string">&#x27;X&#x27;</span>)<br>Y = TypeVar(<span class="hljs-string">&#x27;Y&#x27;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">lookup_name</span>(<span class="hljs-params">mapping: Mapping[X, Y], key: X, default: Y</span>) -&gt; Y:<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">return</span> mapping[key]<br>    <span class="hljs-keyword">except</span> KeyError:<br>        <span class="hljs-keyword">return</span> default<br></code></pre></td></tr></table></figure><p>这里还给出了另一篇<a href="https://zhuanlan.zhihu.com/p/486772116">文章</a>中的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> TypeVar, <span class="hljs-type">Union</span>, <span class="hljs-type">Generic</span>, <span class="hljs-type">List</span><br><br><span class="hljs-comment"># 通过TypeVar限定为整数型的列表和浮点数的列表</span><br>T = TypeVar(<span class="hljs-string">&quot;T&quot;</span>, bound=<span class="hljs-type">Union</span>[<span class="hljs-built_in">int</span>, <span class="hljs-built_in">float</span>])<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyList</span>(<span class="hljs-type">Generic</span>[T]):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, size: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        self.size = size<br>        self.<span class="hljs-built_in">list</span>: <span class="hljs-type">List</span>[T] = []<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">append</span>(<span class="hljs-params">self, e: T</span>):<br>        self.<span class="hljs-built_in">list</span>.append(e)<br>        <span class="hljs-built_in">print</span>(self.<span class="hljs-built_in">list</span>)<br><br><span class="hljs-comment"># 适用于整数型</span><br>intList = MyList[<span class="hljs-built_in">int</span>](<span class="hljs-number">3</span>)    <span class="hljs-comment"># 通过[int]进行类型提示！</span><br>intList.append(<span class="hljs-number">101</span>)<br><br><span class="hljs-comment"># 也适用于浮点数</span><br>floatList = MyList[<span class="hljs-built_in">float</span>](<span class="hljs-number">3</span>)<br>floatList.append(<span class="hljs-number">1.1</span>)<br><br><span class="hljs-comment"># 但不适用于字符串，以下代码通过mypy检查会报错！</span><br>strList = MyList[<span class="hljs-built_in">str</span>](<span class="hljs-number">3</span>)<br>strList.append(<span class="hljs-string">&quot;test&quot;</span>)<br></code></pre></td></tr></table></figure><p>或许可以理解为，如果你定义的一个类中使用了某种类型变量，那么你可以通过<code>Generic</code>来对你的类声明。（如果你创建的类中想要使用某种类型变量，如T，那么你就通过继承<code>Generic[T]</code>类来使用。）</p><h2 id="Protocol">Protocol</h2><p>官方文档是这么描述的：协议类的基类。呃，那么问题来了，我也不知道什么是协议类啊。。。所以我直接使用搜索引擎，找到了点零零散散的东西。<br>在Python中，协议就是一个或一组方法（接口），那协议类很明显就是包含协议的类，就是在这个类里边放一些不实现的方法，是不是像那啥，抽象基类啊？<br>比如下面的代码，<code>__eq__</code>和<code>__lt__</code>不就pass了吗，这俩就能看成协议。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># ... 表示函数没有实现任何代码，跟 pass 的作用类似</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Comparable</span>(<span class="hljs-title class_ inherited__">Protocol</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__eq__</span>(<span class="hljs-params">self, other: <span class="hljs-type">Any</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        ...<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__lt__</span>(<span class="hljs-params">self: C, other: C</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        ...<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__gt__</span>(<span class="hljs-params">self: C, other: C</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">not</span> self &lt; other) <span class="hljs-keyword">and</span> self != other<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__le__</span>(<span class="hljs-params">self: C, other: C</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-keyword">return</span> self &lt; other <span class="hljs-keyword">or</span> self == other<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__ge__</span>(<span class="hljs-params">self: C, other: C</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">not</span> self &lt; other<br></code></pre></td></tr></table></figure><p>然后官方文档接着说了：这些类主要与静态类型检查器搭配使用，用来识别结构子类型（静态鸭子类型）。啊，好的，我也不知道啥是鸭子类型，所以我又去找搜索引擎帮忙了，然后我找到这么一篇文章：<a href="https://cloud.tencent.com/developer/article/1484390#3.2">你知道什么是Python里的鸭子类型和猴子补丁吗？</a><br>文章里是这么说的：</p><blockquote><p>鸭子类型是对Python中数据类型本质上是由属性和行为来定义的一种解读。<br>Python是一种动态语言，不像Java和C++这种强类型语言，Python里实际上没有严格的类型检查。<br>只要某个对象具有鸭子的方法，可以像鸭子那样走路和嘎嘎叫，那么它就可以被其它函数当做鸭子一样调用。<br>啥意思呢，举个栗子：<br>假设我们现在有两个类，一个<code>Duck</code>类，一个<code>Goose</code>类，两个类都实现了同样的方法<code>bark()</code><br>然后我们自定义了一个函数<code>test</code>，这个函数接受一个<code>Duck</code>对象，并调用该对象的<code>bark()</code>方法。在其它语言中，我们需要指定传入形参<code>duck</code>的类型，得这么写<code>test(Duck duck)</code>，但是在Python中不需要，直接这么写：<code>test(duck)</code><br>但由于Python是动态语言，没有严格类型检查，这就导致你把一个<code>Goose</code>类的对象塞进去也不会报错，因为<code>Goose</code>类也实现了<code>bark()</code>方法。<br>卸载再来看下官方文档给出的例子：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Proto</span>(<span class="hljs-title class_ inherited__">Protocol</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">meth</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        ...<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">meth</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">x: Proto</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-keyword">return</span> x.meth()<br><br>func(C())  <span class="hljs-comment"># Passes static type check</span><br></code></pre></td></tr></table></figure><p>上面的<code>Proto</code>类即是协议类，里面只有一个协议（方法）<code>meth()</code>，而另一个则是<code>C</code>，它实现了协议<code>meth()</code>，那么它就可以看作是鸭子类型。<br>这里的<code>func()</code>函数用了类型检查，虽然指定了参数<code>x</code>的类型是<code>Proto</code>，但是由于<code>Proto</code>继承了<code>Protocol</code>，所以传入鸭子类型<code>C</code>的时候，跳过了静态类型检查。</p><div class="note note-info">            <p>Protocol 类可以是泛型，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GenProto</span>(Protocol[T]):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">meth</span>(<span class="hljs-params">self</span>) -&gt; T:<br>        ...<br></code></pre></td></tr></table></figure>          </div><h2 id="Callable">Callable</h2><hr>]]></content>
    
    
    <categories>
      
      <category>Essay</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>斐波那契数列</title>
    <link href="/2022/09/14/fibonacci_1/"/>
    <url>/2022/09/14/fibonacci_1/</url>
    
    <content type="html"><![CDATA[<h1>什么是斐波那契数列？</h1><p>相信对于各位程序员来说，斐波那契数列是个无比熟悉的东西了（递 归 启 蒙），不需要什么多余的介绍。不过出于让文章变得更友好些，还是简单提一下吧。<br>其实在数学上，斐波那契数列就是以递归的形式定义的：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>F</mi><mn>0</mn></msub><mo>=</mo><mn>0</mn><mspace linebreak="newline"></mspace><msub><mi>F</mi><mn>1</mn></msub><mo>=</mo><mn>1</mn><mspace linebreak="newline"></mspace><msub><mi>F</mi><mi>n</mi></msub><mo>=</mo><msub><mi>F</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>F</mi><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow></msub><mtext>（</mtext><mi>n</mi><mo>≥</mo><mn>2</mn><mtext>）</mtext></mrow><annotation encoding="application/x-tex">F_0=0 \\F_1=1 \\F_n=F_{n-1}+F_{n-2}（n \ge 2）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">（</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">2</span><span class="mord cjk_fallback">）</span></span></span></span></span></p><p>用文字来说，就是斐波那契数列由0和1开始，之后的斐波那契数就是由之前的两数相加而得出。</p><h1>最先想到的实现！</h1><p>其实看完上面的三个公式，很快就能把对应的求斐波那契数的函数写出来了。最经典（应该吧）的写法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fib0</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br><span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">2</span>:<br><span class="hljs-keyword">return</span> n<br><span class="hljs-keyword">return</span> fib0(n - <span class="hljs-number">1</span>) + fib0(n - <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>虽然这种写法是根据数学公式直接转换过来的，十分简单暴力，但是它的运算时间是随n而指数上升的！</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">55</span><br>计算第<span class="hljs-number">10</span>个斐波那契数所需时间：<span class="hljs-number">0</span>.<span class="hljs-number">3194000000000009m</span>s<br><span class="hljs-number">6765</span><br>计算第<span class="hljs-number">20</span>个斐波那契数所需时间：<span class="hljs-number">1</span>.<span class="hljs-number">1687000000000016m</span>s<br><span class="hljs-number">832040</span><br>计算第<span class="hljs-number">30</span>个斐波那契数所需时间：<span class="hljs-number">108</span>.<span class="hljs-number">93619999999999m</span>s<br><span class="hljs-number">102334155</span><br>计算第<span class="hljs-number">40</span>个斐波那契数所需时间：<span class="hljs-number">12987</span>.<span class="hljs-number">193299999999m</span>s<br></code></pre></td></tr></table></figure><p>可以看到，从30到40，计算时间直接翻了100倍！更不要说运行<code>fib0(50)</code>了，可能根本等不到运行结果。。。</p><h1>想办法进行优化</h1><p>那如果我们有额外需求要求如此之“大”的斐波那契数，要怎么办呢？这里给出两种办法：利用结果缓存、将递归改为迭代。</p><h2 id="简直不要太好用的结果缓存">简直不要太好用的结果缓存</h2><p>结果缓存是一种缓存技术，即在每次计算任务完成后就把结果保存起来，这样在下次需要时即可直接检索出结果，避免了重复计算。</p><h3 id="使用字典进行结果缓存">使用字典进行结果缓存</h3><p>我们可以将每次计算得到的斐波那契数存入字典中，需要的时候再把它取出来，这样就可以避免重复运算，提高运行效率了。<br>下面给出了在Python中利用<code>Dict</code>实现结果缓存和在Java中使用<code>Map</code>实现结果缓存的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Dict</span><br><br>memo: <span class="hljs-type">Dict</span>[<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>] = &#123;<span class="hljs-number">0</span>: <span class="hljs-number">0</span>, <span class="hljs-number">1</span>: <span class="hljs-number">1</span>&#125;<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fib1</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-keyword">if</span> n <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> memo:<br>        memo[n] = fib1(n - <span class="hljs-number">1</span>) + fib1(n - <span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">return</span> memo[n]<br><br><span class="hljs-comment"># output</span><br><span class="hljs-number">354224848179261915075</span><br>计算第<span class="hljs-number">100</span>个斐波那契数所需时间：<span class="hljs-number">0.3382000000000003</span>ms<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CalculateFib</span> &#123;<br>    <span class="hljs-keyword">static</span> Map&lt;Integer, Integer&gt; m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, Integer&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (m.get(n) == <span class="hljs-literal">null</span>) &#123;<br>            m.put(n, fib(n - <span class="hljs-number">1</span>) + fib(n - <span class="hljs-number">2</span>));<br>        &#125;<br>        <span class="hljs-keyword">return</span> m.get(n);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        m.put(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        m.put(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>        System.out.println(CalculateFib.fib(<span class="hljs-number">20</span>));<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// output</span><br><span class="hljs-number">102334155</span><br>Spend time:<span class="hljs-number">134100.</span>0ns<br></code></pre></td></tr></table></figure><p>比较一下现在的效率和之前的效率，怎么样，是不是有了飞一般的提升？不过，使用字典并不是Python最方便的结果缓存方法，因为在Python里有一个内置的装饰器，可以自动为任何函数缓存结果。</p><h3 id="自动化的结果缓存">自动化的结果缓存</h3><p><code>@functools.lru_cache(maxsize=128, typed=False)</code>是一个为函数提供缓存功能的装饰器，缓存 maxsize 组传入参数，在下次以相同参数调用时直接返回上一次的结果。<br>如果 maxsize 设为 None，LRU 特性将被禁用且缓存可无限增长。<br>如果 typed 被设置为 true ，不同类型的函数参数将被分别缓存。 如果 typed 为 false ，实现通常会将它们视为等价的调用，只缓存一个结果。(有些类型，如 str 和 int ，即使 typed 为 false ，也可能被分开缓存）。<br>我们只需要在最开始实现的<code>fib0()</code>函数上加上装饰器即可，非常简单友好，不是吗？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> lru_cache<br><span class="hljs-meta">@lru_cache(<span class="hljs-params">maxsize=<span class="hljs-literal">None</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fib0</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br><span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">2</span>:<br><span class="hljs-keyword">return</span> n<br><span class="hljs-keyword">return</span> fib0(n - <span class="hljs-number">1</span>) + fib0(n - <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>但是其实，就算利用结果缓存，因为还是利用递归的原因，回溯存在上限，还是无法计算一些大数，比如<code>fib(1000)</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Python">Traceback (most recent call last):<br>RecursionError: maximum recursion depth exceeded<br></code></pre></td></tr></table></figure><p>这种情况下，我们就改用<strong>迭代法</strong>来求斐波那契数了。</p><h2 id="迭代法">迭代法</h2><p>递归解决方案是反向求解，而迭代则是正向求解，也就是说，我们不再是从n往前求解，而是从0开始推导出n。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fib2</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> n<br>    last: <span class="hljs-built_in">int</span> = <span class="hljs-number">0</span><br>    <span class="hljs-built_in">next</span>: <span class="hljs-built_in">int</span> = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>        last, <span class="hljs-built_in">next</span> = <span class="hljs-built_in">next</span>, last + <span class="hljs-built_in">next</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">next</span><br><br><span class="hljs-comment"># output</span><br><span class="hljs-number">139423224561697880139724382870407283950070256587697307264108962948325571622863290691557658876222521294125</span><br>计算第<span class="hljs-number">500</span>个斐波那契数所需时间：<span class="hljs-number">0.30870000000000203</span>ms<br></code></pre></td></tr></table></figure><p>因为利用了迭代法的原因，我们可以在此基础上将这个函数写成生成器，这样就可以输出到n的每一个斐波那契数了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Generator<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fib3</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; Generator[<span class="hljs-built_in">int</span>, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>]:<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> n &gt; <span class="hljs-number">0</span>: <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span><br>    last: <span class="hljs-built_in">int</span> = <span class="hljs-number">0</span><br>    <span class="hljs-built_in">next</span>: <span class="hljs-built_in">int</span> = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>        last, <span class="hljs-built_in">next</span> = <span class="hljs-built_in">next</span>, last + <span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">next</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> fib3(<span class="hljs-number">50</span>):<br><span class="hljs-built_in">print</span>(i)<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>Essay</category>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Java</tag>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python学习笔记——循环与迭代</title>
    <link href="/2022/07/19/python-learning-5/"/>
    <url>/2022/07/19/python-learning-5/</url>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>由于我实在想不出写什么前言好，所以这里我选择直截了当地概括内容！(<br>在本篇中，你可以学到：怎么<s>漂亮地</s>写Python中的循环，<s>轻松地</s>认识Python中的迭代器和生成器。</p><h1>正文</h1><h2 id="Python中的循环">Python中的循环</h2><h3 id="认识Python中的循环">认识Python中的循环</h3><p>如果是刚接触Python，那么可能会对Python中循环的写法感到奇怪，因为Python中的循环并不像其他语言那样写。先来比较一下我们熟悉的循环和Python的循环。<br>就以Java语言为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"># Java语言举例循环<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> a; i &lt; n; i += s)&#123;<br><span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>然后再来看看Python的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># Python语言的循环，a为起始值，n为终止值，s为步长。</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(a, n, s)<br></code></pre></td></tr></table></figure><p>其他语言转换成Python中的循环，就是用<code>range()</code>函数，它接受三个可选参数，在上边程序段中也说明了三个参数代表什么。<br>哦，当然，譬如Java和C#这样的语言也提供foreach循环，可以说Python中的基本循环就是比较接近于foreach循环的，直接在容器或序列中迭代元素，无需通过索引查找，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Python">items = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]<br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> items:<br><span class="hljs-built_in">print</span>(item)<br><br><span class="hljs-comment"># 输出如下：</span><br>a<br>b<br>c<br></code></pre></td></tr></table></figure><p>所以如果是刚刚接触Python可能还需要一段时间来适应循环的写法，熟悉后便会觉得“诶，这样写循环还挺不错挺方便的哦！”<br>当然这里要提的不仅仅是这点东西，我还会介绍一下<code>range()</code>函数、解析式、以及一些循环写法。</p><div class="note note-warning">            <p><strong>在Python循环中需要注意的几点！</strong><br>1、 循环中不再跟踪容器的大小，也不使用运行时索引来访问元素。<br>2、 容器本身现在负责分发将要处理的元素。如果容器是有序的，那么所得到的元素序列也是有序的。如果容器是无序的，那么将以随机顺序返回其元素，但循环仍然会遍历所有元素。</p>          </div><h3 id="Python中的循环的一些神必写法">Python中的循环的一些神必写法</h3><p><s>好吧其实并不神必只是想取个有意思的标题</s><br>我们知道，Python的循环可以取索引，或者直接取容器中的元素，但是有的时候我们既需要索引，也需要元素，能不能做到呢？其实是可以的，利用内置的<code>enumerate()</code>即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> i, item <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(items):<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;i&#125;</span>: <span class="hljs-subst">&#123;item&#125;</span>&#x27;</span>)<br><br><span class="hljs-number">0</span>: a<br><span class="hljs-number">1</span>: b<br><span class="hljs-number">2</span>: c<br></code></pre></td></tr></table></figure><blockquote><p>Python中的迭代器可以连续返回多个值。迭代器可以返回含有任意个元素的元组，然后在for语句内解包。</p></blockquote><h3 id="Python中的解析式">Python中的解析式</h3><p>列表解析式是Python的一个特性，也可以看作是一种语法糖<s>（或者是神必写法）</s>。它可以简化（前提是能够理解）并使循环更加紧凑，举个栗子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 如果要写一个平方列表，我们可能会这么做：</span><br>squares = []<br>    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>        squares.append(x * x)<br><br><span class="hljs-comment"># 如果使用列表解析式，就会变得十分简洁紧凑：</span><br>    squares = [x * x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)]<br></code></pre></td></tr></table></figure><p>上边可以说是最基本的列表解析式构建列表了，列表解析式能做到的还不止这样，它还能使用条件来过滤元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Python">even_squares = [x * x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">if</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p>在上面的代码段中，构建了一个从0到9所有偶数整数的平方组成的列表。<br>归纳一下，可以得到如下列表解析式模板：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 一般循环：</span><br>values = []<br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> collection:<br><span class="hljs-keyword">if</span> condition:<br>values.append(expression)<br><br><span class="hljs-comment"># 使用列表解析式的循环：</span><br>values = [expression <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> collection <span class="hljs-keyword">if</span> condition]<br></code></pre></td></tr></table></figure><p>以上就是列表解析式的所有内容啦，不过既然有列表解析式，那Python中是否还有<strong>字典解析式</strong>呢？<br>你好，有的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">&gt;&gt;&gt; </span>&#123; x: x * x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>)&#125;<br>&#123;<span class="hljs-number">0</span>: <span class="hljs-number">0</span>, <span class="hljs-number">1</span>: <span class="hljs-number">1</span>, <span class="hljs-number">2</span>: <span class="hljs-number">4</span>, <span class="hljs-number">3</span>: <span class="hljs-number">9</span>, <span class="hljs-number">4</span>: <span class="hljs-number">16</span>&#125;<br></code></pre></td></tr></table></figure><p>不仅是字典解析式，还有<strong>集合解析式</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">&gt;&gt;&gt; </span>&#123; x * x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(-<span class="hljs-number">9</span>, <span class="hljs-number">10</span>) &#125;<br>&#123;<span class="hljs-number">64</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">36</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">81</span>, <span class="hljs-number">49</span>, <span class="hljs-number">25</span>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>集合是无需类型，所以在将元素加到set容器时顺序是随机的。</p></blockquote><div class="note note-info">            <p>“不过Python解析式中有一个需要注意的地方：在熟悉了解析式之后，很容易就会编写出难以阅读的代码。”<br>“在经历了许多烦恼之后，我给解析式设定的限制是只能嵌套一层。在大多数情况下，多层嵌套最好直接使用for循环，这样代码更加易读且容易维护。”</p>          </div><h3 id="Python中的列表切片及其技巧">Python中的列表切片及其技巧</h3><p>Python的列表对象有方便的切片特性。<strong>切片</strong>可被视为方括号索引语法的扩展，通常用于访问有序集合中某一范围的元素。例如，将一个大型列表对象分成几个较小的子列表。<br>我们可以这么看切片语法：<code>a_list[start:stop:step]</code>，其中<strong>start</strong>为起始索引，<strong>stop</strong>为终止索引，<strong>step</strong>为步长（也叫<strong>stride</strong>，步幅）。不过要记住一点，切片计算方法是算头不算尾，也就是切片里面包含的元素是<strong>start到stop-1</strong>。<br>了解了语法，就可以来看看它的一些应用技巧了。首先是用切片语法创建一个原始列表的逆序副本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">&gt;&gt;&gt; </span>a_list = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>a_list[::-<span class="hljs-number">1</span>]<br>[<span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>稍微分析一下，在<code>[::-1]</code>这里， :: 让Python提供了完整的列表，而将步长设置为-1则让Python从后到前来遍历所有元素。</p><blockquote><p>这么做其实和<code>list.reverse()</code>或是<code>reverse()</code>是一样的<br>这里还有另一个列表切片技巧：使用 : 操作符清空列表中的所有元素，同时不会破坏列表对象本身。<br>这适用于在程序中有其他引用指向这个列表时清空列表。在这种情况下，通常不能用新的列表对象替换已有列表来清空列表，替换列表不会更新原列表的引用。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">del</span> a_list[:]<br><span class="hljs-meta">&gt;&gt;&gt; </span>a_list<br>[]<br></code></pre></td></tr></table></figure><blockquote><p>在Python3中也可以使用<code>a_list.clear()</code>完成同样的工作，而且这种方式在某些情况下可读性更好。<br>也就是说，我们还能利用这个技巧，用切片来在不创建新列表对象的情况下替换列表中的所有元素：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">&gt;&gt;&gt; </span>a_list = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>b_list = a_list<br><span class="hljs-meta">&gt;&gt;&gt; </span>a_list[:] = [<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>a_list<br>[<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>b_list<br>[<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>b_list <span class="hljs-keyword">is</span> a_list<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>利用 : 操作符还可以创建现有列表的浅副本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">&gt;&gt;&gt; </span>copied_list = a_list[:]<br><span class="hljs-meta">&gt;&gt;&gt; </span>copied_list<br>[<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>copied_list <span class="hljs-keyword">is</span> a_list<br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>创建浅副本意味着只复制元素的结构，而不复制元素本身。两个列表中的每个元素都是相同的实例。<br>如果需要复制所有内容（包括元素），则需要创建列表的深副本。创建深副本可以使用Python内置的copy模块。</p>          </div><h2 id="迭代器">迭代器</h2><h3 id="什么是迭代器？">什么是迭代器？</h3><blockquote><p>“迭代器（iterator），是确使用户可在容器对象（container，例如链表或数组）上遍访的对象，设计人员使用此接口无需关心容器对象的内存分配的实现细节。其行为很像数据库技术中的光标（cursor）。”——维基百科<br>举个例子，列表就属于迭代器，因此列表能用于for-in循环：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Python">numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> numbers:<br>    <span class="hljs-built_in">print</span>(num)<br></code></pre></td></tr></table></figure><p>在Python中，只要对象支持<code>__iter__</code>和<code>__next__</code>双下划线方法（或者说支持迭代器协议），那么就能使用for-in循环。正是由于这个特点，使得我们在需要遍历一个对象中的某些内容时能通过使用迭代器而变得十分方便。<br>所以我们可以编写一个支持迭代器协议的类，从而对这个类创建的实例使用for-in循环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Repeater</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, value</span>):<br>        self.value = value<br>            <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__next__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self.value<br></code></pre></td></tr></table></figure><p>这里编写了一个Repeater类，该类在迭代时类的实例会重复返回同一个值，效果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">&gt;&gt;&gt; </span>repeater = Repeater(<span class="hljs-string">&#x27;Hello&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> repeater:<br><span class="hljs-built_in">print</span>(item)<br>    <br>Hello<br>Hello<br>...<br>Hello<br>Hello<br></code></pre></td></tr></table></figure><p>其实到这迭代器就可以算介绍完了。看到这里，我相信有些人可以理解，但是有些人会觉得挺抽象的（因为我就觉得），也没搞明白到底是个什么工作原理，怎么iter返回个self啊，next返回个value什么的，所以下面会以书上的另一种方式再次解读迭代器。</p><blockquote><p>还是用到上面的Repeater类为例子，但是这里我们把它拆分为两个类（Repeater、RepeaterIterator）来分别实现迭代器协议中的两个方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Repeater</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, value</span>):<br>        self.value = value<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> RepeaterIterator(self)<br>    <br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RepeaterIterator</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, source</span>):<br>        self.source = source<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__next__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self.source.value<br></code></pre></td></tr></table></figure><p>我们要关注的是上面的<code>__iter__</code>和<code>__next__</code>两个方法以及RepeaterIterator类。<br>首先是<code>__iter__</code>。<code>__iter__</code>创建并返回了RepeaterIterator对象，从意思上看，也能说创建了一个Repeater类的迭代器对象。<br>然后就是RepeaterIterator类，我们要注意以下两点：<br>（1）在<code>__init__</code>方法中，每个RepeaterIterator实例都链接到创建它的Repeater对象。这样可以持有迭代的“源”（source）对象。<br>（2）在<code>RepeaterIterator.__next__</code>中，回到“源”Repeater实例并返回与其关联的值。<br>如此一来，我们便可以在for-in中使用Repeater实例。那么for-in循环又是怎么工作的呢？看下面一段代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Python">repeater = Repeater(<span class="hljs-string">&#x27;Hello&#x27;</span>)<br>iterator = repeator.__iter__()<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    item = iterator.__next__()<br>    <span class="hljs-built_in">print</span>(item)<br></code></pre></td></tr></table></figure><p>首先让repeater对象准备迭代，即调用<code>__iter__</code>方法来返回实际的迭代器对象。<br>然后循环反复调用迭代器对象的<code>__next__</code>方法，从中获取值。<br>如果有数据库相关知识，你还会发现迭代器和游标的相似之处：首先初始化游标并准备读取，然后从中逐个取出数据存入局部变量中。<br>无论是元素列表、字典，还是Repeater类提供的无限序列，或是其他序列类型，对于迭代器来说只是实现细节不同。迭代器能以相同的方式遍历这些对象中的元素。</p></blockquote><h3 id="在Python解释器会话中模拟循环使用迭代器协议的方式">在Python解释器会话中模拟循环使用迭代器协议的方式</h3><p>实际上，我们可以手动模拟这个过程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">&gt;&gt;&gt; </span>repeater = Repeater(<span class="hljs-string">&#x27;Hello&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>iterator = <span class="hljs-built_in">iter</span>(repeater)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(iterator)<br><span class="hljs-string">&#x27;Hello&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(iterator)<br><span class="hljs-string">&#x27;Hello&#x27;</span><br>...<br></code></pre></td></tr></table></figure><p>在这里，我们没有使用双下划线方法，作为替代，我们使用了Python内置函数<code>iter()</code>和<code>next()</code>。<br>这些内置函数在内部会调用相同的双下划线方法，为迭代器协议提供一个简洁的封装（facade）。</p><h3 id="有限迭代">有限迭代</h3><p>既然可以手动模拟迭代过程，我们不妨来学习一下其他实现了迭代器协议的对象是怎么停下迭代的。<br>就用开头那个列表作为例子，让我们手动模拟一下它的迭代过程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">&gt;&gt;&gt; </span>iterator = <span class="hljs-built_in">iter</span>(numbers)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(iterator)<br><span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(iterator)<br><span class="hljs-number">2</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(iterator)<br><span class="hljs-number">3</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(iterator)<br>StopIteration<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(iterator)<br>StopIteration<br>...<br></code></pre></td></tr></table></figure><p>可以看到，在遍历完列表中的所有元素后，继续调用<code>next()</code>函数将会抛出StopIteration异常。<br>所以我们也可以在我们自己编写的支持迭代器协议的类中，通过抛出StopIteration异常来停止迭代。<br>下面是书上的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BoundedRepeater</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, value, max_repeats</span>):<br>        self.value = value<br>        self.max_repeats = max_repeats<br>        self.count = <span class="hljs-number">0</span><br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__next__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> self.count &gt;= self.max_repeats:<br>            <span class="hljs-keyword">raise</span> StopIteration<br>        self.count += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> self.value<br></code></pre></td></tr></table></figure><h2 id="生成器">生成器</h2><h3 id="什么是生成器">什么是生成器</h3><p>生成器说白了吧，就是简化版的迭代器。它不是基于类的迭代器，而是基于函数的迭代器，因此也不需要实现两个双下划线方法，而且在生成器中不是使用return语句，而是使用yield语句将数据传回给调用者：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">repeater</span>(<span class="hljs-params">value</span>):<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br><span class="hljs-keyword">yield</span> value<br></code></pre></td></tr></table></figure><p>这样一个简单的无限生成器就写好了，很简单对吧！虽然它像普通函数，但是要注意，调用生成器函数并不会运行该函数，而是仅仅创建并返回一个生成器对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">&gt;&gt;&gt; </span>repeater(<span class="hljs-string">&#x27;Hey&#x27;</span>)<br>&lt;generator <span class="hljs-built_in">object</span> repeater at <span class="hljs-number">0x00000188C0A32E40</span>&gt;<br></code></pre></td></tr></table></figure><p>只有在生成器对象上调用<code>next()</code>时才会执行生成器函数中的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">&gt;&gt;&gt; </span>generator_obj = repeater(<span class="hljs-string">&#x27;Hey&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(generator_obj)<br><span class="hljs-string">&#x27;Hey&#x27;</span><br></code></pre></td></tr></table></figure><blockquote><p>return 和 yield 的区别<br>1.当函数内部调用return语句时，控制权会永久性地交还给函数的调用者。在调用yield时，虽然控制权也是交还给函数的调用者，但只是暂时的。<br>2.return语句会丢弃函数的局部状态，而yield语句会暂停该函数并保留其局部状态。</p></blockquote><h3 id="有限生成器">有限生成器</h3><p>在基于类的迭代器中，我们通过抛出StopIteration异常来表示迭代结束，那么在生成器中呢？<br>由于生成器与基于类的迭代器完全兼容，所以背后仍然使用这种方法。<br>或者，我们可以使用更好的接口。如果控制流从生成器函数中返回，但不是通过yield语句，那么生成器就会停止：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">repeat_three_times</span>(<span class="hljs-params">value</span>):<br><span class="hljs-keyword">yield</span> value<br><span class="hljs-keyword">yield</span> value<br><span class="hljs-keyword">yield</span> value<br><span class="hljs-meta">&gt;&gt;&gt; </span>iterator = repeat_three_times(<span class="hljs-string">&#x27;Hey there&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(iterator)<br><span class="hljs-string">&#x27;Hey there&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(iterator)<br><span class="hljs-string">&#x27;Hey there&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(iterator)<br>StopIteration<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(iterator)<br>StopIteration<br></code></pre></td></tr></table></figure><p>知道了这些知识，我们就能够转化一下BoundedRepeater类了，让它变成一个生成器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">bounded_repeater</span>(<span class="hljs-params">value, max_repeats</span>):<br>count = <span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br><span class="hljs-keyword">if</span> count &gt;= max_repeats:<br><span class="hljs-keyword">return</span><br>count += <span class="hljs-number">1</span><br><span class="hljs-keyword">yield</span> value<br></code></pre></td></tr></table></figure><p>当然，还有更简便的版本，利用Python为每个函数的末尾添加一个隐式<code>return None</code>语句的特性，我们甚至可以这样写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">bounded_repeater</span>(<span class="hljs-params">value, max_repeats</span>):<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(max_repeats):<br><span class="hljs-keyword">yield</span> value<br></code></pre></td></tr></table></figure><h3 id="生成器表达式">生成器表达式</h3><p>生成器表达式通过一行代码来定义迭代器。看到这个，我们很快就能联想到列表解析式。是的，生成器表达式的确和列表表达式非常相似：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">&gt;&gt;&gt; </span>listcomp = [<span class="hljs-string">&#x27;Hello&#x27;</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>)]<br><span class="hljs-meta">&gt;&gt;&gt; </span>genexpr = (<span class="hljs-string">&#x27;Hello&#x27;</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>))<br></code></pre></td></tr></table></figure><p>和列表解析式相同，生成器表达式也可以添加条件从而来过滤一些元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">&gt;&gt;&gt; </span>even_squares = (x * x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">if</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> even_squares:<br>...   <span class="hljs-built_in">print</span>(x)<br><span class="hljs-number">0</span><br><span class="hljs-number">4</span><br><span class="hljs-number">16</span><br><span class="hljs-number">36</span><br><span class="hljs-number">64</span><br></code></pre></td></tr></table></figure><p>和列表解析式不同，生成器表达式不会构造列表对象，而是像基于类的迭代器或生成器函数那样“即时”生成值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">&gt;&gt;&gt; </span>listcomp<br>[<span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-string">&#x27;Hello&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>genexpr<br>&lt;generator <span class="hljs-built_in">object</span> &lt;genexpr&gt; at <span class="hljs-number">0x00000188C0A32DD0</span>&gt;<br></code></pre></td></tr></table></figure><p>我们也可以归纳一下，得出一个生成器表达式的模板：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Python">genexpr = (expression <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> collection <span class="hljs-keyword">if</span> condition)<br></code></pre></td></tr></table></figure><blockquote><p>这个模板也可以看成下边的生成器函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">generator</span>():<br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> collection:<br>        <span class="hljs-keyword">if</span> condition:<br>            <span class="hljs-keyword">yield</span> expression<br></code></pre></td></tr></table></figure></blockquote><div class="note note-warning">            <p>生成器表达式一经使用就不能重新启动或重用，所以在某些情况下生成器函数或基于类的迭代器更加合适。</p>          </div><h3 id="内联生成器表达式">内联生成器表达式</h3><p>因为生成器表达式也是表达式，所以可以与其他语句一起内联使用。例如，可以定义一个迭代器并立即在for循环中使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> (<span class="hljs-string">&#x27;Test&#x27;</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>)):<br><span class="hljs-built_in">print</span>(x)<br></code></pre></td></tr></table></figure><p>另外还有一个语法技巧可以美化生成器表达式。如果生成器表达式是作为函数中的单个参数使用，那么可以删除生成器表达式外层的括号：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">sum</span>((x * <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)))<br><span class="hljs-number">90</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">sum</span>(x * <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>))<br><span class="hljs-number">90</span><br></code></pre></td></tr></table></figure><h2 id="迭代器链">迭代器链</h2><p>Python中的迭代器还有另一个重要特性：可以链接多个迭代器，从而编写高效的数据处理“管道”。<br>普通函数只会产生一次返回值，而生成器会多次产生结果。可以认为生成器在整个生命周期中能<strong>产生值的“流”</strong>。下面用例子来说明：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">integers</span>():<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">9</span>):<br><span class="hljs-keyword">yield</span> i<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">squared</span>(<span class="hljs-params">seq</span>):<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> seq:<br><span class="hljs-keyword">yield</span> i * i<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">negated</span>(<span class="hljs-params">seq</span>):<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> seq:<br><span class="hljs-keyword">yield</span> -i<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>chain = negated(squared(integers()))<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(chain)<br>[-<span class="hljs-number">1</span>, -<span class="hljs-number">4</span>, -<span class="hljs-number">9</span>, -<span class="hljs-number">16</span>, -<span class="hljs-number">25</span>, -<span class="hljs-number">36</span>, -<span class="hljs-number">49</span>, -<span class="hljs-number">64</span>]<br></code></pre></td></tr></table></figure><p>在这里，先是由integers()生成器产生值的“流”，然后送入squared()生成器，squared()生成器根据值再生成值，再送入negated()生成器中生成最后的值。</p><blockquote><p>在生成器链中，每次只处理一个元素，这说明链中的处理步骤之间没有缓冲区。下面是详细步骤：</p><ol><li>integers生成器产生一个值，如3.</li><li>这个值“激活”squared生成器来处理，得到3 * 3 = 9，并将其传递到下一阶段。</li><li>由squared生成器产生的平方数立即送入negated生成器，将其修改为-9并再次yield。</li></ol></blockquote><h1>一些无关的话</h1><p>放假后真的是太懒啦，也是各种作息混乱加上在外游玩又或者干脆睡觉摆烂以至于根本没怎么学（土下座.jpg）。下次更新也是这本好书的最后一章啦，一定会在开学前学完的（确信），就这样啦~</p><hr><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>《Python Tricks 深入理解python特性》 [德]达恩·巴德尔 人民邮电出版社<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Learning Log</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python中的数据结构</title>
    <link href="/2022/07/09/python-learning-4/"/>
    <url>/2022/07/09/python-learning-4/</url>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>其实忙碌的期末周已经过去一个星期多了，但是我又咸🐟了整整一个星期没在学习所以导致博客断更了好长一段时间www<br>正好学到了Python中的数据结构，而我也有复习数据结构的打算，所以很快啊，我就来水（bushi）博文了。<br>Python中的数据结构其实挺多的，而且不像其它语言一样，比如Java中就把列表分为LinkedList和ArrayList，但是在Python中就更“抽象”。所以还是非常有必要下相当一部分功夫的。</p><h1>正文</h1><h2 id="数组数据结构">数组数据结构</h2><p>从我们熟悉而且常用的老朋友——数组开始介绍。在Python中，数组可以是固定大小的，也可以是动态的，可以只装一种数据类型，也可以装很多种，这些都会在后边一一介绍。现在，先来了解一下数组的原理和用途。</p><blockquote><p>数组由大小固定的数据记录组成，根据索引能快速找到其中的每个元素。<br>因为数组将信息存储在依次连接的内存块中，所以它是<strong>连续</strong>的数据结构。</p></blockquote><h3 id="列表——可变动态数组">列表——可变动态数组</h3><p>Python里边常用的列表，即list，就是以动态数组实现的。它实现了增删查改功能，而且可以包含任何对象（也就是说可以装不同的数据类型）。</p><blockquote><p>这个功能很强大，但缺点是同时支持多种数据类型会导致数据存储得不是很紧凑。因此整个结构占据了更多的空间。<br>本质上是因为列表中存储的是PyObject指针，指向不同的对象。然而（其它）数组是直接存放数据本身。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>arr[<span class="hljs-number">0</span>]<br><span class="hljs-number">1</span><br><br><span class="hljs-comment"># 列表的__repr__方法</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>arr<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><br><span class="hljs-comment"># 列表是可变的，且可以含有任意类型的数据</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>arr[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;two&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>arr<br>[<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;two&#x27;</span>, <span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><p>想了解更多有关list的知识，可以翻阅官方文档：<a href="https://docs.python.org/3.9/library/stdtypes.html#list">List</a></p><h3 id="元组——不可变容器">元组——不可变容器</h3><p>元组也是非常熟悉的一个Python中的序列类型了。与列表不同的是，Python的元组对象是不可变的，创建了元组之后，我们就不能对这个元组进行修改了。有些看上去是修改了元组的语法，本质上是创建了一个新的元组，而不是修改原来的元组。<br>和列表一样，元组也可以包含任意数据类型的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>arr = <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>arr[<span class="hljs-number">0</span>]<br><span class="hljs-number">1</span><br><br><span class="hljs-comment"># 元组的__repr__方法</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>arr<br>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><br><span class="hljs-comment"># 元组是不可变的</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>arr[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;two&#x27;</span><br>TypeError: <span class="hljs-string">&#x27;tuple&#x27;</span> <span class="hljs-built_in">object</span> does <span class="hljs-keyword">not</span> support item assignment<br><br><span class="hljs-comment"># 元组可以包含任意类型的数据(注意，这里并没有修改原本的元组，而是创建了一个新的元组)</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>arr + (<span class="hljs-number">23</span>,)<br>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">23</span>)<br></code></pre></td></tr></table></figure><p>想了解更多有关tuple的知识，可以翻阅官方文档：<a href="https://docs.python.org/3.9/library/stdtypes.html#tuple">Tuple</a></p><h3 id="array-array——基本类型数组">array.array——基本类型数组</h3><p>利用array.array创建的数组也是可变的，但是它是只能包含单一数据类型的“<a href="https://docs.python.org/3/library/array.html?highlight=array%20array#array.array">类型数组</a>”,因此它也比列表和元组更为节省空间。<br>此外，数组中也有许多普通列表中含有的方法，使用方式也相同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> array<br><span class="hljs-meta">&gt;&gt;&gt; </span>arr = array.array(<span class="hljs-string">&#x27;f&#x27;</span>, (<span class="hljs-number">1.0</span>, <span class="hljs-number">1.5</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">2.5</span>))<br><span class="hljs-meta">&gt;&gt;&gt; </span>arr[<span class="hljs-number">1</span>]<br><span class="hljs-number">1.5</span><br><br><span class="hljs-comment"># array.array的__repr__方法</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>arr<br>array(<span class="hljs-string">&#x27;f&#x27;</span>, [<span class="hljs-number">1.0</span>, <span class="hljs-number">1.5</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">2.5</span>])<br><br><span class="hljs-comment"># array.array中数据类型是单一的</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>arr[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;one&#x27;</span><br>TypeError: must be real number, <span class="hljs-keyword">not</span> <span class="hljs-built_in">str</span><br></code></pre></td></tr></table></figure><h3 id="str——含有Unicode字符的不可变数组">str——含有Unicode字符的不可变数组</h3><p>Python中的str实际上是不可变的字符数组，而且，str还是一种递归的数据结构，字符串中的每个字符都是长度为1的str对象（很奇怪吧，我也觉得）。<br>如果需要一个可变字符串，Python并不能像Java那样直接拿出一个StringBuffer，而是只能利用列表来作为可变字符串。</p><blockquote><p>python3.x使用str对象将文本数据存储为不可变的Unicode字符序列。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>arr = <span class="hljs-string">&#x27;hello&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>arr[<span class="hljs-number">1</span>]<br><span class="hljs-string">&#x27;e&#x27;</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>arr<br><span class="hljs-string">&#x27;hello&#x27;</span><br><br><span class="hljs-comment"># 字符串是不可变的</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>arr[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;e&#x27;</span><br>TypeError: <span class="hljs-string">&#x27;str&#x27;</span> <span class="hljs-built_in">object</span> does <span class="hljs-keyword">not</span> support item assignment<br><br><span class="hljs-comment"># 字符串是递归型数据类型</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(<span class="hljs-string">&#x27;hello&#x27;</span>)<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;str&#x27;</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(<span class="hljs-string">&#x27;hello&#x27;</span>[<span class="hljs-number">1</span>])<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;str&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>想了解更多有关str的知识，可以翻阅官方文档：<a href="https://docs.python.org/3/library/stdtypes.html#text-sequence-type-str">Str</a></p><h3 id="bytes——含有单字节的不可变数组">bytes——含有单字节的不可变数组</h3><p>bytes对象是单字节的不可变序列，单字节为[0, 255]范围内的整数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>arr = <span class="hljs-built_in">bytes</span>((<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>))<br><span class="hljs-meta">&gt;&gt;&gt; </span>arr[<span class="hljs-number">1</span>]<br><span class="hljs-number">1</span><br><br><span class="hljs-comment"># bytes有自己的语法</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>arr<br><span class="hljs-string">b&#x27;\x00\x01\x02\x03&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>arr = <span class="hljs-string">b&#x27;\x00\x11\x22\x33&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>arr<br><span class="hljs-string">b&#x27;\x00\x01\x02\x03&#x27;</span><br></code></pre></td></tr></table></figure><div class="note note-info">            <p>bytes可以解包到bytearray中。</p>          </div><p>想了解更多有关bytes的知识，可以翻阅官方文档：<a href="https://docs.python.org/3/library/stdtypes.html#bytes">Bytes</a></p><h3 id="bytearray——含有单字节的可变数组">bytearray——含有单字节的可变数组</h3><p>bytearray类型是可变整数序列，包含的整数范围和bytes一样，也是[0, 255]。<br>bytearray数可以转换回不可变的bytes对象，但是这需要复制所存储的数据，是耗时为**O(n)**的慢操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>arr = <span class="hljs-built_in">bytearray</span>((<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>))<br><span class="hljs-meta">&gt;&gt;&gt; </span>arr[<span class="hljs-number">1</span>]<br><span class="hljs-number">1</span><br><br><span class="hljs-comment"># bytearray的__repr__方法</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>arr<br><span class="hljs-built_in">bytearray</span>(<span class="hljs-string">b&#x27;\x00\x01\x02\x03&#x27;</span>)<br><br><span class="hljs-comment"># bytearray可以转换回byte对象，此过程会复制数据</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">bytes</span>(arr)<br><span class="hljs-string">b&#x27;\x00\x01\x02\x03&#x27;</span><br></code></pre></td></tr></table></figure><p>想了解更多有关bytearray的知识，可以翻阅官方文档：<a href="https://docs.python.org/3/library/stdtypes.html#bytearray">Bytes Array</a></p><h2 id="字典数据结构">字典数据结构</h2><p>Python里边第二熟悉的数据结构应该就是字典了。字典可以存储任意数量的对象，每个对象都是一个<strong>值</strong>，每个<strong>值</strong>都被唯一的字典<strong>键</strong>标识。<br>字典通常也被称为<strong>映射</strong>、<strong>散列表</strong>、<strong>查找表</strong>或<strong>关联数组</strong>。<br>在Python中，通常字典都是由dict实现，不过当dict不能满足某些需求的时候，Python还提供了一些特殊字典（尽管特殊，但他们都基于内置的字典类dict）以供使用。</p><h3 id="dict——首选字典实现">dict——首选字典实现</h3><p>Python中最稳健的字典实现就是dict。为方便使用，Python还提供了一些有用的“语法糖”来处理程序中的字典。例如，用花括号字典表达式语法和字典解析式能够方便地创建新的字典对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">number = &#123;<br>    <span class="hljs-string">&#x27;one&#x27;</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-string">&#x27;two&#x27;</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-string">&#x27;three&#x27;</span>: <span class="hljs-number">3</span>,<br>&#125;<br>squares = &#123;x: x * x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>)&#125;<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>number[<span class="hljs-string">&#x27;two&#x27;</span>]<br><span class="hljs-number">2</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>squares<br>&#123;<span class="hljs-number">0</span>: <span class="hljs-number">0</span>, <span class="hljs-number">1</span>: <span class="hljs-number">1</span>, <span class="hljs-number">2</span>: <span class="hljs-number">4</span>, <span class="hljs-number">3</span>: <span class="hljs-number">9</span>, <span class="hljs-number">4</span>: <span class="hljs-number">16</span>, <span class="hljs-number">5</span>: <span class="hljs-number">25</span>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Python的字典由<a href="https://docs.python.org/3/glossary.html#term-hashable">可散列类型</a>的键来索引。 可散列对象具有在其生命周期中永远不会改变的散列值（参见<code>__hash__</code>），并且可以与其他对象进行比较（参见<code>__eq__</code>）。另外，相等的可散列对象，其散列值必然相同。<br>像字符串和数这样的不可变类型是可散列的，它们可以很好地用作字典键。元组对象也可以用作字典键，但这些元组本身必须只包含可散列类型。<br>想了解更多有关dict的知识，可以翻阅官方文档：<a href="https://docs.python.org/3/library/stdtypes.html#mapping-types-dict">Mapping Types — dict</a></p></blockquote><h3 id="collections-OrderDict——能记住键的插入顺序">collections.OrderDict——能记住键的插入顺序</h3><p>collections.OrderDict是特别的dict子类，该类型会记录添加到其中的键的插入顺序。</p><div class="note note-info">            <p>在Python3.7以后，标准的字典实现会保留键的插入顺序这一特性被固定下来了，当然，这只是CPython实现的一个副作用，如果在自己的工作中很需要用到键顺序，最好明确使用OrderedDict类。</p>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> collections<br><span class="hljs-meta">&gt;&gt;&gt; </span>d = collections.OrderedDict(one = <span class="hljs-number">1</span>, two = <span class="hljs-number">2</span>, three = <span class="hljs-number">3</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>d<br>OrderedDict([(<span class="hljs-string">&#x27;one&#x27;</span>, <span class="hljs-number">1</span>), (<span class="hljs-string">&#x27;two&#x27;</span>, <span class="hljs-number">2</span>), (<span class="hljs-string">&#x27;three&#x27;</span>, <span class="hljs-number">3</span>)])<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>d[<span class="hljs-string">&#x27;four&#x27;</span>] = <span class="hljs-number">4</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>d<br>OrderedDict([(<span class="hljs-string">&#x27;one&#x27;</span>, <span class="hljs-number">1</span>), (<span class="hljs-string">&#x27;two&#x27;</span>, <span class="hljs-number">2</span>), (<span class="hljs-string">&#x27;three&#x27;</span>, <span class="hljs-number">3</span>), (<span class="hljs-string">&#x27;four&#x27;</span>, <span class="hljs-number">4</span>)])<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>d.keys()<br>odict_keys([<span class="hljs-string">&#x27;one&#x27;</span>, <span class="hljs-string">&#x27;two&#x27;</span>, <span class="hljs-string">&#x27;three&#x27;</span>, <span class="hljs-string">&#x27;four&#x27;</span>])<br></code></pre></td></tr></table></figure><p>想了解更多有关collections.OrderedDict的知识，可以翻阅官方文档：<a href="https://docs.python.org/3/library/collections.html?highlight=collections%20ordereddict#collections.OrderedDict">collections.OrderedDict</a></p><h3 id="collections-defaultdict——为缺失的键返回默认值">collections.defaultdict——为缺失的键返回默认值</h3><p>defaultdict是另一个dict子类，其构造函数接受一个可调用对象，查找时如果找不到给定的键，就返回这个可调用对象。</p><blockquote><p>与使用<code>get()</code>方法或在普通字典中捕获KeyError异常相比，这种方式的代码较少，并能清晰地表达出程序员的意图。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict<br><span class="hljs-meta">&gt;&gt;&gt; </span>d = defaultdict(<span class="hljs-built_in">list</span>)<br><br><span class="hljs-comment"># 访问缺失的键就会用默认工厂方法创建它并初始化</span><br><span class="hljs-comment"># 在本例中工厂方法为list()</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>d[<span class="hljs-string">&#x27;none&#x27;</span>].append(<span class="hljs-number">1</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>d[<span class="hljs-string">&#x27;none&#x27;</span>].append(<span class="hljs-number">2</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>d[<span class="hljs-string">&#x27;none&#x27;</span>].append(<span class="hljs-number">3</span>)<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>d[<span class="hljs-string">&#x27;none&#x27;</span>]<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><p>可以看到我们在访问缺失的键时，对象 d 自动调用了list()方法为新键的值创建列表并返回这个列表。<br>想了解更多有关collections.defaultdict的知识，可以翻阅官方文档：<a href="https://docs.python.org/3/library/collections.html?highlight=collections%20defaultdict#collections.defaultdict">collections.defaultdict</a></p><h3 id="collections-ChainMap——搜索多个字典">collections.ChainMap——搜索多个字典</h3><p>collections.ChainMap将多个字典分组到一个映射中，在查找时逐个搜索底层映射，直到找到一个符合条件的键。对ChainMap进行插入、更新和删除操作，只会作用于其中的第一个字典。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> ChainMap<br><span class="hljs-meta">&gt;&gt;&gt; </span>d1 = &#123;<span class="hljs-string">&#x27;one&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;two&#x27;</span>: <span class="hljs-number">2</span>,&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>d2 = &#123;<span class="hljs-string">&#x27;three&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;four&#x27;</span>: <span class="hljs-number">4</span>,&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>chainDict = ChainMap(d1, d2)<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>chainDict<br>ChainMap(&#123;<span class="hljs-string">&#x27;one&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;two&#x27;</span>: <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-string">&#x27;three&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;four&#x27;</span>: <span class="hljs-number">4</span>&#125;)<br><br><span class="hljs-comment"># ChinaMap在内部从左到右逐个搜索，直到找到对应的键或全部搜索完毕。</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>chainDict[<span class="hljs-string">&#x27;three&#x27;</span>]<br><span class="hljs-number">3</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>chainDict[<span class="hljs-string">&#x27;one&#x27;</span>]<br><span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>chainDict[<span class="hljs-string">&#x27;none&#x27;</span>]<br>KeyError: <span class="hljs-string">&#x27;none&#x27;</span><br></code></pre></td></tr></table></figure><p>直观地看，我就觉得这东西像是一个包含字典的列表（像啊，很像啊！），操作（如查找）更方便的字典列表（误）。<br>想了解更多有关collections.ChainMap的知识，可以翻阅官方文档：<a href="https://docs.python.org/3/library/collections.html?highlight=collections%20chainmap#collections.ChainMap">collections.ChainMap</a></p><h3 id="types-MappingProxyType——用于创建只读字典">types.MappingProxyType——用于创建只读字典</h3><p>MappingProxyType封装了标准的字典，为封装的字典数据提供只读视图。<br>举例来说，如果希望返回一个字典来表示类或模块的内部状态，同时禁止向该对象写入内容，此时MappingProxyType就能派上用场。使用MappingProxyType无需创建完整的字典副本。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> types <span class="hljs-keyword">import</span> MappingProxyType<br><span class="hljs-meta">&gt;&gt;&gt; </span>writable = &#123;<span class="hljs-string">&#x27;one&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;two&#x27;</span>: <span class="hljs-number">2</span>,&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>readOnly = MappingProxyType(writable)<br><br><span class="hljs-comment"># 代理是只读的</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>readOnly[<span class="hljs-string">&#x27;one&#x27;</span>]<br><span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>readOnly[<span class="hljs-string">&#x27;one&#x27;</span>] = <span class="hljs-string">&#x27;one&#x27;</span><br>TypeError: <span class="hljs-string">&#x27;mappingproxy&#x27;</span> <span class="hljs-built_in">object</span> does <span class="hljs-keyword">not</span> support item assignment<br><br><span class="hljs-comment"># 更新原字典也会影响代理</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>writable[<span class="hljs-string">&#x27;one&#x27;</span>] = <span class="hljs-string">&#x27;one&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>readOnly<br>mappingproxy(&#123;<span class="hljs-string">&#x27;one&#x27;</span>: <span class="hljs-string">&#x27;one&#x27;</span>, <span class="hljs-string">&#x27;two&#x27;</span>: <span class="hljs-number">2</span>&#125;)<br></code></pre></td></tr></table></figure><p>想了解更多有关types.MappingProxyType的知识，可以翻阅官方文档：<a href="https://docs.python.org/3/library/types.html?highlight=types%20mappingproxytype#types.MappingProxyType">types.MappingProxyType</a></p><h2 id="记录、结构体和纯数据对象">记录、结构体和纯数据对象</h2><blockquote><p>与数组相比，记录数据结构中的字段数目固定，每个都有一个名称，类型也可以不同。<br>从这个概念出发，我们很容易地可以想到用python中的字典来实现记录，也可以用元组来实现没有字段名称的特殊记录。但是前者的缺点是没有对字段名称进行保护，后者则是没有字段名称。好在python中还提供了一些数据类型或类来帮助实现这些数据结构。</p></blockquote><h3 id="collections-namedtuple——方便的数据对象">collections.namedtuple——方便的数据对象</h3><p>namedtuple可以看作是普通元组的拓展，也是不可变容器，但是它的每个字段都有名称。也就是说，namedtuple是<strong>具有名称的元组</strong>。<br>namedtuple非常适合在python中以节省内存的方式快速手动定义一个不可变的类，所以也很适合用于实现记录数据类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> namedtuple<br><span class="hljs-meta">&gt;&gt;&gt; </span>Car = namedtuple(<span class="hljs-string">&#x27;Car&#x27;</span>, <span class="hljs-string">&#x27;color mileage automatic&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>car1 = Car(<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-number">3812.4</span>, <span class="hljs-literal">True</span>)<br><br><span class="hljs-comment"># 实例的__repr__方法</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>car1<br>Car(color=<span class="hljs-string">&#x27;red&#x27;</span>, mileage=<span class="hljs-number">3812.4</span>, automatic=<span class="hljs-literal">True</span>)<br><br><span class="hljs-comment"># 访问字段</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>car1.mileage<br><span class="hljs-number">3812.4</span><br><br><span class="hljs-comment"># 字段是不可变的</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>car1.mileage = <span class="hljs-number">12</span><br>AttributeError: can<span class="hljs-string">&#x27;t set attribute</span><br><span class="hljs-string">&gt;&gt;&gt; car1.windshield = &#x27;</span>broken<span class="hljs-string">&#x27;</span><br><span class="hljs-string">AttributeError: &#x27;</span>Ca<span class="hljs-string">r&#x27; object has no attribute &#x27;</span>windshield<span class="hljs-string">&#x27;</span><br></code></pre></td></tr></table></figure><p>想了解更多有关namedtuple的知识，可以翻阅官方文档：<a href="https://docs.python.org/3/library/collections.html?highlight=collections%20namedtuple#collections.namedtuple">collections.namedtuple</a></p><h3 id="typing-NamedTuple——改进版namedtuple">typing.NamedTuple——改进版namedtuple</h3><p>NamedTuple与namedtuple的主要区别就在于用新语法来定义记录类型并支持类型注解（type hint）。</p><blockquote><p>注意，只有像mypy这样独立的类型检查工具才会在意类型注解。不过即使没有工具支持，类型注解也可帮助其他程序员更好地理解代码（如果类型注解没有随代码及时更新则会带来混乱）。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> NamedTuple<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>(<span class="hljs-title class_ inherited__">NamedTuple</span>):<br>color: <span class="hljs-built_in">str</span><br>mileage: <span class="hljs-built_in">float</span><br>automatic: <span class="hljs-built_in">bool</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>car1 = Car(<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-number">3812.4</span>, <span class="hljs-literal">True</span>)<br><br><span class="hljs-comment"># 实例的__repr__方法</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>car1<br>Car(color=<span class="hljs-string">&#x27;red&#x27;</span>, mileage=<span class="hljs-number">3812.4</span>, automatic=<span class="hljs-literal">True</span>)<br><br><span class="hljs-comment"># 访问字段</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>car1.mileage<br><span class="hljs-number">3812.4</span><br><br><span class="hljs-comment"># 字段是不可变的</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>car1.mileage = <span class="hljs-number">12</span><br>AttributeError: can<span class="hljs-string">&#x27;t set attribute</span><br><span class="hljs-string">&gt;&gt;&gt; car1.windshield = &#x27;</span>broken<span class="hljs-string">&#x27;</span><br><span class="hljs-string">AttributeError: &#x27;</span>Ca<span class="hljs-string">r&#x27; object has no attribute &#x27;</span>windshield<span class="hljs-string">&#x27;</span><br><span class="hljs-string"></span><br><span class="hljs-string"># 只有像mypy这样的类型检查工具才会落实类型注解</span><br><span class="hljs-string">&gt;&gt;&gt; Car(&#x27;</span>red<span class="hljs-string">&#x27;, &#x27;</span>NOT_A_FLOAT<span class="hljs-string">&#x27;, 99)</span><br><span class="hljs-string">Car(color=&#x27;</span>red<span class="hljs-string">&#x27;, mileage=&#x27;</span>NOT_A_FLOAT<span class="hljs-string">&#x27;, automatic=99)</span><br></code></pre></td></tr></table></figure><p>想了解更多有关NamedTuple的知识，可以翻阅官方文档：<a href="https://docs.python.org/3/library/typing.html?highlight=typing%20namedtuple#typing.NamedTuple">typing.NamedTuple</a></p><h3 id="types-SimpleNamespace——花哨的属性访问">types.SimpleNamespace——花哨的属性访问</h3><p>SimpleNamespace同样可以用于创建数据对象，它主要提供通过属性访问的方式访问其名称空间。<br>也就是说，SimpleNamespace实例将其中的所有键都公开为类属性。因此访问属性时可以使用obj.key这样的点式语法，不需要像普通字典一样通过索引来访问值。</p><blockquote><p>正如其名，SimpleNamespace很简单，基本上就是扩展版的字典，能够很好地访问属性并以字符串打印出来，还能自由地添加、修改和访问属性。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> types <span class="hljs-keyword">import</span> SimpleNamespace<br><span class="hljs-meta">&gt;&gt;&gt; </span>car1 = SimpleNamespace(color = <span class="hljs-string">&#x27;red&#x27;</span>, mileage = <span class="hljs-number">3812.4</span>, automatic = <span class="hljs-literal">True</span>)<br><br><span class="hljs-comment"># 实例的__repr__方法</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>car1<br>namespace(color=<span class="hljs-string">&#x27;red&#x27;</span>, mileage=<span class="hljs-number">3812.4</span>, automatic=<span class="hljs-literal">True</span>)<br><br><span class="hljs-comment"># 实例支持属性访问并且是可变的</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>car1.mileage = <span class="hljs-number">12</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>car1.windshield = <span class="hljs-string">&#x27;broken&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">del</span> car1.automatic<br><span class="hljs-meta">&gt;&gt;&gt; </span>car1<br>namespace(color=<span class="hljs-string">&#x27;red&#x27;</span>, mileage=<span class="hljs-number">12</span>, windshield=<span class="hljs-string">&#x27;broken&#x27;</span>)<br></code></pre></td></tr></table></figure><p>想了解更多有关SimpleNamespace的知识，可以翻阅官方文档：<a href="https://docs.python.org/3/library/types.html?highlight=types%20simplenamespace#types.SimpleNamespace">types.SimpleNamespace</a></p><h3 id="为什么没有struct-Struct？">为什么没有struct.Struct？</h3><p>因为我认为这个东西太过高级<s>（懒）</s>，如同书中所说：“大多数情况下这都属于高级（且可能不必要的）优化。”如果想了解可以自行翻阅相关文档。</p><h2 id="集合和多重集合">集合和多重集合</h2><p><strong>集合</strong>含有一组不含重复元素的<strong>无序</strong>对象。集合可用来快速检查元素的包含性，插入或删除值，计算两个集合的并集或交集。<br>在python中，集合和字典一样，也拥有语法糖：利用花括号表达式就可以快速创建集合，但是要注意，如果需要创建<strong>空集</strong>（不含任何元素的集合），就要用<code>set()</code>构造函数，如果用空花括号<code>&#123;&#125;</code>的话，创建的是一个空字典。</p><h3 id="set——首选集合实现">set——首选集合实现</h3><p>set就是Python中的内置集合实现，可以看成是最基本的集合。set类型是可变的，能够动态插入和删除元素，所有可散列的对象都可以存储在集合中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>animal = &#123;<span class="hljs-string">&#x27;cat&#x27;</span>, <span class="hljs-string">&#x27;bird&#x27;</span>, <span class="hljs-string">&#x27;dog&#x27;</span>, <span class="hljs-string">&#x27;panda&#x27;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&#x27;cat&#x27;</span> <span class="hljs-keyword">in</span> animal<br><span class="hljs-literal">True</span><br><br><span class="hljs-comment"># intersection方法返回包含存在于集合 x 和集合 y 中的项目的集合（返回集合 x 和集合 y 的交集）</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>my_pet = &#123;<span class="hljs-string">&#x27;cat&#x27;</span>, <span class="hljs-string">&#x27;dog&#x27;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>my_pet.intersection(animal)<br>&#123;<span class="hljs-string">&#x27;dog&#x27;</span>, <span class="hljs-string">&#x27;cat&#x27;</span>&#125;<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>animal.add(<span class="hljs-string">&#x27;bat&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>animal<br>&#123;<span class="hljs-string">&#x27;dog&#x27;</span>, <span class="hljs-string">&#x27;cat&#x27;</span>, <span class="hljs-string">&#x27;bat&#x27;</span>, <span class="hljs-string">&#x27;panda&#x27;</span>, <span class="hljs-string">&#x27;bird&#x27;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">len</span>(animal)<br><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>想了解更多有关set的知识，可以翻阅官方文档：<a href="https://docs.python.org/3/library/stdtypes.html?highlight=set#set">set</a></p><h3 id="frozenset——不可变集合">frozenset——不可变集合</h3><p>其实看名字就知道这是什么东西啦，就是一个静态集合，里边的元素只读不改。因此frozenset是可用作字典的键的（静态且可散列），也可以放置在另一个集合中，这些都是set没办法做到的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>vowels = <span class="hljs-built_in">frozenset</span>(&#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;u&#x27;</span>&#125;)<br><span class="hljs-meta">&gt;&gt;&gt; </span>vowels.add(<span class="hljs-string">&#x27;p&#x27;</span>)<br>AttributeError: <span class="hljs-string">&#x27;frozenset&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;add&#x27;</span><br><br><span class="hljs-comment"># frozenset用作字典键</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>d = &#123;<span class="hljs-built_in">frozenset</span>(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;): <span class="hljs-string">&#x27;hello&#x27;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>d[<span class="hljs-built_in">frozenset</span>(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;)]<br><span class="hljs-string">&#x27;hello&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>key = <span class="hljs-built_in">frozenset</span>(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;)<br><span class="hljs-meta">&gt;&gt;&gt; </span>d[key]<br><span class="hljs-string">&#x27;hello&#x27;</span><br></code></pre></td></tr></table></figure><p>想了解更多有关frozenset的知识，可以翻阅官方文档：<a href="https://docs.python.org/3/library/stdtypes.html?highlight=frozenset#frozenset">frozenset</a></p><h3 id="collections-Counter——多重集合">collections.Counter——多重集合</h3><p>其实这个东西也非常简单，就是允许出现重复元素（允许在集合中多次出现同一个元素）的集合，它也叫做背包（bag）类型。</p><blockquote><p>如果既要检查元素是否为集合的一部分，又要记录元素在集合中出现的次数，那么就需要用到这个类型</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter<br><span class="hljs-meta">&gt;&gt;&gt; </span>inventory = Counter()<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>loot = &#123;<span class="hljs-string">&#x27;sword&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;bread&#x27;</span>: <span class="hljs-number">3</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>inventory.update(loot)<br><span class="hljs-meta">&gt;&gt;&gt; </span>inventory<br>Counter(&#123;<span class="hljs-string">&#x27;bread&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;sword&#x27;</span>: <span class="hljs-number">1</span>&#125;)<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>more_loot = &#123;<span class="hljs-string">&#x27;sword&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;apple&#x27;</span>: <span class="hljs-number">1</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>inventory.update(more_loot)<br><span class="hljs-meta">&gt;&gt;&gt; </span>inventory<br>Counter(&#123;<span class="hljs-string">&#x27;bread&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;sword&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;apple&#x27;</span>: <span class="hljs-number">1</span>&#125;)<br></code></pre></td></tr></table></figure><p>想了解更多有关Counter的知识，可以翻阅官方文档：<a href="https://docs.python.org/3/library/collections.html?highlight=counter#collections.Counter">collections.Counter</a></p><h2 id="栈与队列">栈与队列</h2><p><strong>栈</strong>是含有一组对象的容器，支持快速<strong>后进先出（LIFO）<strong>的插入（<strong>入栈push</strong>）和删除（<strong>出栈pop</strong>）操作。<br><strong>队列</strong>则是</strong>先进先出（FIFO）</strong>，插入和删除分别称作<strong>入队enqueue</strong>和<strong>出队dequeue</strong>。<br>可以很容易地想到用python内置的列表来实现，但是列表只对随机访问的性能好，对于插入和删除元素则差，所以python在这方面还提供了另外的类来实现。</p><h3 id="collections-deque——快速且稳健的栈">collections.deque——快速且稳健的栈</h3><p>deque类实现了一个双端队列，所以它既可以作为栈也可以作为队列。</p><blockquote><p>Python的deque对象以双向链表实现，这为插入和删除元素提供了出色且一致的性能，但是随机访问位于栈中间元素的性能很差，耗时为O(n)。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br><span class="hljs-meta">&gt;&gt;&gt; </span>s = deque()<br><span class="hljs-meta">&gt;&gt;&gt; </span>s.append(<span class="hljs-string">&#x27;eat&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>s.append(<span class="hljs-string">&#x27;sleep&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>s.append(<span class="hljs-string">&#x27;code&#x27;</span>)<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>s<br>deque([<span class="hljs-string">&#x27;eat&#x27;</span>, <span class="hljs-string">&#x27;sleep&#x27;</span>, <span class="hljs-string">&#x27;code&#x27;</span>])<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>s.pop()<br><span class="hljs-string">&#x27;code&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>s.pop()<br><span class="hljs-string">&#x27;sleep&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>s.pop()<br><span class="hljs-string">&#x27;eat&#x27;</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>s.pop()<br>IndexError: pop <span class="hljs-keyword">from</span> an empty deque<br></code></pre></td></tr></table></figure><p>想了解更多有关deque的知识，可以翻阅官方文档：<a href="https://docs.python.org/3/library/collections.html?highlight=collections%20deque#collections.deque">collections.deque</a></p><h3 id="queue-LifoQueue——为并行计算提供的锁语义">queue.LifoQueue——为并行计算提供的锁语义</h3><p>queue.LifoQueue这个位于Python标准库中的栈实现是同步的，提供了锁语义来支持多个并发的生产者和消费者。（可以参考一下PV操作）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> queue <span class="hljs-keyword">import</span> LifoQueue<br><span class="hljs-meta">&gt;&gt;&gt; </span>s = LifoQueue()<br><span class="hljs-meta">&gt;&gt;&gt; </span>s.put(<span class="hljs-string">&#x27;eat&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>s.put(<span class="hljs-string">&#x27;sleep&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>s.put(<span class="hljs-string">&#x27;code&#x27;</span>)<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>s<br>&lt;queue.LifoQueue <span class="hljs-built_in">object</span> at <span class="hljs-number">0x000001E3F4D22430</span>&gt;<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>s.get()<br><span class="hljs-string">&#x27;code&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>s.get()<br><span class="hljs-string">&#x27;sleep&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>s.get()<br><span class="hljs-string">&#x27;eat&#x27;</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>s.get()<br><span class="hljs-comment"># 阻塞，永远停在这里...</span><br></code></pre></td></tr></table></figure><p>想了解更多有关LifoQueue的知识，可以翻阅官方文档：<a href="https://docs.python.org/3/library/queue.html?highlight=queue%20lifoqueue#queue.LifoQueue">queue.LifoQueue</a></p><h3 id="collections-deque——快速且稳健的队列">collections.deque——快速且稳健的队列</h3><p>上边已经介绍过所以在这里不重复叙述了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br><span class="hljs-meta">&gt;&gt;&gt; </span>q = deque()<br><span class="hljs-meta">&gt;&gt;&gt; </span>q.append(<span class="hljs-string">&#x27;eat&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>q.append(<span class="hljs-string">&#x27;sleep&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>q.append(<span class="hljs-string">&#x27;code&#x27;</span>)<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>q<br>deque([<span class="hljs-string">&#x27;eat&#x27;</span>, <span class="hljs-string">&#x27;sleep&#x27;</span>, <span class="hljs-string">&#x27;code&#x27;</span>])<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>q.popleft()<br><span class="hljs-string">&#x27;eat&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>q.popleft()<br><span class="hljs-string">&#x27;sleep&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>q.popleft()<br><span class="hljs-string">&#x27;code&#x27;</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>q.popleft()<br>IndexError: pop <span class="hljs-keyword">from</span> an empty deque<br></code></pre></td></tr></table></figure><p>想了解更多有关deque的知识，可以翻阅官方文档：<a href="https://docs.python.org/3/library/collections.html?highlight=collections%20deque#collections.deque">collections.deque</a></p><h3 id="queue-Queue——为并行计算提供的锁语义">queue.Queue——为并行计算提供的锁语义</h3><p>参考LifoQueue。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> queue <span class="hljs-keyword">import</span> Queue<br><span class="hljs-meta">&gt;&gt;&gt; </span>q = Queue()<br><span class="hljs-meta">&gt;&gt;&gt; </span>q.put(<span class="hljs-string">&#x27;eat&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>q.put(<span class="hljs-string">&#x27;sleep&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>q.put(<span class="hljs-string">&#x27;code&#x27;</span>)<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>q<br>&lt;queue.Queue <span class="hljs-built_in">object</span> at <span class="hljs-number">0x0000026060A55FA0</span>&gt;<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>q.get()<br><span class="hljs-string">&#x27;eat&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>q.get()<br><span class="hljs-string">&#x27;sleep&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>q.get()<br><span class="hljs-string">&#x27;code&#x27;</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>q.get()<br><span class="hljs-comment"># 阻塞，永远停在这里...</span><br></code></pre></td></tr></table></figure><p>想了解更多有关Queue的知识，可以翻阅官方文档：<a href="https://docs.python.org/3/library/queue.html?highlight=queue%20queue#queue.Queue">queue.Queue</a></p><h2 id="优先队列">优先队列</h2><p>优先队列是一个容器数据结构，使用具有<a href="zh.wikipedia.org/zh-hans/%E5%85%A8%E5%BA%8F%E5%85%B3%E7%B3%BB">全序关系</a>的键（例如用数值表示的权重）来管理元素，以便快速访问容器中键值<strong>最小</strong>或<strong>最大</strong>的元素。<br>所以说python的列表挺全能了，甚至也能当优先队列，只不过每次添加新元素时，都要重新排序。<br>当然了，也有其他办法实现优先队列。</p><h3 id="heapq——基于列表的二叉堆">heapq——基于列表的二叉堆</h3><p>heapq是二叉堆，通常用普通列表实现，能在O(logn)时间内插入和获取最小的元素。</p><blockquote><p>由于heapq在技术上只提供最小堆实现，因此必须添加额外步骤来确保排序稳定性，以此来获得“实际”的优先级队列中所含有的预期特性。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> heapq<br><br>q = []<br>heapq.heappush(q, (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;code&#x27;</span>))<br>heapq.heappush(q, (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;eat&#x27;</span>))<br>heapq.heappush(q, (<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;sleep&#x27;</span>))<br><br><span class="hljs-keyword">while</span> q:<br>    next_item = heapq.heappop(q)<br>    <span class="hljs-built_in">print</span>(next_item)<br><br><span class="hljs-comment"># 输出如下</span><br><span class="hljs-comment"># (1, &#x27;eat&#x27;)</span><br><span class="hljs-comment"># (2, &#x27;code&#x27;)</span><br><span class="hljs-comment"># (3, &#x27;sleep&#x27;)</span><br></code></pre></td></tr></table></figure><p>想了解更多有关heapq的知识，可以翻阅官方文档：<a href="https://docs.python.org/3.9/library/heapq.html?highlight=heapq#module-heapq">heapq</a></p><h3 id="queue-PriorityQueue——美丽的优先级队列">queue.PriorityQueue——美丽的优先级队列</h3><p>其实这个类就是在内部使用了heapq来实现优先级队列，相当于让程序员看起来更容易明白。而且它是基于类的接口，而不像heapq是基于函数的接口。</p><blockquote><p>PriorityQueue是同步的，提供了锁语义来支持多个并发的生产者和消费者。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> queue <span class="hljs-keyword">import</span> PriorityQueue<br><br>q = PriorityQueue()<br>q.put((<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;code&#x27;</span>))<br>q.put((<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;eat&#x27;</span>))<br>q.put((<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;sleep&#x27;</span>))<br><br><span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> q.empty():<br>    next_item = q.get()<br>    <span class="hljs-built_in">print</span>(next_item)<br><br><span class="hljs-comment"># 输出如下</span><br><span class="hljs-comment"># (1, &#x27;eat&#x27;)</span><br><span class="hljs-comment"># (2, &#x27;code&#x27;)</span><br><span class="hljs-comment"># (3, &#x27;sleep&#x27;)</span><br></code></pre></td></tr></table></figure><p>想了解更多有关PriorityQueue的知识，可以翻阅官方文档：<a href="https://docs.python.org/3.9/library/queue.html?highlight=queue%20priorityqueue#queue.PriorityQueue">queue.PriorityQueue</a></p><h1>尾声</h1><p>在我不断地拖延症发作下漫长的更新终于结束啦蛤蛤蛤马上就有又会接着更新的现在就先这样啦</p><hr><p>参考书目： 《Python Tricks 深入理解python特性》 [德]达恩·巴德尔 人民邮电出版社</p>]]></content>
    
    
    <categories>
      
      <category>Learning Log</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PYQT6疑难杂症解决方案</title>
    <link href="/2022/06/15/pyqt-essay-1/"/>
    <url>/2022/06/15/pyqt-essay-1/</url>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>谁能想到课程设计要用pyqt+qt来写呢？我是没想到的。还好是老师会给课件，这下一周速通了。问题是老师给的pyqt5，而我作死用pyqt6导致自己碰一大堆壁。<br>所以这篇随笔就是把碰的壁整合一下，不知道以后有没有机会用到（虽然我并不是很喜欢用python来干这种事情（指写GUI和操作数据库））。</p><h1>正文</h1><h2 id="QPalette-setColor">QPalette.setColor</h2><p>在pyqt5里边，是这么写的：<code>palette1.setColor(palette1.Background, QtGui.QColor(255,  210,  210))</code><br>但是在pyqt6里边，多了两个东西，ColorRole 和 ColorGroup，这就导致你要这么写：<code>palette1.setColor(palette1.ColorRole.Window, QtGui.QColor('gray'))</code><br>上边的Background是被弃用了的，取而代之的是Window，而Window归于ColorRole，所以写法大大地不同（闷了）。</p><div class="note note-warning">            <p>设置某些控件的字体颜色的时候不要用调色盘！！！比如QLabel和QPlainTextEdit，用他们自带的<code>setStyleSheet()</code>，向里面传字符串<code>&quot;color: xx&quot;</code>，xx替换成相应颜色。</p>          </div><h2 id="关于鼠标相关的事件">关于鼠标相关的事件</h2><p>其实每个组件都已经写好了相关事件，只不过有些组件本来就没必要和鼠标进行交互当然不会触发相关事件。但是我们可以自己编写自己的类，通过继承和重载来对鼠标的信号作出反应。<br>和鼠标事件有关的方法有：<code>mousePressEvent(self, event)</code>、<code>wheelEvent(self, event)</code>、<code>mouseDoubieCiickEvent(self, event)</code>、<code>mouseReleaseEvent(self, event)</code>、<code>mouseMoveEvent(self, event)</code>、<code>enterEvent(self, event)</code>和<code>leaveEvent(self, event)</code>。<br>分别是：鼠标按下事件、滚轮滚动事件、鼠标双击事件、鼠标释放事件、鼠标移动事件、鼠标进入控件事件和鼠标离开控件事件。鼠标按下事件中可以通过event来获取具体按下的键再来配置更详细的操作。</p><div class="note note-warning">            <p>如果要实现实时监测鼠标移动，需要<code>setMouseTracking(True)</code>，否则只会在<code>mousePress</code>的时候触发鼠标移动事件。</p>          </div><h2 id="关于pyqt6把pyrcc删除了这件事">关于pyqt6把pyrcc删除了这件事</h2><p>老师给的课件用的是pyqt5，此时还存在pyrcc5这种东西，但是到了6能编译资源文件的pyrcc就惨遭阉割（误）。结果弄到我在这里卡了挺久，找了个什么pyqt6rc装一下不仅没用还把我pyqt6搞崩了，郁闷。<br>但是我们可以用pyside6-rcc进行编译（我是没想到的）。我们需要先安装pyside6：<code>pip install pyside6</code>，安装成功后，进入到资源文件所在文件夹中，使用命令：<code>pyside6-rcc res.qrc -o res.py</code>即可编译。<br>但是pyuic6编译后的py文件中不会自带<code>import res</code>，需要我们手动写进去。</p><h2 id="关于我的电脑时区为了登上xbox改成了香港特别行政区结果数字全显示成苏州码子这件事">关于我的电脑时区为了登上xbox改成了香港特别行政区结果数字全显示成苏州码子这件事</h2><p>如果你发现数字显示成苏州码子：〡〢〣〤〥〦〧〨〩<br>把电脑时区改回来！具体操作：控制面板 -&gt; 时钟和区域 -&gt; 区域，格式改成：中文(简体，中国)。</p><h2 id="关于pyCharm读取数据库或文件导致程序崩溃报错-1073740791-0xC0000409">关于pyCharm读取数据库或文件导致程序崩溃报错-1073740791 (0xC0000409)</h2><p>菜单栏Run -&gt; Edit Configuration，把Emulate terminal in output console勾选上。</p><h2 id="关于pyqt6里边枚举类型是：类名-枚举名-枚举值这件事">关于pyqt6里边枚举类型是：类名.枚举名.枚举值这件事</h2><p>简单的例子，pyqt5里边：<code>self.tabModel.setEditStrategy(QSqlTableModel.OnManualSubmit)</code>，pyqt6里边：<code>self.tabModel.setEditStrategy(QSqlTableModel.EditStrategy.OnManualSubmit)</code><br>就这么简单。虽然老师提醒过了但是我一开始根本就没想到这里面是枚举。查文档看到的确存在这种属性，然后又忽略了枚举。闷了很久，突然就灵光一闪这不是枚举值吗，不会是枚举的锅吧！然后就解决了。。。</p><h2 id="关于某些时候一些行为触发两次相同的槽函数这件事">关于某些时候一些行为触发两次相同的槽函数这件事</h2><p>本来是不想管的，但是open两次数据库就直接炸了啊我能不管吗？最简单的解决办法：给槽函数上@pyqtSlot()装饰器。</p><h2 id="关于QSqlTableMode、QSqlQueryModel、QSqlRelationalTableMode、QSqlQuery这四个东西用来干嘛">关于QSqlTableMode、QSqlQueryModel、QSqlRelationalTableMode、QSqlQuery这四个东西用来干嘛</h2><p>在课件里边，老师是这么用的：<code>QSqlTableMode</code>用来写了对数据库进行增删查改等操作的界面，<code>QSqlQueryModel</code>用来写对数据库进行查询的界面，从这里边我们就能很好地总结出：前者可以对数据库进行读写操作，而后者对数据库是只读的。<br>在网络上也找了一点说法：</p><blockquote><p>提供了一个sql查询结果的只读数据模型。它从查询QSqlQueryModel获取数据。可以方便的用于在QListView, QTableView, QTreeView等各种view上展示数据。但它是只读的，不能编辑。<br>继承于QSqlQueryModel，与QSqlQueryModel功能相似。比QSqlQueryModel的限制在于不能是任意sql语句，只是对单个数据表操作。拓展在于在各种view上展示表格数据的同时，还允许用户进行编辑操作。</p></blockquote><p>那<code>QSqlRelationalTableMode</code>是用来干什么的呢？在课件里边，它被用来做便捷的联合查询操作（也可以对数据表进行操作），且可以快速设置代理组件而不需要自己手写。<br>还有最后一个<code>QSqlQuery</code>，简单地说就是用来执行sql语句的。</p><h2 id="关于pyqt6里的QChart没有axisX-这个东西">关于pyqt6里的QChart没有axisX()这个东西</h2><p>这是课件里pyqt5的做法:<code>chart.removeAxis(chart.axisX())  # 删除坐标轴</code><br>但是pyqt6他没有啊，他又没有了啊！找了半天有个可以返回全部坐标轴列表的方法，于是我改成了下边的写法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> chart.axes():<br>    <span class="hljs-keyword">for</span> axis <span class="hljs-keyword">in</span> chart.axes():<br>        chart.removeAxis(axis)  <span class="hljs-comment"># 删除坐标轴</span><br></code></pre></td></tr></table></figure><p>你以为就结束了啊？你要把坐标轴加上去用的也不是<code>setAxisX()</code>而是<code>addAxis()</code>了。详细对比下面两句：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">chart.addAxis(axisStud, Qt.AlignmentFlag.AlignLeft)  <span class="hljs-comment"># pyqt6写法</span><br>chart.setAxisY(axisStud, seriesBar)  <span class="hljs-comment"># pyqt5写法</span><br></code></pre></td></tr></table></figure><h1>结语</h1><p>做完课设人已经麻了，谢谢。</p><hr>]]></content>
    
    
    <categories>
      
      <category>Essay</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>PyQt6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python随笔-4</title>
    <link href="/2022/06/13/python-essay-4/"/>
    <url>/2022/06/13/python-essay-4/</url>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>临近期末周了，所以人也闲下来一点了。什么？你问我期末不复习吗？啊，挂科嘛，不要紧的（迫真<br>刚好Matplotlib可能在某些地方要用上，某本书上也有讲例子，就跑来学学了。这篇随笔估计非常杂，关于Matplotlib的什么东西都可能扔上来www，不过有目录应该会清晰许多。</p><h1>正文</h1><h2 id="Matplotlib的安装">Matplotlib的安装</h2><p>CMD执行pip命令：<code>pip install --user matplotlib</code><br>终端执行pip命令：<code>$ python -m pip install --user matplotlib</code></p><div class="note note-warning">            <p>在macOS系统中，若操作不成功，请尝试删去–user再次执行。</p>          </div><p>在pyCharm中，用的解释器可能是虚拟环境中的解释器，可按如下步骤安装Matplotlib：<br>File -&gt; Settings -&gt; Project: Project Name -&gt; Project Interpreter<br><img src="https://s1.ax1x.com/2022/06/13/XRmj1A.png" alt="1-1"><br><img src="https://s1.ax1x.com/2022/06/13/XRmv6I.png" alt="1-2"><br>点击 + 号，然后在搜索框中输入Matplotlib，选中后安装即可。<br><img src="https://s1.ax1x.com/2022/06/13/XRmxXt.png" alt="1-3"></p><div class="note note-info">            <p>pyCharm懒狗型安装方法：直接在python文件中先用import导入matplotlib包，会报错，鼠标放到import代码上会显示浮动窗口，有直接安装操作。</p>          </div><div class="note note-info">            <p>如果pyCharm把matplotlib默认输出到Sciview了，而你又不想这么做，那么可以通过<strong>Settings -&gt; Tools -&gt; Python Scientific</strong>找到<strong>Show plots in toolwindow</strong>选项，取消勾选即可。</p>          </div><h2 id="Matplotlib的导入">Matplotlib的导入</h2><p><code>import matplotlib.pyplot as plt</code><br>使用别名plt是因为官方这么用所以跟风（bushi）就完事了</p><h2 id="Matplotlib输出中文">Matplotlib输出中文</h2><p>建议不要使用Matplotlib输出中文（比如图表标题）以避免出现无法正确显示文字的问题，但是也不是没有办法。<br>输入这行代码即可：<code>plt.rcParams['font.sans-serif'] = ['SimHei']</code><br>SimHei是微软雅黑字体。</p><div class="note note-warning">            <p>如果还需要执行其他代码如设置样式：<code>plt.style.use('seaborn')</code>，请在这一系列代码最后面加入字体设置代码，否则有可能出现仍然无法显示中文字体的问题。</p>          </div><h2 id="使用内置样式">使用内置样式</h2><p>可以在终端执行如下命令来查看有哪些样式可供使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-meta">&gt;&gt;&gt; </span>plt.style.available<br></code></pre></td></tr></table></figure><h2 id="某些注意事项">某些注意事项</h2><ol><li>向<code>plot()</code>提供一系列数时，它假设第一个数据点对应的<strong>x</strong>坐标值为0。</li><li>使用<code>plot()</code>时可指定各种实参，还可以使用众多函数对图形进行定制。</li><li>可以使用列表解析生成需要的值，再传递列表。</li></ol><hr>]]></content>
    
    
    <categories>
      
      <category>Essay</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux随笔-1</title>
    <link href="/2022/05/27/linux-essay-1/"/>
    <url>/2022/05/27/linux-essay-1/</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>文章内容来源：《Linux命令行与shell脚本编程大全（第3版）》 [美] Richard Blum  Christine Bresnahan 著 人民邮电出版社</p>          </div><h1>前言</h1><p>虽然说是前几天在操作系统上机课上就看完想写的东西但是由于各种事情拖到了今天。。。<br>算是刚接触Linux操作系统吧，所以就写了这么一个东西自用，作为快速参考。以后学到了什么相关内容可能也会在这里补充。</p><h1>正文</h1><h2 id="Vim快速参考">Vim快速参考</h2><h3 id="启动Vim编辑器">启动Vim编辑器</h3><p>命令：<code>vim 文件名</code><br>示例：<code>vim myprog.c</code></p><h3 id="插入（文本编辑）模式">插入（文本编辑）模式</h3><p>按 <strong>i</strong> 键进入。该模式下有如下命令：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>x</td><td>删除当前光标所在位置的字符</td></tr><tr><td>dd</td><td>删除当前光标所在行</td></tr><tr><td>dw</td><td>删除当前光标所在位置的单词</td></tr><tr><td>d$</td><td>删除当前光标所在位置至行尾的内容</td></tr><tr><td>J</td><td>删除当前光标所在行行尾的换行符</td></tr><tr><td>u</td><td>撤销前一编辑命令</td></tr><tr><td>a</td><td>在当前光标后追加数据</td></tr><tr><td>A</td><td>在当前光标所在行行尾追加数据</td></tr><tr><td>r <em>char</em></td><td>用<em>char</em>替换当前光标所在位置的单个字符</td></tr><tr><td>R <em>text</em></td><td>用<em>text</em>覆盖当前光标所在位置的数据，直到按下ESC键</td></tr></tbody></table><div class="note note-info">            <p>有些编辑命令允许使用数字修饰符来指定重复该命令多少次。比如，命令<code>2x</code>会删除从光标当前位置开始的两个字符，命令<code>5dd</code>会删除从光标当前所在行开始的5行。</p>          </div><h4 id="剪切、复制和粘贴">剪切、复制和粘贴</h4><p>vim在删除数据时，实际上会将数据保存在单独的一个寄存器中，可以用<code>p</code>命令取回数据。<br>所以，vim中的剪切和粘贴操作其实就是先删除数据，再移动光标至想要粘贴的位置，然后用<code>p</code>命令。<br>vim中的复制命令是<code>y</code>（代表yank），可以在<code>y</code>后面使用和<code>d</code>命令相同的第二字符（d、w、$）。<br>为了方便复制，我们可以按下<code>v</code>键进入<strong>可视模式</strong>，<strong>可视模式</strong>会在你移动光标时高亮显示文本。在覆盖了要复制的文本后，按下<code>y</code>键就好了。</p><h3 id="普通模式">普通模式</h3><p>在插入模式下按 <strong>esc</strong> 键进入。该模式下可移动光标，命令如下：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>h</td><td>左移一个字符</td></tr><tr><td>j</td><td>下移一行（文本中的下一行）</td></tr><tr><td>k</td><td>上移一行（文本中的上一行）</td></tr><tr><td>l</td><td>右移一个字符</td></tr><tr><td>PageDown（或Ctrl+F）</td><td>下翻一屏</td></tr><tr><td>PageUp（或Ctrl+B）</td><td>下翻一屏</td></tr><tr><td>G</td><td>移到缓冲区的最后一行</td></tr><tr><td>num G</td><td>移动到缓冲区中的第num行</td></tr><tr><td>gg</td><td>移到缓冲区的第一行</td></tr></tbody></table><h3 id="命令行模式">命令行模式</h3><p>普通模式下按 <strong>:</strong> 键进入。该模式下有如下命令：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>q</td><td>如果未修改缓存区数据，退出</td></tr><tr><td>q!</td><td>取消所有对缓冲区数据的修改并退出</td></tr><tr><td>w <em>filename</em></td><td>将文件保存到另一个文件中</td></tr><tr><td>wq</td><td>将缓冲区数据保存到文件中并退出</td></tr></tbody></table><h2 id="终端快速参考">终端快速参考</h2><h3 id="访问终端">访问终端</h3><p>图形化桌面下可尝试右键桌面，看弹出的菜单选项中有无该选项。<br>利用快捷键访问（进入）不同终端：<code>Ctrl + Alt + (F1~F7)</code></p><h3 id="设置终端背景颜色">设置终端背景颜色</h3><div class="note note-warning">            <p>*终端内输入指令</p>          </div><table><thead><tr><th>说明</th><th>命令</th></tr></thead><tbody><tr><td>开启该设置选项</td><td><code>settern -inversescreen on</code></td></tr><tr><td>设置背景色</td><td><code>settern -background white</code></td></tr><tr><td>设置前景色</td><td><code>settern -foreground black</code></td></tr></tbody></table><div class="note note-info">            <p>可供选择的颜色：black、red、green、yellow、blue、magenta、cyan、white</p>          </div><h3 id="Gnome-Terminal快捷键">Gnome Terminal快捷键</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>Shift+Ctrl+N</td><td>在新的窗口启动一个新的shell会话</td></tr><tr><td>Shift+Ctrl+T</td><td>在当前窗口启动一个新的shell会话</td></tr><tr><td>Shift+Ctrl+W</td><td>关闭当前标签中的会话</td></tr><tr><td>Shift+Ctrl+Q</td><td>关闭当前的Gnome Terminal会话</td></tr><tr><td>Shift+Ctrl+C/V</td><td>复制/粘贴</td></tr><tr><td>Shift+Ctrl+F</td><td>打开Find窗口</td></tr><tr><td>Shift+Ctrl+H/G</td><td>从终端会话的当前位置开始向后/向前搜索指定文本</td></tr><tr><td>Shift+Ctrl+PageUp/PageDown</td><td>使当前标签移动到前一个标签的前面/下一个标签的后面</td></tr><tr><td>Ctrl+PageDown/PageUp</td><td>使上一个/下一个标签成为活动标签</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Essay</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python随笔-3</title>
    <link href="/2022/05/22/python-essay-3/"/>
    <url>/2022/05/22/python-essay-3/</url>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>最近挺忙的（指打游戏）所以导致摸了很久（包括学习），现在痛定思痛，于是乎毅然决然写<s>（水）</s>一篇博文来规避内疚感<s>（不是）</s>。<br>其实还是有看（一点）的，这篇随笔要介绍的都是和类与面向对象有关的，那么不（想）多说了直接进入正文了。</p><h1>正文</h1><h2 id="is-和">is 和 ==</h2><p>在python中，<code>==</code>比较的是相等性，而<code>is</code>比较的是相同性，当我们用<code>==</code>时，比较的是值，当我们用<code>is</code>时，比较的是标识符。这么说可能非常难懂，所以直接在python中写点代码会好很多。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>b = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>a == b<br><span class="hljs-literal">True</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>a <span class="hljs-keyword">is</span> b<br><span class="hljs-literal">False</span><br><br>&gt;&gt;&gt;b = a<br>&gt;&gt;&gt;a <span class="hljs-keyword">is</span> b<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>这里我们可以看到，由于 a 和 b 的值是相等的，所以<code>a == b</code>为True，但是很明显 a 和 b 的标识符是不同的，所以结果输出了False。而在执行了<code>b = a</code>后，由于标识符相同了，所以现在<code>a is b</code>的结果是True了。</p><blockquote><p>来概括一下吧，用两条定义区分is和==的区别：<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="《Python Tricks 深入理解python特性》 [德]达恩·巴德尔 人民邮电出版社">[1]</span></a></sup></p><blockquote><p>当两个变量指向同一个对象时，is表达式的结果为True；<br>当各变量指向的对象含有相同内容时，==表达式的结果为True。</p></blockquote></blockquote><h2 id="字符串转换">字符串转换</h2><p>有的时候我们想把我们实例化类的对象的内容（信息）打印出来，我们希望最好是这么做：<code>print(a_object)</code>，但是理所当然的不会像你想的那样输出你想要的结果。<br>如果直接打印的话，我们的得到的是一个包含类名和实例对象的标识符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pet</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, specie</span>):<br>        self.name = name<br>        self.specie = specie<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>my_pet = Pet(<span class="hljs-string">&#x27;white&#x27;</span>, <span class="hljs-string">&#x27;cat&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(my_pet)<br>&lt;__main__.Pet <span class="hljs-built_in">object</span> at <span class="hljs-number">0x0000019E5BDFCF40</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>my_pet<br>&lt;__main__.Pet <span class="hljs-built_in">object</span> at <span class="hljs-number">0x0000019E5BDFCF40</span>&gt;<br></code></pre></td></tr></table></figure><p>为了解决这个问题，我们可以自己在类里构建一个方法来对打印的实例对象进行字符串转换，但是我们不需要这么做（不要构建自己的字符串转换机制），因为Python提供了两个双下划线方法<code>__str__</code>和<code>__repr__</code>在不同的情况下来将对象转换成字符串。<br>现在我们在上边的类中添加一个<code>__str__</code>方法，再用print输出，这时候就可以转换成我们想要的字符串了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pet</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, specie</span>):<br>        self.name = name<br>        self.specie = specie<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;The <span class="hljs-subst">&#123;self.specie&#125;</span>\&#x27;s name is <span class="hljs-subst">&#123;self.name&#125;</span>.&#x27;</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>my_pet = Pet(<span class="hljs-string">&#x27;white&#x27;</span>, <span class="hljs-string">&#x27;cat&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(my_pet)<br>The cat<span class="hljs-string">&#x27;s name is white.</span><br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>“在Python解释器会话中查看对象得到的是对象的__repr__结果。<br>像列表和字典这样的容器总是使用__repr__的结果来表示所包含的对象，哪怕对容器本身调用str()也是如此。”</p>          </div><p>我们也可以手动选择两种方法中的一种，用<code>str()</code>或是<code>repr()</code>即可，最好不要用<code>对象名.__str__</code>或是<code>对象名.__repr__</code>。<br>那他们的具体差别在哪里呢？这里我觉得书中的例子非常好，所以摘录书中内容来介绍。</p><blockquote><p>对于这样的问题，可以看看Python标准库是怎么做的。现在再设计一个实验，创建一个datetime.date对象，看这个对象如何使用__repr__和__str__来控制字符串转换：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> datetime<br><span class="hljs-meta">&gt;&gt;&gt; </span>today = datetime.date.today()<br></code></pre></td></tr></table></figure><p>在date对象上，__str__函数的结果侧重于<strong>可读性</strong>，旨在为人们返回一个简洁的文本表示，以便放心地向用户展示。因此在date对象上调用str()时，得到的是一些看起来像ISO日期格式的东西：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">str</span>(today)<br><span class="hljs-string">&#x27;2017-02-02&#x27;</span><br></code></pre></td></tr></table></figure><p>__repr__侧重的则是得到<strong>无歧义</strong>的结果，生成的字符串更多的是帮助开发人员调试程序。为此需要尽可能明确地说明这个对象是什么，因此在对象上调用repr()会得到相对更复杂的结果，其中甚至包括完整的模块和类名称：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">repr</span>()<br><span class="hljs-string">&#x27;datetime.date(2017, 2, 2)&#x27;</span><br></code></pre></td></tr></table></figure><p>我的经验法则是只要让__repr__生成的字符串对开发人员清晰且有帮助就可以了，并不需要能从中恢复对象的完整状态。</p></blockquote><div class="note note-warning">            <p>如果没有设置__str__方法的话，那么在需要调用该方法时会转为调用__repr__方法。</p>          </div><h2 id="abc——抽象基类">abc——抽象基类</h2><p>使用抽象基类可以避免我们在之后编写代码的时候不小心实例化了基类，并且可以确保派生类实现了我们想在其中实现的基类方法。<br>先来看看普通的基类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pet</span>:<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">infor</span>(<span class="hljs-params">self</span>):<br><span class="hljs-keyword">raise</span> NotImplementedError()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">behavior</span>(<span class="hljs-params">self</span>):<br><span class="hljs-keyword">raise</span> NotImplementedError()<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-title class_ inherited__">Pet</span>):<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">infor</span>(<span class="hljs-params">self, name, specie</span>):<br><span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;A <span class="hljs-subst">&#123;specie&#125;</span> called <span class="hljs-subst">&#123;name&#125;</span>.&quot;</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>b = Pet()<br><span class="hljs-meta">&gt;&gt;&gt; </span>b.infor()<br>NotImplementedError<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>my_cat = Cat()<br><span class="hljs-meta">&gt;&gt;&gt; </span>my_cat.infor(<span class="hljs-string">&#x27;white&#x27;</span>, <span class="hljs-string">&#x27;cat&#x27;</span>)<br>A cat called white.<br><span class="hljs-meta">&gt;&gt;&gt; </span>my_cat.behavior()<br>NotImplementedError<br></code></pre></td></tr></table></figure><p>在上面的代码里，不仅基类被实例化了，而且只有在调用未实现的方法时才能发现编写了一个实现不完整的子类。<br>为了避免出现这种状况，就可以用到我们的abc模块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> abc <span class="hljs-keyword">import</span> ABCMeta, abstractmethod<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pet</span>(metaclass=ABCMeta):<br><span class="hljs-meta">@abstractmethod</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">infor</span>(<span class="hljs-params">self</span>):<br><span class="hljs-keyword">pass</span><br><br><span class="hljs-meta">@abstractmethod</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">behavior</span>(<span class="hljs-params">self</span>):<br><span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-title class_ inherited__">Pet</span>):<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">infor</span>(<span class="hljs-params">self, name, specie</span>):<br><span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;A <span class="hljs-subst">&#123;specie&#125;</span> called <span class="hljs-subst">&#123;name&#125;</span>.&quot;</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>b = Pet()<br>TypeError: Can<span class="hljs-string">&#x27;t instantiate abstract class Pet with abstract methods behavior, infor</span><br><span class="hljs-string"></span><br><span class="hljs-string">&gt;&gt;&gt; my_cat = Cat()</span><br><span class="hljs-string">TypeError: Can&#x27;</span>t instantiate abstract <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">with</span> abstract method behavior<br></code></pre></td></tr></table></figure><p>如果我们尝试实例化基类，或者实例化一个不完整的子类，那么就会引发TypeError，并且会指出子类中缺少了哪些方法（未实现哪些抽象方法）。</p><div class="note note-warning">            <p>在用多个装饰器修饰同一个方法时，<code>abstractmethod()</code>应当被应用为最内层的装饰器。</p>          </div><div class="note note-warning">            <p>不同于Java 抽象方法，这些抽象方法可能具有一个实现。这个实现可在重载它的类上通过<code>super()</code>机制来调用。这在使用协作多重继承的框架中可以被用作超调用的一个端点。</p>          </div><p>如果想进一步了解abc模块，可以阅读官方文档：<a href="https://docs.python.org/zh-cn/3.9/library/abc.html?highlight=abc#module-abc">点这里跳转</a></p><hr><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>《Python Tricks 深入理解python特性》 [德]达恩·巴德尔 人民邮电出版社<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Essay</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python随笔-2</title>
    <link href="/2022/05/13/python-essay-2/"/>
    <url>/2022/05/13/python-essay-2/</url>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>在学习装饰器的时候，其中有提到过*args和**kwargs可以让装饰器变得更加强大、有用。<br>文章也简单地说明了下他们的作用，不过想了想这部分<s>貌似也能水一篇文章</s>还是挺重要的，遂写了一篇随笔记一下。<br>当然相关的函数参数解包的内容也一起写在随笔里了。</p><h1>正文</h1><h2 id="它们有什么用">它们有什么用</h2><p>它们能让函数接受<strong>可选参数</strong>。当然，这里的可选参数可能并不像你想的那样，我是说，不是这样的可选参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a=<span class="hljs-number">0</span>, b=<span class="hljs-number">0</span></span>)<br><span class="hljs-keyword">return</span> a + b<br></code></pre></td></tr></table></figure><p>而是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">*args, **kwargs</span>):<br><span class="hljs-built_in">print</span>(args)<br><span class="hljs-built_in">print</span>(kwargs)<br></code></pre></td></tr></table></figure><p>上述函数可以传递任意多的参数，也能不传递参数。在这里arg会收集位置参数组成元组，kwargs会收集额外的关键字参数组成字典。如果不传递参数，那么args和kwargs都为空。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>test(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,k=<span class="hljs-number">1</span>,j=<span class="hljs-number">2</span>,l=<span class="hljs-number">3</span>)<br>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br>&#123;<span class="hljs-string">&#x27;k&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;j&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;l&#x27;</span>: <span class="hljs-number">3</span>&#125;<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>test()<br>()<br>&#123;&#125;<br></code></pre></td></tr></table></figure><div class="note note-info">            <p>实际起作用的是语法分别是星号（*）和双星号（**），args和kwargs只是命名约定。</p>          </div><h2 id="函数参数解包">函数参数解包</h2><p>解包操作符*和**可以用来从序列和字典中“解包”函数参数。<br>比如我们现在有这么一个函数，接受三个参数并返回他们的和。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b, c</span>):<br><span class="hljs-keyword">return</span> a + b + c<br></code></pre></td></tr></table></figure><p>如果我们需要传递的参数在一个列表中，我们得这么做才能传递过去：<code>add(a_list[0], a_list[1], a_list[2])</code><br>但是这看上去非常笨不是吗？所幸我们有解包操作符*，现在，它可以这么写了：<code>add(*a_list)</code>在函数调用时，在可迭代对象前面放一个*能<strong>解包</strong>这个参数，将其中的元素作为单独的位置参数传递给被调用的函数。<br>另一个解包操作符**则是用于从字典中解包关键字参数，比如有这么一个字典：<code>a_dict = &#123;'a' = 1, 'b' = 2, 'c' = 3&#125;</code>，那么要将它传入<code>add()</code>中，就可以这么写：<code>add(**a_dict)</code>，则其中的值会按插入顺序传递给对应位置的参数。<br>需要说明的是，解包的时候会匹配字典键和函数参数，在上边，add中的a参数会接受字典中与’a’键相关的值。<br>而如果使用*对字典进行解包的话，则是将所有的<strong>键</strong>按插入顺序传递给函数。</p><h2 id="传递可选参数">传递可选参数</h2><p>了解了函数参数解包后，我们就可以用它来从一个函数中将可选参数传递给另外一个函数了，并且，参数在传递之前还可以进行修改。<br>比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test1</span>(<span class="hljs-params">*args, **kwargs</span>):<br>new_args = args + (<span class="hljs-number">5</span>, )<br>kwargs[<span class="hljs-string">&#x27;k&#x27;</span>] = <span class="hljs-number">5</span><br>test(*new_args, **kwargs)<br></code></pre></td></tr></table></figure><blockquote><p>这种技术适用于创建子类和编写包装函数（如装饰器）。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="《Python Tricks 深入理解python特性》 [德]达恩·巴德尔 人民邮电出版社">[1]</span></a></sup><br>例如在扩展父类的行为时，子类中的构造函数不用再带有完整的参数列表，因而适用于处理那些不受我们控制的API。<br>一般情况下，自己定义的类层次中并不会用到这种技术。这通常用于修改或覆盖某些外部类中的行为，而自己又无法控制这些外部类。</p></blockquote><hr><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>《Python Tricks 深入理解python特性》 [德]达恩·巴德尔 人民邮电出版社<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Essay</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统原理——虚拟存储管理实验</title>
    <link href="/2022/04/29/page-store/"/>
    <url>/2022/04/29/page-store/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>本文章用到的语言：Python</p>          </div><h1>前言</h1><p>前排提个醒，这个程序我觉得自己写得挺复杂的（因为我懒癌犯了，没有想着优化，也没有想着跟题目走），so大家看看就好。</p><h1>原理</h1><p>老样子照搬：</p><blockquote><p>突然发现这次没得搬的我be like： :(</p></blockquote><h1>实现</h1><h2 id="一些一些一些全局变量">一些一些一些全局变量</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">input_queue = [<span class="hljs-number">7</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, ]  <span class="hljs-comment"># 输入队列</span><br>a_queue = []  <span class="hljs-comment"># 保存用于打印的结果</span><br>b_queue = []  <span class="hljs-comment"># 同上</span><br>c_queue = []  <span class="hljs-comment"># 同上</span><br>interrupt_queue = []  <span class="hljs-comment"># 中断队列，保存发生中断时候的位置</span><br>page_queue = []  <span class="hljs-comment"># 保存页表类对象的队列</span><br>ram_queue = []  <span class="hljs-comment"># 虚拟内存队列</span><br></code></pre></td></tr></table></figure><p>（小声：其实我会很大程度写出这样的程序是题目要求的输出的问题，真的</p><h2 id="一直到最后都没什么用的页表类">一直到最后都没什么用的页表类</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PageList</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;页表类&quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, status, quote</span>):<br>        self.status = status  <span class="hljs-comment"># 状态</span><br>        self.quote = quote  <span class="hljs-comment"># 引用位</span><br></code></pre></td></tr></table></figure><p>真的没用。真的没用。真的没用。直接往下看吧。我用数组下标完成工作的。</p><h2 id="获取输入、打印结果、重置各队列">获取输入、打印结果、重置各队列</h2><p>获取输入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">input_data</span>():<br>    <span class="hljs-string">&quot;&quot;&quot;获取用户输入来选择算法&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        algorithm = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请选择一个算法：A、最佳置换；B、先进先出置换；C、最近最少用置换；D、退出&quot;</span>)<br>        <span class="hljs-keyword">if</span> algorithm == <span class="hljs-string">&#x27;A&#x27;</span>:<br>            opt()<br>        <span class="hljs-keyword">elif</span> algorithm == <span class="hljs-string">&#x27;B&#x27;</span>:<br>            fifo()<br>        <span class="hljs-keyword">elif</span> algorithm == <span class="hljs-string">&#x27;C&#x27;</span>:<br>            lru()<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;程序退出！&quot;</span>)<br>            <span class="hljs-keyword">break</span><br>        reset_page()<br></code></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_result</span>():<br>    <span class="hljs-string">&quot;&quot;&quot;打印各个队列&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">global</span> input_queue, a_queue, b_queue, c_queue, interrupt_queue<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> input_queue:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;i&#125;</span>&quot;</span>.center(<span class="hljs-number">3</span>), end=<span class="hljs-string">&#x27;&#x27;</span>)<br>    <span class="hljs-built_in">print</span>()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&quot;</span>.center(<span class="hljs-number">60</span>, <span class="hljs-string">&#x27;-&#x27;</span>))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> a_queue:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;i&#125;</span>&quot;</span>.center(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;|&#x27;</span>), end=<span class="hljs-string">&#x27;&#x27;</span>)<br>    <span class="hljs-built_in">print</span>()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&quot;</span>.center(<span class="hljs-number">60</span>, <span class="hljs-string">&#x27;-&#x27;</span>))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> b_queue:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;i&#125;</span>&quot;</span>.center(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;|&#x27;</span>), end=<span class="hljs-string">&#x27;&#x27;</span>)<br>    <span class="hljs-built_in">print</span>()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&quot;</span>.center(<span class="hljs-number">60</span>, <span class="hljs-string">&#x27;-&#x27;</span>))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> c_queue:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;i&#125;</span>&quot;</span>.center(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;|&#x27;</span>), end=<span class="hljs-string">&#x27;&#x27;</span>)<br>    <span class="hljs-built_in">print</span>()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&quot;</span>.center(<span class="hljs-number">60</span>, <span class="hljs-string">&#x27;-&#x27;</span>))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> interrupt_queue:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;i&#125;</span>&quot;</span>.center(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;|&#x27;</span>), end=<span class="hljs-string">&#x27;&#x27;</span>)<br>    <span class="hljs-built_in">print</span>()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;该算法一共发生了<span class="hljs-subst">&#123;interrupt_queue.count(<span class="hljs-string">&#x27;+&#x27;</span>)&#125;</span>页面置换，缺页中断率为<span class="hljs-subst">&#123;interrupt_queue.count(<span class="hljs-string">&#x27;+&#x27;</span>)*<span class="hljs-number">100</span>/<span class="hljs-built_in">len</span>(input_queue)&#125;</span>%&quot;</span>)<br>    <span class="hljs-built_in">print</span>()<br>    <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p>重置各队列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">reset_page</span>():<br>    <span class="hljs-string">&quot;&quot;&quot;重置页表状态&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">global</span> a_queue, b_queue, c_queue, interrupt_queue, ram_queue<br>    <span class="hljs-keyword">for</span> page <span class="hljs-keyword">in</span> page_queue:<br>        page.status = <span class="hljs-number">0</span><br>        page.quote = <span class="hljs-number">0</span><br>    a_queue = []<br>    b_queue = []<br>    c_queue = []<br>    interrupt_queue = []<br>    ram_queue = []<br></code></pre></td></tr></table></figure><h2 id="最优置换算法">最优置换算法</h2><p>最优是我想了最久的，毕竟其他两个确实不难，这里仔细划分每种情况就清晰多了。<br>首先是虚拟内存当前是否满的情况，这里要注意在虚拟内存未满的时候产生缺页中断是插入队尾而不是队头（就这个OPT是这样），其实虚拟内存未满的情况下还需要考虑是否产生缺页中断，我这里写的是没有考虑的。<br>然后是虚拟内存满了后，产生缺页中断和不产生缺页中断的情况。不产生缺页中断就不需要对虚拟内存进行操作了。<br>产生缺页中断后，我首先找剩下不需要再调用的页面，这部分页面的优先级是最大的，当然这是在有python列表方法的情况下这么写简单，直接找最迟访问也行。如果都还要访问那就找最迟访问的页面。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">opt</span>():<br>    <span class="hljs-string">&quot;&quot;&quot;to do&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">global</span> input_queue, a_queue, b_queue, c_queue, interrupt_queue, page_queue, ram_queue<br>    <span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(input_queue)):  <span class="hljs-comment"># 遍历整个序列</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(ram_queue) == <span class="hljs-number">3</span>:<br>            <span class="hljs-keyword">if</span> input_queue[index] <span class="hljs-keyword">in</span> ram_queue:  <span class="hljs-comment"># 当前虚拟内存中有该页，不产生缺页中断，也不需要改变虚拟内存中的页表</span><br>                a_queue.append(ram_queue[<span class="hljs-number">0</span>])  <span class="hljs-comment"># 保存用于打印的结果</span><br>                b_queue.append(ram_queue[<span class="hljs-number">1</span>])<br>                c_queue.append(ram_queue[<span class="hljs-number">2</span>])<br>                interrupt_queue.append(<span class="hljs-string">&#x27; &#x27;</span>)  <span class="hljs-comment"># 未产生缺页中断，所以塞个&#x27; &#x27;进去</span><br>                <span class="hljs-keyword">continue</span>  <span class="hljs-comment"># 继续下次循环</span><br>            <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 虚拟内存满的情况下，调用对应页面置换算法置换页面</span><br>                find = <span class="hljs-number">0</span><br>                <span class="hljs-keyword">for</span> exchange_index <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(ram_queue)):  <span class="hljs-comment"># 找出需要置换的页面在虚拟内存队列中的下标</span><br>                    <span class="hljs-keyword">if</span> ram_queue[exchange_index] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> input_queue[index + <span class="hljs-number">1</span>:]:  <span class="hljs-comment"># 如果在剩下的序列中都找不到该页，可以直接换出去</span><br>                        find = <span class="hljs-number">1</span>  <span class="hljs-comment"># 标记是否找到了置换页面</span><br>                        exchange_page = ram_queue[exchange_index]<br>                        <span class="hljs-keyword">break</span><br>                <span class="hljs-keyword">if</span> find == <span class="hljs-number">0</span>:  <span class="hljs-comment"># 三个页在剩下的序列中还有访问</span><br>                    tmp_queue = input_queue[index + <span class="hljs-number">1</span>:]<br>                    max_index = <span class="hljs-number">0</span><br>                    exchange_page = <span class="hljs-number">0</span><br>                    <span class="hljs-keyword">for</span> tmp_index <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(ram_queue)):  <span class="hljs-comment"># 找出最迟访问的页</span><br>                        new_index = tmp_queue.index(ram_queue[tmp_index])<br>                        <span class="hljs-keyword">if</span> max_index &lt; new_index:<br>                            max_index = new_index<br>                            exchange_page = ram_queue[tmp_index]<br>                <span class="hljs-keyword">for</span> tmp_index <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(ram_queue)):<br>                    <span class="hljs-keyword">if</span> exchange_page == ram_queue[tmp_index]:  <span class="hljs-comment"># 进行页面置换</span><br>                        ram_queue[tmp_index] = input_queue[index]<br>                        <span class="hljs-keyword">break</span><br>                a_queue.append(ram_queue[<span class="hljs-number">0</span>])  <span class="hljs-comment"># 保存用于打印的结果</span><br>                b_queue.append(ram_queue[<span class="hljs-number">1</span>])<br>                c_queue.append(ram_queue[<span class="hljs-number">2</span>])<br>                interrupt_queue.append(<span class="hljs-string">&#x27;+&#x27;</span>)  <span class="hljs-comment"># 产生缺页中断，所以塞个&#x27;+&#x27;进去</span><br>                <span class="hljs-keyword">continue</span>  <span class="hljs-comment"># 继续下次循环</span><br>        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">len</span>(ram_queue) &lt;= <span class="hljs-number">2</span>:  <span class="hljs-comment"># 虚拟内存队列长度为0、1、2的情况</span><br>            ram_queue.append(input_queue[index])<br>            a_queue.append(ram_queue[<span class="hljs-number">0</span>])  <span class="hljs-comment"># 保存用于打印的结果</span><br>            b_queue.append(ram_queue[<span class="hljs-number">1</span>] <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(ram_queue) &gt;= <span class="hljs-number">2</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27; &#x27;</span>)<br>            c_queue.append(ram_queue[<span class="hljs-number">2</span>] <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(ram_queue) == <span class="hljs-number">3</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27; &#x27;</span>)<br>            interrupt_queue.append(<span class="hljs-string">&#x27;+&#x27;</span>)  <span class="hljs-comment"># 产生缺页中断，所以塞个&#x27;+&#x27;进去</span><br>            <span class="hljs-keyword">continue</span>  <span class="hljs-comment"># 继续下次循环</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;OPT页面置换算法示意图如下：&quot;</span>)<br>    print_result()<br>    <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><h2 id="先进先出置换算法">先进先出置换算法</h2><p>其实就是很简单的队列操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fifo</span>():<br>    <span class="hljs-keyword">global</span> input_queue, a_queue, b_queue, c_queue, interrupt_queue, page_queue, ram_queue<br>    <span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(input_queue)):  <span class="hljs-comment"># 遍历整个序列</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(ram_queue) == <span class="hljs-number">3</span>:<br>            <span class="hljs-keyword">if</span> input_queue[index] <span class="hljs-keyword">in</span> ram_queue:  <span class="hljs-comment"># 当前虚拟内存中有该页，不产生缺页中断，也不需要改变虚拟内存中的页表</span><br>                a_queue.append(ram_queue[<span class="hljs-number">0</span>])  <span class="hljs-comment"># 保存用于打印的结果</span><br>                b_queue.append(ram_queue[<span class="hljs-number">1</span>])<br>                c_queue.append(ram_queue[<span class="hljs-number">2</span>])<br>                interrupt_queue.append(<span class="hljs-string">&#x27; &#x27;</span>)  <span class="hljs-comment"># 未产生缺页中断，所以塞个&#x27; &#x27;进去</span><br>                <span class="hljs-keyword">continue</span>  <span class="hljs-comment"># 继续下次循环</span><br>            <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 虚拟内存满的情况下，调用对应页面置换算法置换页面</span><br>                ram_queue.insert(<span class="hljs-number">0</span>, input_queue[index])  <span class="hljs-comment"># 队列头进</span><br>                ram_queue.pop()  <span class="hljs-comment"># 队列尾出</span><br>                a_queue.append(ram_queue[<span class="hljs-number">0</span>])  <span class="hljs-comment"># 保存用于打印的结果</span><br>                b_queue.append(ram_queue[<span class="hljs-number">1</span>])<br>                c_queue.append(ram_queue[<span class="hljs-number">2</span>])<br>                interrupt_queue.append(<span class="hljs-string">&#x27;+&#x27;</span>)  <span class="hljs-comment"># 产生缺页中断，所以塞个&#x27;+&#x27;进去</span><br>                <span class="hljs-keyword">continue</span>  <span class="hljs-comment"># 继续下次循环</span><br>        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">len</span>(ram_queue) &lt;= <span class="hljs-number">2</span>:  <span class="hljs-comment"># 虚拟内存队列长度为0、1、2的情况</span><br>            ram_queue.insert(<span class="hljs-number">0</span>, input_queue[index])<br>            a_queue.append(ram_queue[<span class="hljs-number">0</span>])  <span class="hljs-comment"># 保存用于打印的结果</span><br>            b_queue.append(ram_queue[<span class="hljs-number">1</span>] <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(ram_queue) &gt;= <span class="hljs-number">2</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27; &#x27;</span>)<br>            c_queue.append(ram_queue[<span class="hljs-number">2</span>] <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(ram_queue) == <span class="hljs-number">3</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27; &#x27;</span>)<br>            interrupt_queue.append(<span class="hljs-string">&#x27;+&#x27;</span>)  <span class="hljs-comment"># 产生缺页中断，所以塞个&#x27;+&#x27;进去</span><br>            <span class="hljs-keyword">continue</span>  <span class="hljs-comment"># 继续下次循环</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;FIFO页面置换算法示意图如下：&quot;</span>)<br>    print_result()<br>    <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><h2 id="最近最少用置换算法">最近最少用置换算法</h2><p>其实和队列也没多大差，要是当前队列有对应页，就把该页和队头那一页调换位置就好了，产生缺页中断时候的操作和FIFO是一样的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">lru</span>():<br>    <span class="hljs-string">&quot;&quot;&quot;to do&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">global</span> input_queue, a_queue, b_queue, c_queue, interrupt_queue, page_queue, ram_queue<br>    <span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(input_queue)):  <span class="hljs-comment"># 遍历整个序列</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(ram_queue) == <span class="hljs-number">3</span>:<br>            <span class="hljs-keyword">if</span> input_queue[index] <span class="hljs-keyword">in</span> ram_queue:  <span class="hljs-comment"># 当前虚拟内存中有该页，不产生缺页中断，也不需要改变虚拟内存中的页表</span><br>                ram_queue.remove(input_queue[index])<br>                ram_queue.insert(<span class="hljs-number">0</span>, input_queue[index])<br>                a_queue.append(ram_queue[<span class="hljs-number">0</span>])  <span class="hljs-comment"># 保存用于打印的结果</span><br>                b_queue.append(ram_queue[<span class="hljs-number">1</span>])<br>                c_queue.append(ram_queue[<span class="hljs-number">2</span>])<br>                interrupt_queue.append(<span class="hljs-string">&#x27; &#x27;</span>)  <span class="hljs-comment"># 未产生缺页中断，所以塞个&#x27; &#x27;进去</span><br>                <span class="hljs-keyword">continue</span>  <span class="hljs-comment"># 继续下次循环</span><br>            <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 虚拟内存满的情况下，调用对应页面置换算法置换页面</span><br>                ram_queue.pop()<br>                ram_queue.insert(<span class="hljs-number">0</span>, input_queue[index])<br>                a_queue.append(ram_queue[<span class="hljs-number">0</span>])  <span class="hljs-comment"># 保存用于打印的结果</span><br>                b_queue.append(ram_queue[<span class="hljs-number">1</span>])<br>                c_queue.append(ram_queue[<span class="hljs-number">2</span>])<br>                interrupt_queue.append(<span class="hljs-string">&#x27;+&#x27;</span>)  <span class="hljs-comment"># 产生缺页中断，所以塞个&#x27;+&#x27;进去</span><br>                <span class="hljs-keyword">continue</span>  <span class="hljs-comment"># 继续下次循环</span><br>        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">len</span>(ram_queue) &lt;= <span class="hljs-number">2</span>:  <span class="hljs-comment"># 虚拟内存队列长度为0、1、2的情况</span><br>            ram_queue.append(input_queue[index])<br>            a_queue.append(ram_queue[<span class="hljs-number">0</span>])  <span class="hljs-comment"># 保存用于打印的结果</span><br>            b_queue.append(ram_queue[<span class="hljs-number">1</span>] <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(ram_queue) &gt;= <span class="hljs-number">2</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27; &#x27;</span>)<br>            c_queue.append(ram_queue[<span class="hljs-number">2</span>] <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(ram_queue) == <span class="hljs-number">3</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27; &#x27;</span>)<br>            interrupt_queue.append(<span class="hljs-string">&#x27;+&#x27;</span>)  <span class="hljs-comment"># 产生缺页中断，所以塞个&#x27;+&#x27;进去</span><br>            <span class="hljs-keyword">continue</span>  <span class="hljs-comment"># 继续下次循环</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;LRU页面置换算法示意图如下：&quot;</span>)<br>    print_result()<br>    <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><h2 id="测试代码">测试代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 初始化页表，一共有八页</span><br>    page_queue.append(PageList(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>))<br>    page_queue.append(PageList(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>))<br>    page_queue.append(PageList(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>))<br>    page_queue.append(PageList(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>))<br>    page_queue.append(PageList(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>))<br>    page_queue.append(PageList(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>))<br>    page_queue.append(PageList(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>))<br>    page_queue.append(PageList(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>))<br><br>    input_data()<br></code></pre></td></tr></table></figure><h1>运行结果</h1><p><s>没想到吧，我这次放运行结果了！</s></p><p><img src="/img/page_store/result_opt.png" alt="最优置换"></p><p><img src="/img/page_store/result_fifo.png" alt="先进先出置换"></p><p><img src="/img/page_store/result_lru.png" alt="最近最少用置换"></p><h1>一些一些一些其他垃圾话</h1><p>其实本来是想优化的，但是由于我太懒了（五一假那能叫懒吗）所以计划取消了！</p><hr>]]></content>
    
    
    <categories>
      
      <category>Learning Log</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>操作系统</tag>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python学习笔记——测试代码</title>
    <link href="/2022/04/24/python-learning-3/"/>
    <url>/2022/04/24/python-learning-3/</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>本文章尚未更新完毕</p>          </div><h1>前言</h1><p>要验证我们所编写的代码是否能像我们所想的那样工作，我们就需要对我们的代码进行测试。<br>但是一般情况下，验证都涉及到数据的输入，这可就麻烦了，为了测试我们的代码，每运行一次都得输入一次数据，这样做即低效又烦琐。<br>而且以后每修改一次函数/类，我们也要做一次这样的工作，想想就头晕，不是吗？<br>好在Python提供了一种自动测试函数输出的高效方式：通过unittest模板来测试代码。</p><h1>什么事Unittest？</h1><p>简单地说，其实就是一个提供一系列代码测试工具的一个模块。在<a href="https://docs.python.org/3.9/library/unittest.html?highlight=unittest#module-unittest">官方文档</a>中描述如下：</p><blockquote><p>The unittest unit testing framework was originally inspired by JUnit and has a similar flavor as major unit testing frameworks in other languages.<br>It supports test automation, sharing of setup and shutdown code for tests, aggregation of tests into collections, and independence of the tests from the reporting framework.</p><p>To achieve this, unittest supports some important concepts in an object-oriented way:</p><p>test fixture</p><blockquote><p>A test fixture represents the preparation needed to perform one or more tests, and any associated cleanup actions.<br>This may involve, for example, creating temporary or proxy databases, directories, or starting a server process.</p></blockquote><p>test case</p><blockquote><p>A test case is the individual unit of testing. It checks for a specific response to a particular set of inputs.<br>unittest provides a base class, TestCase, which may be used to create new test cases.</p></blockquote><p>test suite</p><blockquote><p>A test suite is a collection of test cases, test suites, or both. It is used to aggregate tests that should be executed together.</p></blockquote><p>test runner</p><blockquote><p>A test runner is a component which orchestrates the execution of tests and provides the outcome to the user.<br>The runner may use a graphical interface, a textual interface, or return a special value to indicate the results of executing the tests.</p></blockquote></blockquote><p>官方文档讲了四种概念，但在这边目前仅涉及test case，即测试用例，这一概念的使用。<br>正如官方文档所说，test case检查输入特定的数据时的响应。正因如此我们可以用它来简化我们的需要输入数据的测试。</p><h1>Unittest中的断言方法</h1><p>因为我们需要检查输出的结果，所以就要用到<code>unittest</code>中的断言方法，在这里我列举了一些方法。</p><h1>对函数进行测试</h1><p>要对函数进行测试，首先我们得有用于测试的函数，我们既可以自行定义要测试的函数，也可以利用Python自带的函数，这里我先自行定义一个函数，它用于将两数相加并返回该值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>):<br><span class="hljs-keyword">return</span> a + b<br></code></pre></td></tr></table></figure><h2 id="通过的测试">通过的测试</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> unittest<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddTestCase</span>(unittest.TestCase):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_two_num_add</span>(<span class="hljs-params">self</span>):<br>        result = add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>        self.assertEqual(result, <span class="hljs-number">3</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    unittest.main()<br></code></pre></td></tr></table></figure><p>首先导入<code>unittest</code>模块。<br>然后创建了一个名为 <code>AddTestCase</code> 的类，名字是可以随便取的，但是最好简单易懂（其实写注释就好啦）。要进行测试，这个类必须继承 <code>unittest.TsetCase</code> 类。<br>类里面目前只写了一个方法，用于测试两个数相加的情况。在运行时，所有以test_打头的方法都将自动运行。<br>在这个方法中，调用了之前编写的<code>add</code>函数并将值返回到<code>result</code>变量中，然后用<code>unittest</code>中的断言方法来判断得到的结果是否与我们预期结果一致。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">.<br>----------------------------------------------------------------------<br>Ran <span class="hljs-number">1</span> test <span class="hljs-keyword">in</span> <span class="hljs-number">0.000</span>s<br><br>OK<br></code></pre></td></tr></table></figure><p>直接运行这个文件，我们会得到如上输出。句点的数量代表了通过的测试数，在上面我们有一个句点，说明通过了一个测试。接下来的一行指出“在xxx秒内运行了xxx个测试”。最后的OK表示该测试用例中的所有单元测试都通过了。</p><h2 id="未通过的测试">未通过的测试</h2><p>如果测试未通过，控制台/终端会输出什么信息呢？试一下就知道了。这里我故意编写了一个无法通过的测试，将<strong>3</strong>改为了<strong>4</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddTestCase</span>(unittest.TestCase):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_two_num_add</span>(<span class="hljs-params">self</span>):<br>        result = add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>        self.assertEqual(result, <span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><p>报错信息如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">F<br>======================================================================<br>FAIL: test_two_num_add (__main__.AddTestCase)<br>----------------------------------------------------------------------<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;G:\example1.py&quot;</span>, line <span class="hljs-number">11</span>, <span class="hljs-keyword">in</span> test_two_num_add<br>    self.assertEqual(result, <span class="hljs-number">4</span>)<br>AssertionError: <span class="hljs-number">3</span> != <span class="hljs-number">4</span><br><br>----------------------------------------------------------------------<br>Ran <span class="hljs-number">1</span> test <span class="hljs-keyword">in</span> <span class="hljs-number">0.001</span>s<br><br>FAILED (failures=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>这里第一行显示测试用例中有一个单元测试失败，接下来告诉你具体是哪个单元测试，紧接着就是Traceback——详细的报错信息了。在最后，我们还能看到运行该测试用例时失败了多少个单元测试。<br>在这里报的错是<strong>F</strong>，还有一种报错是<strong>E</strong>，这里一并演示一下：首先改下我们的函数<code>add</code>的代码，让它从现在开始接受三个参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b, c</span>):<br>    <span class="hljs-keyword">return</span> a + b + c<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddTestCase</span>(unittest.TestCase):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_two_num_add</span>(<span class="hljs-params">self</span>):<br>        result = add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>        self.assertEqual(result, <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>然后运行，得到如下信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">E<br>======================================================================<br>ERROR: test_two_num_add (__main__.AddTestCase)<br>----------------------------------------------------------------------<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;G:\example1.py&quot;</span>, line <span class="hljs-number">10</span>, <span class="hljs-keyword">in</span> test_two_num_add<br>    result = add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>TypeError: add() missing <span class="hljs-number">1</span> required positional argument: <span class="hljs-string">&#x27;c&#x27;</span><br><br>----------------------------------------------------------------------<br>Ran <span class="hljs-number">1</span> test <span class="hljs-keyword">in</span> <span class="hljs-number">0.001</span>s<br><br>FAILED (errors=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>可以看到，在这里出的错就是E，即error了。<br>通过对比我们就能知道，E代表程序代码引发的测试错误，F代表程序输出的结果没有得到“预期的结果”（毕竟所谓预期的结果也是我们自己所定义的）。</p><h1>对类进行测试</h1><p><em><strong>to do…</strong></em></p><hr>]]></content>
    
    
    <categories>
      
      <category>Learning Log</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统原理——可变分区存储管理</title>
    <link href="/2022/04/20/variable-partition/"/>
    <url>/2022/04/20/variable-partition/</url>
    
    <content type="html"><![CDATA[<h1>原理</h1><p>进行一个实验报告的抄~</p><blockquote><p>可变分区方式是按作业需要的主存空间大小来分区。<br>当装入一个作业时，首先要查看是否有足够的空闲空间来分配，若有则按指定的分配方式进行分配；否则作业不能装入。</p><blockquote><p>可变分区的三种分配算法就是为作业分配主存空间的方法。</p><ul><li>最先适应算法：在空闲区间中查询满足作业需要的空间，并将作业装入第一个满足条件的空间中去。</li><li>最佳适应算法：在空闲区间中查询满足作业需要的空间，并将作业装入满足条件的空闲空间中最小的一个空间中去。</li><li>最坏适应算法：在空闲区间中查询满足作业需要的空间，并将作业装入满足条件的空闲空间中最大的一个空间中去。</li></ul></blockquote><blockquote><p>从三种算法的说明可以看出，分配空间的过程主要可以分两步：</p><ol><li>查询所有满足作业需求的空间块。</li><li>按照指定的算法将作业装入空间块中。</li></ol></blockquote><blockquote><p>可变分区的回收算法：</p><ul><li>回收区有下邻空闲区</li><li>回收区有上邻空闲区</li><li>归还区既有上邻空闲区又有下邻空闲区</li><li>归还区既无上邻空闲区又有下邻空闲区</li></ul></blockquote></blockquote><h1>实现</h1><h2 id="空闲表和已分配表">空闲表和已分配表</h2><p>这里其实根据我的作业要求只能用一个内存分区表（就是一个列表）来实现的，但是明显是用两个表来表示会更方便，这样就不需要标志属性了！<s>（偷懒）</s><br>所以我定义了两个全局变量，一个存空闲分区，一个存已分配分区。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">free_list = []  <span class="hljs-comment"># 空闲列表</span><br>allocated_list = []  <span class="hljs-comment"># 已分配列表</span><br></code></pre></td></tr></table></figure><h2 id="空闲空间和已分配空间">空闲空间和已分配空间</h2><p>这边用了两个类来表示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Free</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;空闲表类&quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, start, length</span>):<br>        self.start = start  <span class="hljs-comment"># 起址</span><br>        self.length = length    <span class="hljs-comment"># 长度</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Allocated</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;已分配表类&quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, start, length</span>):<br>        self.name = name    <span class="hljs-comment"># 作业名</span><br>        self.start = start  <span class="hljs-comment"># 起址</span><br>        self.length = length    <span class="hljs-comment"># 长度</span><br></code></pre></td></tr></table></figure><h2 id="读取用户输入">读取用户输入</h2><p>我先不急着实现功能，而是先做了“具有交互功能”（确信）的函数，能够让用户操作数据和读取数据！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">input_data</span>():<br>    <span class="hljs-string">&quot;&quot;&quot;读取用户输入以及操作&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">global</span> free_list, allocated_list<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        op = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请选择要进行的操作：A 分配主存； B 回收主存； C 显示主存； Q 退出；&quot;</span>)<br>        <span class="hljs-keyword">if</span> op == <span class="hljs-string">&#x27;A&#x27;</span>:<br>            job_name = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入作业名：&quot;</span>)<br>            length = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入作业长度&quot;</span>))<br>            algorithm = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入分配算法：A 最先适应； B 最优适应； C 最坏适应；&quot;</span>)<br>            <span class="hljs-keyword">if</span> algorithm == <span class="hljs-string">&#x27;A&#x27;</span>:<br>                allocate(job_name, length, algorithm)<br>            <span class="hljs-keyword">elif</span> algorithm == <span class="hljs-string">&#x27;B&#x27;</span>:<br>                allocate(job_name, length, algorithm)<br>            <span class="hljs-keyword">elif</span> algorithm == <span class="hljs-string">&#x27;C&#x27;</span>:<br>                allocate(job_name, length, algorithm)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;输入错误，请重新输入。&quot;</span>)<br>        <span class="hljs-keyword">elif</span> op == <span class="hljs-string">&#x27;B&#x27;</span>:<br>            recycle_name = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入要回收的作业名：&quot;</span>)<br>            recycle(recycle_name)<br>        <span class="hljs-keyword">elif</span> op == <span class="hljs-string">&#x27;C&#x27;</span>:<br>            display()<br>        <span class="hljs-keyword">elif</span> op == <span class="hljs-string">&#x27;Q&#x27;</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;程序退出。&quot;</span>)<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;输入错误，请重新输入。&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="显示主存空间">显示主存空间</h2><p>为了检查前面写的代码没什么问题，比如功能选择、空闲和已分配列表，我决定先实现这个函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">display</span>():<br>    <span class="hljs-string">&quot;&quot;&quot;打印两张表&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">global</span> free_list, allocated_list<br>    free_list_sort(<span class="hljs-string">&#x27;A&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;空闲表&quot;</span>.center(<span class="hljs-number">32</span>, <span class="hljs-string">&#x27;-&#x27;</span>))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;起址&quot;</span>.center(<span class="hljs-number">10</span>) + <span class="hljs-string">&quot;|&quot;</span> + <span class="hljs-string">&quot;长度&quot;</span>.center(<span class="hljs-number">10</span>) + <span class="hljs-string">&quot;|&quot;</span> + <span class="hljs-string">&quot;终址&quot;</span>.center(<span class="hljs-number">10</span>))<br>    <span class="hljs-keyword">for</span> free <span class="hljs-keyword">in</span> free_list:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;free.start&#125;</span>&quot;</span>.center(<span class="hljs-number">11</span>) + <span class="hljs-string">&quot;|&quot;</span> + <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;free.length&#125;</span>&quot;</span>.center(<br>            <span class="hljs-number">11</span>) + <span class="hljs-string">&quot;|&quot;</span> + <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;free.start + free.length - <span class="hljs-number">1</span>&#125;</span>&quot;</span>.center(<span class="hljs-number">11</span>))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&quot;</span>.center(<span class="hljs-number">34</span>, <span class="hljs-string">&#x27;-&#x27;</span>))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已分配表&quot;</span>.center(<span class="hljs-number">32</span>, <span class="hljs-string">&#x27;-&#x27;</span>))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;名字&quot;</span>.center(<span class="hljs-number">10</span>) + <span class="hljs-string">&quot;|&quot;</span> + <span class="hljs-string">&quot;起址&quot;</span>.center(<span class="hljs-number">10</span>) + <span class="hljs-string">&quot;|&quot;</span> + <span class="hljs-string">&quot;长度&quot;</span>.center(<span class="hljs-number">10</span>))<br>    <span class="hljs-keyword">for</span> job <span class="hljs-keyword">in</span> allocated_list:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;job.name&#125;</span>&quot;</span>.center(<span class="hljs-number">11</span>) + <span class="hljs-string">&quot;|&quot;</span> + <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;job.start&#125;</span>&quot;</span>.center(<br>            <span class="hljs-number">11</span>) + <span class="hljs-string">&quot;|&quot;</span> + <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;job.length&#125;</span>&quot;</span>.center(<span class="hljs-number">11</span>))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&quot;</span>.center(<span class="hljs-number">34</span>, <span class="hljs-string">&#x27;-&#x27;</span>))<br></code></pre></td></tr></table></figure><p>(请无视这粗暴的代码分行，这是我用IDEA快捷格式化出来的。。。)<br>如果不明白其中的<code>center</code>方法的话，可以看我之后的随笔（写完后会在这里放跳转链接）。<br>在这个函数第二行我调用了一个<code>free_list_sort</code>函数，作用如其名，用来对空闲分区列表中的空闲分区排序。</p><h2 id="对空闲分区列表进行排序">对空闲分区列表进行排序</h2><p>虽然看上去是写了一个函数，但其实用的还是python自带的<code>sorted</code>函数进行的排序<s>因为真的太好用啦</s><br>为什么要特地写这个函数？因为分配主存空间有三种算法，最先、最优和最坏适应，这里我就写了三个排序方式：按照起址、长度升序、长度逆序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">free_list_sort</span>(<span class="hljs-params">method</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;为空闲表选择排序方式&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">global</span> free_list<br>    <span class="hljs-keyword">if</span> method == <span class="hljs-string">&#x27;A&#x27;</span>:<br>        free_list = <span class="hljs-built_in">sorted</span>(free_list, key=<span class="hljs-keyword">lambda</span> free: free.start)  <span class="hljs-comment"># 按照起址排序</span><br>    <span class="hljs-keyword">elif</span> method == <span class="hljs-string">&#x27;B&#x27;</span>:<br>        free_list = <span class="hljs-built_in">sorted</span>(free_list, key=<span class="hljs-keyword">lambda</span> free: free.length)  <span class="hljs-comment"># 按照长度排序</span><br>    <span class="hljs-keyword">elif</span> method == <span class="hljs-string">&#x27;C&#x27;</span>:<br>        free_list = <span class="hljs-built_in">sorted</span>(free_list, key=<span class="hljs-keyword">lambda</span> free: free.length, reverse=<span class="hljs-literal">True</span>)  <span class="hljs-comment"># 按照长度排逆序</span><br></code></pre></td></tr></table></figure><p>这里的用到的<code>sorted</code>函数和<code>sort</code>方法类似，都接受两个作用一样的可选参数key和reverse，这两个参数有什么用可以看这篇文章：<a href="https://map1e-g.github.io/2022/04/17/python-essay-1/">点我跳转</a><br>而lambda表达式就是一个单表达式函数，也可以当成匿名函数。在对可迭代对象进行排序的时候，我们都可以用lambda表达式定义简短的key函数。关于lambda表达式可能之后会写在随笔或者学习笔记里。</p><h2 id="分配主存">分配主存</h2><p>虽然有三种算法，但是由于我的空闲分区和已分配分区是分开的，所以不同的地方只有排序上，剩下的找空闲分区并安排的操作是一样的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">allocate</span>(<span class="hljs-params">name, length, method</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;分配主存空间&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">global</span> free_list, allocated_list<br>    free_list_sort(method)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(free_list)):<br>        <span class="hljs-comment"># 找到可进行分配的空间</span><br>        <span class="hljs-keyword">if</span> free_list[i].length &gt;= length:<br>            allocated_list.append(Allocated(name, free_list[i].start, length))<br>            allocated_list = <span class="hljs-built_in">sorted</span>(allocated_list, key=<span class="hljs-keyword">lambda</span> job: job.start)<br>            <span class="hljs-keyword">if</span> free_list[i].length == length:<br>                <span class="hljs-keyword">del</span> free_list[i]<br>            <span class="hljs-keyword">else</span>:<br>                free_list[i].start = free_list[i].start + length<br>                free_list[i].length = free_list[i].length - length<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;分配成功！&quot;</span>)<br>            <span class="hljs-keyword">return</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;分配失败！&quot;</span>)<br></code></pre></td></tr></table></figure><p>在找空闲分区前，我们先按照给定的算法对空闲分区列表进行排序，然后再去遍历这个列表，尝试找到合适的分区并对作业进行分配。<br>这里有两种情况，一种是作业长度刚好等于找到的空闲分区长度，这时候直接删除掉对应的空闲分区即可；若作业长度小于空闲分区的长度，这个空闲分区就应该重新计算起址和长度。</p><h2 id="回收主存">回收主存</h2><p>这部分其实涉及到两个东西，一个是回收，一个是合并。<br>先来看回收：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">recycle</span>(<span class="hljs-params">name</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;回收空间&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">global</span> free_list, allocated_list<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(allocated_list)):<br>        <span class="hljs-comment"># 检查已分配表中是否有该作业</span><br>        <span class="hljs-keyword">if</span> allocated_list[i].name == name:<br>            free_list.append(Free(allocated_list[i].start, allocated_list[i].length))<br>            free_list_sort(<span class="hljs-string">&#x27;A&#x27;</span>)<br>            <span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(free_list)):<br>                <span class="hljs-comment"># 找出新加入的空闲表的索引并调用merge函数进行合并</span><br>                <span class="hljs-keyword">if</span> free_list[index].start == allocated_list[i].start:<br>                    merge(index)<br>                    <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">del</span> allocated_list[i]<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;回收成功！&quot;</span>)<br>            <span class="hljs-keyword">return</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;回收失败！&quot;</span>)<br></code></pre></td></tr></table></figure><p>可以看出遍历一遍已分配列表就好啦，找到对应名字的作业后，先在空闲分区列表中加入一个新的空闲分区，然后对这个新的空闲分区调用<code>merge</code>函数进行合并，最后使用<code>del</code>函数删除掉这个作业即可~<br>那么我们再来看看合并函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">index</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;合并空间&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">global</span> free_list<br>    <span class="hljs-keyword">if</span> index == <span class="hljs-number">0</span>:<br>        <span class="hljs-comment"># 第一个元素，只需向下合并</span><br>        <span class="hljs-keyword">if</span> free_list[index].start + free_list[index].length == free_list[index + <span class="hljs-number">1</span>].start:<br>            <span class="hljs-comment"># 当前起址加上长度等于下个起址，可以合并</span><br>            free_list[index].length = free_list[index].length + free_list[index + <span class="hljs-number">1</span>].length<br>            <span class="hljs-keyword">del</span> free_list[index + <span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">elif</span> index == <span class="hljs-built_in">len</span>(free_list) - <span class="hljs-number">1</span>:<br>        <span class="hljs-comment"># 最后一个元素，只需向上合并</span><br>        <span class="hljs-keyword">if</span> free_list[index - <span class="hljs-number">1</span>].start + free_list[index - <span class="hljs-number">1</span>].length == free_list[index].start:<br>            <span class="hljs-comment"># 上个起址加上长度等于当前起址，可以合并</span><br>            free_list[index - <span class="hljs-number">1</span>].length = free_list[index - <span class="hljs-number">1</span>].length + free_list[index].length<br>            <span class="hljs-keyword">del</span> free_list[index]<br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment"># 向上向下均要检查</span><br>        <span class="hljs-keyword">if</span> free_list[index].start + free_list[index].length == free_list[index + <span class="hljs-number">1</span>].start:<br>            <span class="hljs-comment"># 当前起址加上长度等于下个起址，可以合并</span><br>            free_list[index].length = free_list[index].length + free_list[index + <span class="hljs-number">1</span>].length<br>            <span class="hljs-keyword">del</span> free_list[index + <span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">if</span> free_list[index - <span class="hljs-number">1</span>].start + free_list[index - <span class="hljs-number">1</span>].length == free_list[index].start:<br>            <span class="hljs-comment"># 上个起址加上长度等于当前起址，可以合并</span><br>            free_list[index - <span class="hljs-number">1</span>].length = free_list[index - <span class="hljs-number">1</span>].length + free_list[index].length<br>            <span class="hljs-keyword">del</span> free_list[index]<br>        <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p>由于我们在回收的时候重新“整理”（排序）了空闲分区列表，列表中的空闲分区现在是连续（有序）的，所以可以直接用下标进行数据处理。<br>不过在上下均要回收的时候，不要搞错了数组下标以及合并先后顺序、合并的应该是哪个空闲分区。</p><h2 id="测试代码">测试代码</h2><p>为了方便提前提供了一点数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 预输入数据</span><br>    free_1 = Free(<span class="hljs-number">10</span>, <span class="hljs-number">16</span>)<br>    free_2 = Free(<span class="hljs-number">36</span>, <span class="hljs-number">14</span>)<br>    free_3 = Free(<span class="hljs-number">55</span>, <span class="hljs-number">10</span>)<br>    free_4 = Free(<span class="hljs-number">70</span>, <span class="hljs-number">30</span>)<br>    free_list.append(free_1)<br>    free_list.append(free_2)<br>    free_list.append(free_3)<br>    free_list.append(free_4)<br>    job_1 = Allocated(<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-number">26</span>, <span class="hljs-number">10</span>)<br>    job_2 = Allocated(<span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-number">50</span>, <span class="hljs-number">5</span>)<br>    job_3 = Allocated(<span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-number">65</span>, <span class="hljs-number">5</span>)<br>    allocated_list.append(job_1)<br>    allocated_list.append(job_2)<br>    allocated_list.append(job_3)<br>    input_data()<br></code></pre></td></tr></table></figure><p>那么代码部分到这就堂堂完结啦</p><h1>运行结果</h1><p>这部分还请大家自行验证（因为不想放图…）</p><h1>尾声</h1><h2 id="s-font-size-3-face-Microsoft-YaHei-尾声就是没有尾声。-font-s"><s><font size=3 face='Microsoft YaHei'>尾声就是没有尾声。</font></s></h2>]]></content>
    
    
    <categories>
      
      <category>Learning Log</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>操作系统</tag>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python学习笔记——列表中的方法</title>
    <link href="/2022/04/20/python-learning-2/"/>
    <url>/2022/04/20/python-learning-2/</url>
    
    <content type="html"><![CDATA[<h1>列表中的方法</h1><p>我们先定义(约定好)一个用于示例的列表，以方便后续调用它。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a_list = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>,]<br></code></pre></td></tr></table></figure><h2 id="append-e-方法"><code>append(e)</code>方法</h2><div class="note note-info">            <p><strong>描述：</strong><br>在尾部添加一个元素 e</p>          </div>  <p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a_list.append(<span class="hljs-number">6</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>a_list<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]<br></code></pre></td></tr></table></figure><h2 id="clear-方法"><code>clear()</code>方法</h2><div class="note note-info">            <p><strong>描述：</strong><br>删除所有元素</p>          </div>  <p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a_list.clear()<br><span class="hljs-meta">&gt;&gt;&gt; </span>a_list<br>[]<br></code></pre></td></tr></table></figure><h2 id="copy-方法"><code>copy()</code>方法</h2><div class="note note-info">            <p><strong>描述：</strong><br>对列表进行<strong>浅复制</strong></p>          </div>  <p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">class</span> <span class="hljs-title class_">stock</span>:<br><span class="hljs-meta">... </span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, num</span>):<br><span class="hljs-meta">... </span>        self.num = num<br>        <br><span class="hljs-meta">&gt;&gt;&gt; </span>A = stock(<span class="hljs-number">5</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>a_list = [A]<br><span class="hljs-meta">&gt;&gt;&gt; </span>b_list = a_list.copy()<br><span class="hljs-meta">&gt;&gt;&gt; </span>A.num = <span class="hljs-number">4</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>b_list[<span class="hljs-number">0</span>].num<br><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>说明：这里涉及到一个概念：<strong>浅复制（浅拷贝）<strong>和</strong>深复制（深拷贝）</strong>。</p><p>“<strong>浅复制</strong>是指构建一个新的容器对象，然后填充原对象中子对象的引用。本质上浅复制只执行一层，复制过程不会递归，因此不会创建子对象的副本。<br><strong>深复制</strong>是递归复制，首先构造一个新的容器对象，然后递归地填充原始对象中子对象的副本。”<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="《Python Tricks 深入理解python特性》 [德]达恩·巴德尔 人民邮电出版社">[1]</span></a></sup></p><h2 id="count-e-方法"><code>count(e)</code>方法</h2><div class="note note-info">            <p><strong>描述：</strong><br>列表中 e 元素出现的次数</p>          </div>  <p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a_list.count(<span class="hljs-number">1</span>)<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="extend-it-方法"><code>extend(it)</code>方法</h2><div class="note note-info">            <p><strong>描述：</strong><br>将可迭代对象 it 里的元素添加到尾部</p>          </div>  <p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>b_list = [<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>a_list.extend(b_list)<br><span class="hljs-meta">&gt;&gt;&gt; </span>a_list<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><h2 id="index-e-方法"><code>index(e)</code>方法</h2><div class="note note-info">            <p><strong>描述：</strong><br>找到 e 在序列中第一次出现的位置</p>          </div>  <p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a_list.index(<span class="hljs-number">4</span>)<br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h2 id="insert-i-e-方法"><code>insert(i, e)</code>方法</h2><div class="note note-info">            <p><strong>描述：</strong><br>在索引 i 处添加空间，并将 e 元素插入到这个地方</p>          </div>  <p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a_list.insert(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>a_list<br>[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><h2 id="pop-i-方法"><code>pop([i])</code>方法</h2><div class="note note-info">            <p><strong>描述：</strong><br>删除索引 i 位置的值并<strong>返回</strong>这个值，i 的默认值为最后一个元素的位置</p>          </div>  <p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a_list.pop(<span class="hljs-number">0</span>)<br><span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a_list.pop()<br><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h2 id="remove-e-方法"><code>remove(e)</code>方法</h2><div class="note note-info">            <p><strong>描述：</strong><br>删除列表里第一次出现的 e 元素</p>          </div>  <p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a_list.remove(<span class="hljs-number">3</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>a_list<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><h2 id="reverse-方法"><code>reverse()</code>方法</h2><div class="note note-info">            <p><strong>描述：</strong><br>反转列表元素的排列顺序</p>          </div>  <p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a_list.reverse()<br><span class="hljs-meta">&gt;&gt;&gt; </span>a_list<br>[<span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h2 id="sort-key-reverse-方法"><code>sort([key], [reverse])</code>方法</h2><div class="note note-info">            <p><strong>描述：</strong><br>就地对列表进行排序，reverse默认值为False</p>          </div>  <p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a_list.sort(reverse = <span class="hljs-literal">True</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>a_list<br>[<span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>说明：<br>建议配合<a href="https://map1e-g.github.io/2022/04/17/python-essay-1/">这篇随笔</a>食用</p><hr><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>《Python Tricks 深入理解python特性》 [德]达恩·巴德尔 人民邮电出版社<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Learning Log</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python随笔-1</title>
    <link href="/2022/04/17/python-essay-1/"/>
    <url>/2022/04/17/python-essay-1/</url>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>其实就是想补充下多道系统作业那篇文章里讲到的东西（指getMethod函数），补充下相关知识方便各位理解。</p><h1>正文</h1><h2 id="前后双下划线方法">前后双下划线方法</h2><p>同时具有前后双下划线的名称在Python中有特殊用途，我们最熟悉的应该就是<code>__init__</code>了，构造对象函数。当然啦，Python还是有非常多的对象属性的，如果想了解更多对象属性，可以调用<code>dir</code>函数，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">dir</span>(<span class="hljs-built_in">max</span>)<br>[<span class="hljs-string">&#x27;__call__&#x27;</span>, <span class="hljs-string">&#x27;__class__&#x27;</span>, <span class="hljs-string">&#x27;__delattr__&#x27;</span>, <span class="hljs-string">&#x27;__dir__&#x27;</span>, <span class="hljs-string">&#x27;__doc__&#x27;</span>, <br><span class="hljs-string">&#x27;__eq__&#x27;</span>, <span class="hljs-string">&#x27;__format__&#x27;</span>, <span class="hljs-string">&#x27;__ge__&#x27;</span>, <span class="hljs-string">&#x27;__getattribute__&#x27;</span>, <span class="hljs-string">&#x27;__gt__&#x27;</span>, <br><span class="hljs-string">&#x27;__hash__&#x27;</span>, <span class="hljs-string">&#x27;__init__&#x27;</span>, <span class="hljs-string">&#x27;__init_subclass__&#x27;</span>, <span class="hljs-string">&#x27;__le__&#x27;</span>, <span class="hljs-string">&#x27;__lt__&#x27;</span>, <br><span class="hljs-string">&#x27;__module__&#x27;</span>, <span class="hljs-string">&#x27;__name__&#x27;</span>, <span class="hljs-string">&#x27;__ne__&#x27;</span>, <span class="hljs-string">&#x27;__new__&#x27;</span>, <span class="hljs-string">&#x27;__qualname__&#x27;</span>,<br> <span class="hljs-string">&#x27;__reduce__&#x27;</span>, <span class="hljs-string">&#x27;__reduce_ex__&#x27;</span>, <span class="hljs-string">&#x27;__repr__&#x27;</span>, <span class="hljs-string">&#x27;__self__&#x27;</span>, <span class="hljs-string">&#x27;__setattr__&#x27;</span>,<br>  <span class="hljs-string">&#x27;__sizeof__&#x27;</span>, <span class="hljs-string">&#x27;__str__&#x27;</span>, <span class="hljs-string">&#x27;__subclasshook__&#x27;</span>, <span class="hljs-string">&#x27;__text_signature__&#x27;</span>]<br></code></pre></td></tr></table></figure><p>在这里，我直接查看了一个内置函数<code>max</code>的属性，可以看到有非常多属性，我们也不必全部知道他们都用来干嘛。<br>仔细看的话会发现，<code>__lt__</code>也在里面，那么它到底是什么呢？其实它代表的是<strong>比较运算符’&lt;'</strong>。</p><h2 id="sort函数">sort函数</h2><p>先上Python官方文档<a href="https://docs.python.org/3.9/library/stdtypes.html#list.sort">点我跳转</a>：</p><blockquote><p>sort(*, key=None, reverse=False)</p><blockquote><p>This method sorts the list in place, using only &lt; comparisons between items. Exceptions are not suppressed - if any comparison operations fail, the entire sort operation will fail (and the list will likely be left in a partially modified state).</p></blockquote></blockquote><p>也就是说，<code>sort</code>方法其实是根据 &lt; 运算符来进行排序的，也就是升序排序，如果觉得文字难以读懂，不妨写点东西试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>=[<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>.sort()<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>)<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><p>我们也应该记住一点，<code>sort</code>的排序算法是稳定的，当两个值相等的时候，即使是排序后它们的相对位置也不会变。<br><em><strong>扩展</strong></em></p><blockquote><p>从上面我们能看到<code>sort</code>还支持两个额外的参数（注意是keyword-only arguments，传入必须像这样：<code>key=xxx, reverse=xxx</code>）<br>reverse很好理解，传入一个Boolean值（True or False），如果是True则倒序排列，默认为False。<br>key则用来产生排序算法所依赖的对比关键字，比如说，在对一些字符串排序时，可以用<code>key=str.lower</code>来实现忽略大小写的排序，或者用<code>key=len</code>来实现基于字符串长度的排序。</p></blockquote><h1>小结</h1><p>看完上面这点，再结合函数学习笔记那里的一些知识，其实就应该能清楚知道<code>getMethod</code>的机制和作用什么的了，传入一个字符串，根据字符串的不同返回不同的函数对象，用来重载JCB类的<code>__lt__</code>属性（在Python中是可以重载运算符的），这样在之后，我们对含有JCB类对象的列表中调用<code>sort</code>方法，就可以按照我们想要的排序方式来排序列表了。</p><hr>]]></content>
    
    
    <categories>
      
      <category>Essay</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python学习笔记——函数</title>
    <link href="/2022/04/14/python-learning-1/"/>
    <url>/2022/04/14/python-learning-1/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>本文章用到的语言：Python</p>          </div><h1>函数作为对象</h1><p>在Python中，函数也是对象，所以我们可以把函数分配给变量、存储在数据结构中、作为参数传递给其他函数，也能作为其他函数的返回值。<br>初次看到这些内容的时候，我是挺惊讶而且发自内心的“すごい！”并且迫不及待地想要理解和掌握。<br>感觉写文章就是一个非常不错的方式，所以在这里我会尝试用自己所理解到的东西来完成这篇文章。<br>如果有什么问题的话可以尝试联系我~ <a href="https://map1e-g.github.io/about/">联系我</a></p><h2 id="怎么理解函数是对象">怎么理解函数是对象</h2><p>现在有这样一个东西：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-keyword">return</span> a + b<br></code></pre></td></tr></table></figure><p>这就是一个加法函数，传入 a 和 b 的值然后返回二者相加的值，我们可以在控制台调用它得到这样一个结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>如果我现在这么做的话（可以思考一下这段代码做了什么以及输出的结果）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>another_add = add<br><span class="hljs-meta">&gt;&gt;&gt; </span>another_add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>没错，输出的结果就是<code>5</code><br>接下来我们把原来定义的<code>add</code>函数用del删除，再调用<code>another_add</code>试试看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">del</span> add<br><span class="hljs-meta">&gt;&gt;&gt; </span>add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>NameError: name <span class="hljs-string">&#x27;add&#x27;</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> defined<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>another_add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>现在<code>add</code>用不了了，但是<code>another_add</code>还能用，为什么呢？因为函数对象及其名称是相互独立的实体：<strong>指向函数的变量和函数本身实际上是彼此独立的</strong>。<br>这边可以了解一下下面这些东西（引用<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="《Python编程 从入门到实践（第2版）》 [美]埃里克·马瑟斯 人民邮电出版社">[1]</span></a></sup>）：</p><blockquote><p>变量是标签</p><blockquote><p>变量常被描述为可用于存储值的盒子。<br><strong>一种好得多的定义是，变量是可以赋给值的标签，也可以说变量指向特定的值。</strong></p></blockquote></blockquote><p><em><strong>以下是扩展</strong></em></p><blockquote><p>Python在创建函数时都会为每个函数附加一个用于调试的字符串标识符，使用__name__属性来访问它：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>add.__name__<br><span class="hljs-string">&#x27;add&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>another.__name__<br><span class="hljs-string">&#x27;add&#x27;</span><br></code></pre></td></tr></table></figure><p>PS:当然是在<code>add</code>没被删除之前调用的，删除后调用了会报错：<code>NameError: name 'add' is not defined</code><br>由于是在创建函数的时候给出的标识符，所以即使把这个函数分配给了另一个变量，这个标识符也不会变</p></blockquote><h2 id="把函数存储在数据结构中！">把函数存储在数据结构中！</h2><p>由于函数是个对象，所以可以把函数也存储在数据结构当中，并且访问或使用他们。<br>比如把他们塞进列表里：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>funcs = [another_add, <span class="hljs-built_in">max</span>, <span class="hljs-built_in">pow</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>funcs<br>[&lt;function add at <span class="hljs-number">0x0000024777A49E50</span>&gt;, &lt;built-<span class="hljs-keyword">in</span> function <span class="hljs-built_in">max</span>&gt;, &lt;built-<span class="hljs-keyword">in</span> function <span class="hljs-built_in">pow</span>&gt;]<br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> fun <span class="hljs-keyword">in</span> funcs:<br><span class="hljs-meta">... </span>   <span class="hljs-built_in">print</span>(fun, fun(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>))<br>&lt;function add at <span class="hljs-number">0x0000024777A49E50</span>&gt; <span class="hljs-number">5</span><br>&lt;built-<span class="hljs-keyword">in</span> function <span class="hljs-built_in">max</span>&gt; <span class="hljs-number">3</span><br>&lt;built-<span class="hljs-keyword">in</span> function <span class="hljs-built_in">pow</span>&gt; <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>你也可以把它们塞进字典里，同样的，我们尝试访问这个字典，然后试着遍历这个字典并调用这些函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>dic_funcs = &#123;<span class="hljs-string">&#x27;another_add&#x27;</span>:another_add, <span class="hljs-string">&#x27;max&#x27;</span>:<span class="hljs-built_in">max</span>, <span class="hljs-string">&#x27;pow&#x27;</span>:<span class="hljs-built_in">pow</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>dic_funcs<br>&#123;<span class="hljs-string">&#x27;another_add&#x27;</span>: &lt;function add at <span class="hljs-number">0x0000024777A49E50</span>&gt;, <span class="hljs-string">&#x27;max&#x27;</span>: &lt;built-<span class="hljs-keyword">in</span> function <span class="hljs-built_in">max</span>&gt;, <span class="hljs-string">&#x27;pow&#x27;</span>: &lt;built-<span class="hljs-keyword">in</span> function <span class="hljs-built_in">pow</span>&gt;&#125;<br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> fun <span class="hljs-keyword">in</span> dic_funcs.values():<br><span class="hljs-meta">... </span>   <span class="hljs-built_in">print</span>(fun, fun(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>))<br>    <br>&lt;function add at <span class="hljs-number">0x0000024777A49E50</span>&gt; <span class="hljs-number">5</span><br>&lt;built-<span class="hljs-keyword">in</span> function <span class="hljs-built_in">max</span>&gt; <span class="hljs-number">3</span><br>&lt;built-<span class="hljs-keyword">in</span> function <span class="hljs-built_in">pow</span>&gt; <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>并且，在这些数据结构里的函数对象都可以直接调用，不需要特意为他们分配一个变量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>funcs[<span class="hljs-number">0</span>](<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><span class="hljs-number">5</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>dic_funcs[<span class="hljs-string">&#x27;max&#x27;</span>](<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<br><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p><em><strong>本小节的补充</strong></em></p><blockquote><p><code>&lt;built-in function max&gt;</code>指出<code>max</code>函数是python的一个内置函数，所以给出的不是地址<br><code>max</code>函数用于查找可迭代的最大值，关于可迭代，在之后的文章可能会介绍（也是python特性哦）<br><code>pow(x, y)</code>函数就是平方函数了，将x的值返回为y的幂</p></blockquote><h2 id="将函数传递给其他函数">将函数传递给其他函数</h2><p>由于函数是对象，因此可以将其作为参数传递给其他函数。<br>让我们通过一个例子来理解下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_max_or_min</span>(<span class="hljs-params">fun</span>):<br>value = fun(<span class="hljs-number">10</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">6</span>)<br><span class="hljs-built_in">print</span>(value)<br></code></pre></td></tr></table></figure><p><code>get_max_or_min</code>函数获取一个函数参数，并调用这个函数得到一个值，然后将它打印出来，在这里可以由函数的名称看出来，我们可以向其中传入<code>max</code>或<code>min</code>函数<br>让我们尝试一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>get_max_or_min(<span class="hljs-built_in">max</span>)<br><span class="hljs-number">10</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>get_max_or_min(<span class="hljs-built_in">min</span>)<br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>可以看到都输出了正确的结果<br>“将函数对象作为参数传递给其他函数的功能非常强大，可以用来将程序中的<strong>行为</strong>抽象出来并传递出去。”<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="《Python Tricks 深入理解python特性》 [德]达恩·巴德尔 人民邮电出版社">[2]</span></a></sup><br><em><strong>扩展</strong></em><sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="《Python Tricks 深入理解python特性》 [德]达恩·巴德尔 人民邮电出版社">[2]</span></a></sup></p><blockquote><p>“能接受其他函数作为参数的函数称为<strong>高阶函数</strong>。”<br>“比如<code>map</code>函数，<code>map</code>接受一个函数对象和一个可迭代对象，然后在可迭代对象中的每个元素上调用该函数来生成结果。”<br>这里我们调用我们的<code>add</code>函数来看看<code>map</code>函数做了什么：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(add, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]))<br>[<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>]<br></code></pre></td></tr></table></figure><p>可以看出，<code>map</code>函数遍历了整个列表并将<code>add</code>函数应用于每个元素，而且得到了一个新列表对象，存储两数相加后的结果。</p></blockquote><h2 id="嵌套函数">嵌套函数</h2><p>在Python中，甚至可以在函数中定义函数，就是之前写多道系统作业调度模拟程序提到过的东西（<a href="https://map1e-g.github.io/2022/04/13/multi-JCB/">戳我跳转文章</a>）<br>在这里我们定义一个用来计算的函数，根据传入字符串的不同返回不同的结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">cal</span>(<span class="hljs-params">text, x, y</span>):<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>):<br><span class="hljs-keyword">return</span> a + b<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sub</span>(<span class="hljs-params">a, b</span>):<br><span class="hljs-keyword">return</span> a - b<br><span class="hljs-keyword">if</span> text == <span class="hljs-string">&#x27;add&#x27;</span>:<br><span class="hljs-keyword">return</span> add(x, y)<br><span class="hljs-keyword">elif</span> text == <span class="hljs-string">&#x27;sub&#x27;</span>:<br><span class="hljs-keyword">return</span> sub(x, y)<br><span class="hljs-meta">&gt;&gt;&gt; </span>cal(<span class="hljs-string">&#x27;add&#x27;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>)<br><span class="hljs-number">8</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>cal(<span class="hljs-string">&#x27;sub&#x27;</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>)<br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>但是需要注意的是嵌套函数的作用域：<strong>仅在创建它的函数的内部</strong><br>如果我们想在函数外部使用这个函数的话，可以像我上边提到的那篇文章中那样，创建一个变量，并把嵌套函数返回给父函数的调用者。<br>在这里，我就写个根据会员等级判断打折力度的函数来作为例子吧：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">discount</span>(<span class="hljs-params">level</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">platinum</span>(<span class="hljs-params">price</span>):<br>        <span class="hljs-keyword">return</span> price*<span class="hljs-number">0.75</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">gold</span>(<span class="hljs-params">price</span>):<br>        <span class="hljs-keyword">return</span> price*<span class="hljs-number">0.8</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sliver</span>(<span class="hljs-params">price</span>):<br>        <span class="hljs-keyword">return</span> price*<span class="hljs-number">0.85</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">copper</span>(<span class="hljs-params">price</span>):<br>        <span class="hljs-keyword">return</span> price*<span class="hljs-number">0.9</span><br>    <span class="hljs-keyword">if</span> level == <span class="hljs-number">4</span>:<br>        <span class="hljs-keyword">return</span> platinum<br>    <span class="hljs-keyword">elif</span> level == <span class="hljs-number">3</span>:<br>        <span class="hljs-keyword">return</span> gold<br>    <span class="hljs-keyword">elif</span> level == <span class="hljs-number">2</span>:<br>        <span class="hljs-keyword">return</span> sliver<br>    <span class="hljs-keyword">elif</span> level == <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> copper<br></code></pre></td></tr></table></figure><p>然后再测试一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>discount(<span class="hljs-number">3</span>)<br>&lt;function discount.&lt;<span class="hljs-built_in">locals</span>&gt;.gold at <span class="hljs-number">0x000001CF0C9BE3A0</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>a_customer = discount(<span class="hljs-number">3</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>a_customer(<span class="hljs-number">100</span>)<br><span class="hljs-number">80.0</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>discount(<span class="hljs-number">3</span>)(<span class="hljs-number">100</span>)<br><span class="hljs-number">80.0</span><br></code></pre></td></tr></table></figure><p><em>“这意味着函数不仅可以通过参数<strong>接受行为</strong>，还可以<strong>返回行为</strong>。”</em><sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="《Python Tricks 深入理解python特性》 [德]达恩·巴德尔 人民邮电出版社">[2]</span></a></sup></p><h2 id="日后计划">日后计划</h2><p>以后学到的有关函数这部分的内容也会一起在这里更新。</p><hr><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>《Python编程 从入门到实践（第2版）》 [美]埃里克·马瑟斯 人民邮电出版社<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>《Python Tricks 深入理解python特性》 [德]达恩·巴德尔 人民邮电出版社<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Learning Log</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统原理——多道系统作业调度</title>
    <link href="/2022/04/13/multi-JCB/"/>
    <url>/2022/04/13/multi-JCB/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>本文章用到的语言：Python</p>          </div><h1>前言</h1><p>其实一周前就把程序写完了，但是因为博客最近才搭好以及最近才学习了一手markdown所以现在才开始写<s><em>（绝对不是我懒！）</em></s><br>操作系统课程的作业，其实挺不想写的<s>（真的）</s>，毕竟我数据结构与算法学得很垃圾www，就当顺便学习python好了</p><h1>原理</h1><p>这部分略过。（因为真的没什么好写的，以后再补充一下吧）</p><blockquote><p>复制实验说明上的原话：</p><blockquote><p>由于在多道批处理系统中，一批作业投入运行，调度作业时需要根据当前系统各类空闲资源的情况选择一个或多个作业进入内存，再按照进程调度方式选择一个作业的进程占用 CPU。<br>每个作业由一个作业控制块JCB表示，JCB可以包含如下信息：作业名、提交时间、所需的运行时间、所需的资源、作业状态、链指针等等。<br>作业的状态可以是等待W(Wait)、运行R(Run)和完成F(Finish)三种状态之一。每个作业的最初状态总是等待W。<br>各个等待的作业按照提交时刻的先后次序排队，总是首先调度等待队列中队首的作业。<br>每个作业完成后要打印该作业的开始运行时刻、完成时刻、周转时间和带权周转时间，这一组作业完成后要计算并打印这组作业的平均周转时间、带权平均周转时间。</p></blockquote></blockquote><h1>实现</h1><h2 id="核心">核心</h2><p>有两部分，先说第一部分：作业控制块（JCB）<br>其实这里存的东西过多了，但是好处就是意思都很清晰，后面计算总时间或者打印信息什么的也方便</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">JCB</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;作业控制块&quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, job_name, commit_time, run_time, source</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;初始化作业程序块&quot;&quot;&quot;</span><br>        self.job_name = job_name  <span class="hljs-comment"># 作业名字</span><br>        self.commit_time = commit_time  <span class="hljs-comment"># 作业提交时间</span><br>        self.run_time = run_time  <span class="hljs-comment"># 作业所需时间</span><br>        self.start_time = <span class="hljs-number">0</span>  <span class="hljs-comment"># 作业开始时间</span><br>        self.finish_time = <span class="hljs-number">0</span>  <span class="hljs-comment"># 作业完成时间</span><br>        self.rr = <span class="hljs-number">0</span>  <span class="hljs-comment"># 作业响应比</span><br>        self.status = <span class="hljs-string">&#x27;w&#x27;</span>  <span class="hljs-comment"># 程序状态，w为等待，r为运行，f为完成</span><br>        self.ta_time = <span class="hljs-number">0</span>  <span class="hljs-comment"># 作业周转时间</span><br>        self.wta_time = <span class="hljs-number">0</span>  <span class="hljs-comment"># 作业带权周转时间</span><br>        self.source = source  <span class="hljs-comment"># 作业所需资源</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">cul_rr</span>(<span class="hljs-params">self, clock</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;计算作业相应比&quot;&quot;&quot;</span><br>        self.rr = ((clock - self.commit_time) + self.run_time) / self.run_time<br></code></pre></td></tr></table></figure><p>然后是第二部分，这部分用到了python的特性：双下划线方法以及嵌套函数、返回函数等，这里用到的特性会放到后面要写的一些文章中更详细地介绍。<br>先看代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">getMethod</span>(<span class="hljs-params">method</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;不同算法的排序方法&quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">FCFS_lt</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-keyword">return</span> self.commit_time &lt; other.commit_time<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">SJF_lt</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-keyword">return</span> self.run_time &lt; other.run_time<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">HRRF_lt</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-keyword">return</span> self.rr &gt; other.rr<br><br>    <span class="hljs-keyword">if</span> method == <span class="hljs-string">&#x27;FCFS&#x27;</span>:<br>        <span class="hljs-keyword">return</span> FCFS_lt<br>    <span class="hljs-keyword">elif</span> method == <span class="hljs-string">&#x27;SJF&#x27;</span>:<br>        <span class="hljs-keyword">return</span> SJF_lt<br>    <span class="hljs-keyword">elif</span> method == <span class="hljs-string">&#x27;HRRF&#x27;</span>:<br>        <span class="hljs-keyword">return</span> HRRF_lt<br></code></pre></td></tr></table></figure><p>调用这个方法，传入一个字符串，根据不同的字符串返回不同的排序方法，这里一共用到了三种算法：</p><ul><li>FCFS：先来先服务</li><li>SJF：短作业优先</li><li>HRRF：响应比最高者优先</li></ul><p>比如我要用FCFS，那么就：<code>JCB.__lt__ = getMethod('FCFS')</code>，这里getMethod返回了一个函数对象，再赋值给了JCB类的<code>__lt__()</code>方法，这样<code>JCB.__lt__()</code>就和<code>FCFS_lt()</code>一样了（<strong>我省略了参数order</strong>），这个方法在之后的文章再详细说，<br>现在可以这样理解：这么做重载了JCB类的默认比较方法，两个JCB之间可以比大小了，怎么比就看<code>__lt__()</code>里了。<br>那么能比较大小了，排序就能方便起来，而python里边提供了<code>sort()</code>函数来对列表进行永久排序，这个时候即使列表里是一堆JCB对象，我们也可以进行排序。</p><h2 id="算法部分">算法部分</h2><p>注释写得算比较清楚所以在这里不多赘述了，以后有空说不定会更新<s>（实打实的懒狗）</s><br>其实写得不算好吧…自己感觉是写复杂了，某些地方凭感觉写了点东西保证不出错，比如那个删除队列，按道理来说有写判断条件的话就不会出错</p><div class="note note-warning">            <p>注意这里用到了<code>copy.deepcopy()</code>，需要导入copy模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> copy<br></code></pre></td></tr></table></figure>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">simulator</span>(<span class="hljs-params">JCB_queue, method, src</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;作业调度模拟程序&quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 系统时钟和资源数</span><br>    clock = <span class="hljs-number">0</span><br>    source = src<br>    <span class="hljs-comment"># 平均周转时间</span><br>    avg_ta_time = <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 平均带权周转时间</span><br>    avg_wta_time = <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 拷贝队列</span><br>    copy_queue = copy.deepcopy(JCB_queue)<br>    <span class="hljs-comment"># 队列长度</span><br>    queue_len = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">len</span>(copy_queue))<br>    <span class="hljs-comment"># 创建执行队列和等待队列</span><br>    wait_queue = []<br>    run_queue = []<br>    num = <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 排序</span><br>    JCB.__lt__ = getMethod(<span class="hljs-string">&#x27;FCFS&#x27;</span>)<br>    copy_queue.sort()<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-comment"># 运行队列中的作业变更</span><br>        <span class="hljs-keyword">if</span> run_queue:<br>            <span class="hljs-keyword">for</span> job <span class="hljs-keyword">in</span> run_queue:<br>                <span class="hljs-comment"># 检查作业是否完成</span><br>                <span class="hljs-keyword">if</span> job.run_time &lt;= clock - job.start_time <span class="hljs-keyword">and</span> job.status == <span class="hljs-string">&#x27;r&#x27;</span>:<br>                    job.status = <span class="hljs-string">&#x27;f&#x27;</span>  <span class="hljs-comment"># 将当前作业状态设置为完成</span><br>                    job.finish_time = clock  <span class="hljs-comment"># 作业完成（结束）时间为当前系统时间</span><br>                    job.ta_time = job.finish_time - job.commit_time  <span class="hljs-comment"># 作业周转时间 = 作业完成时间 - 作业提交时间</span><br>                    job.wta_time = job.ta_time / job.run_time  <span class="hljs-comment"># 作业带权周转时间 = 作业周转时间 / 作业所需时间</span><br>                    avg_ta_time = avg_ta_time + job.ta_time<br>                    avg_wta_time = avg_wta_time + job.wta_time<br>                    num = num + <span class="hljs-number">1</span>  <span class="hljs-comment"># 作业完成数+1</span><br>                    source = source + job.source  <span class="hljs-comment"># 归还资源</span><br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;作业名：<span class="hljs-subst">&#123;job.job_name&#125;</span>\t&quot;</span><br>                          <span class="hljs-string">f&quot;作业开始时间：<span class="hljs-subst">&#123;job.start_time&#125;</span>\t&quot;</span><br>                          <span class="hljs-string">f&quot;作业完成时间：<span class="hljs-subst">&#123;job.finish_time&#125;</span>\t&quot;</span><br>                          <span class="hljs-string">f&quot;作业周转时间：<span class="hljs-subst">&#123;job.ta_time&#125;</span>\t&quot;</span><br>                          <span class="hljs-string">f&quot;作业带权周转时间：<span class="hljs-subst">&#123;job.wta_time:<span class="hljs-number">.2</span>f&#125;</span>\t&quot;</span>)<br><br>        <span class="hljs-comment"># 检查是否有可以进入等待作业队列的作业</span><br>        <span class="hljs-keyword">for</span> job <span class="hljs-keyword">in</span> copy_queue:<br>            <span class="hljs-keyword">if</span> job.commit_time &lt;= clock <span class="hljs-keyword">and</span> job.status == <span class="hljs-string">&#x27;w&#x27;</span>:<br>                wait_queue.append(job)<br><br>        <span class="hljs-comment"># 等待队列不为空，检查是否有可以进入运行队列的作业</span><br>        <span class="hljs-keyword">if</span> wait_queue:<br>            <span class="hljs-comment"># 计算响应比</span><br>            <span class="hljs-keyword">for</span> job <span class="hljs-keyword">in</span> wait_queue:<br>                job.cul_rr(clock)<br>            JCB.__lt__ = getMethod(method)<br>            wait_queue.sort()<br>            <span class="hljs-comment"># 用于删除等待队列列表元素的列表</span><br>            del_queue = []<br>            <span class="hljs-keyword">for</span> job <span class="hljs-keyword">in</span> wait_queue:<br>                <span class="hljs-keyword">if</span> job.source &lt;= source <span class="hljs-keyword">and</span> job.status == <span class="hljs-string">&#x27;w&#x27;</span>:<br>                    run_queue.append(job)<br>                    del_queue.append(job)<br>                    job.start_time = clock  <span class="hljs-comment"># 作业开始时间为当前系统时间</span><br>                    job.status = <span class="hljs-string">&#x27;r&#x27;</span><br>                    source = source - job.source<br>            <span class="hljs-keyword">if</span> del_queue <span class="hljs-keyword">and</span> wait_queue:<br>                <span class="hljs-keyword">for</span> job <span class="hljs-keyword">in</span> del_queue:<br>                    wait_queue.remove(job)<br><br>        <span class="hljs-comment"># 跳出循环用</span><br>        <span class="hljs-keyword">if</span> num == queue_len:<br>            <span class="hljs-keyword">break</span><br><br>        <span class="hljs-comment"># 系统时钟自增</span><br>        clock = clock + <span class="hljs-number">1</span><br>    avg_ta_time = avg_ta_time / queue_len<br>    avg_wta_time = avg_wta_time / queue_len<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;平均周转时间：<span class="hljs-subst">&#123;avg_ta_time:<span class="hljs-number">.2</span>f&#125;</span>\t带权周转时间：<span class="hljs-subst">&#123;avg_wta_time:<span class="hljs-number">.2</span>f&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="其他函数">其他函数</h2><p>其实只有一个<code>input()</code>用来获取用户输入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">inputJCB</span>():<br>    <span class="hljs-string">&quot;&quot;&quot;初始化JCB队列&quot;&quot;&quot;</span><br>    JCB_queue = []<br>    src = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入系统资源数：&quot;</span>))<br>    JCB_num = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入作业数量：&quot;</span>))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(JCB_num):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前是第<span class="hljs-subst">&#123;i + <span class="hljs-number">1</span>&#125;</span>个作业；&quot;</span>)<br>        jn = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入作业名字：&quot;</span>)<br>        ct = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入作业提交时间：&quot;</span>))<br>        rt = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入作业运行时间：&quot;</span>))<br>        sc = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入作业所需资源：&quot;</span>))<br>        new_JCB = JCB(jn, ct, rt, sc)<br>        JCB_queue.append(new_JCB)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n&quot;</span>)<br>    <span class="hljs-comment"># 打印JCB队列</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(JCB_num):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;第<span class="hljs-subst">&#123;i + <span class="hljs-number">1</span>&#125;</span>个作业名字：<span class="hljs-subst">&#123;JCB_queue[i].job_name&#125;</span>\t&quot;</span><br>              <span class="hljs-string">f&quot;作业提交时间：<span class="hljs-subst">&#123;JCB_queue[i].commit_time&#125;</span>\t&quot;</span><br>              <span class="hljs-string">f&quot;作业所需运行时间：<span class="hljs-subst">&#123;JCB_queue[i].run_time&#125;</span>\t&quot;</span><br>              <span class="hljs-string">f&quot;作业所需资源数：<span class="hljs-subst">&#123;JCB_queue[i].source&#125;</span>&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;FCFS算法：&quot;</span>)<br>    simulator(JCB_queue, <span class="hljs-string">&quot;FCFS&quot;</span>, src)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;SJF算法：&quot;</span>)<br>    simulator(JCB_queue, <span class="hljs-string">&quot;SJF&quot;</span>, src)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;HRRF算法：&quot;</span>)<br>    simulator(JCB_queue, <span class="hljs-string">&quot;HRRF&quot;</span>, src)<br></code></pre></td></tr></table></figure><p>python测试代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    inputJCB()<br></code></pre></td></tr></table></figure><h1>运行结果</h1><p>暂时不贴结果，没找到一个好云图库放图，上传到github也不合适www<br>麻烦各位自己运行一下了</p><h1>结语</h1><p>日后补充<s>（兄啊一篇文章下来省略了多少啊）</s></p><hr>]]></content>
    
    
    <categories>
      
      <category>Learning Log</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>操作系统</tag>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Test my blog</title>
    <link href="/2022/04/12/Test-my-blog/"/>
    <url>/2022/04/12/Test-my-blog/</url>
    
    <content type="html"><![CDATA[<h1>这是第一篇博文，用于测试以及练习markdown语法</h1><h2 id="打两个-就是二级标题">打两个##就是二级标题</h2><h3 id="Markdown字体">Markdown字体</h3><p><em>斜体文本一个*</em><br><strong>粗体文本两个*</strong><br><em><strong>斜粗体文本三个*</strong></em></p><h3 id="分隔线">分隔线</h3><hr><h2 id="font-size-3-face-Microsoft-YaHei-用三个-或者三个-把文本围起来-上面一行下面一行-font-虽然但是为什么分割线里的文本默认挺大的（思考🤔（（这里我用-font-size-改了"><font size=3 face='Microsoft YaHei'>用三个-或者三个*把文本围起来(上面一行下面一行)</font><br>虽然但是为什么分割线里的文本默认挺大的（思考🤔（（这里我用&lt;font size&gt;改了</h2><h3 id="删除线">删除线</h3><p>两个波浪线括起来就能<s>删除</s>了</p><p><s>这样我就能乱说话乐！</s></p><p>为什么用空格不能换行啊！</p><h3 id="下划线">下划线</h3><p><u>直接用html的&lt;u&gt;标签</u></p><h3 id="脚注">脚注</h3><p>这里有一个脚注<a href="%E5%8A%A0VX%E8%AF%B7%E5%90%83KFC%E7%96%AF%E7%8B%82%E6%9C%A8%E6%9B%9C%E6%97%A5%E6%8D%8F">^<s>别点，要脸</s></a></p><h3 id="列表">列表</h3><ul><li>星号+空格+内容</li><li>或者</li><li>+号也行</li><li>-号也行</li><li>有序列表用序号</li></ul><ol><li>这是有序嵌套无序：<ul><li>我是无序</li></ul></li><li>我是有序</li></ol><h3 id="Markdown区块">Markdown区块</h3><blockquote><p>用&gt;加上一个空格再加上文本就好了</p><blockquote><p>区块嵌套就写多点&gt;</p><blockquote><ul><li>区块里边用列表也行</li></ul></blockquote></blockquote></blockquote><ul><li>反过来列表里用区块也行<blockquote><p>在最前边摁个tab就好啦</p></blockquote></li></ul><h3 id="Markdown-代码">Markdown 代码</h3><p>在一行里直接用`包起来就好啦 -&gt; <code>print()</code>函数<br>代码块就用三个`包起来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@login_required</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">topics</span>(<span class="hljs-params">request</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;显示所有的主题&quot;&quot;&quot;</span><br>    topics = Topic.objects.order_by(<span class="hljs-string">&#x27;data_added&#x27;</span>)<br>    context = &#123;<span class="hljs-string">&#x27;topics&#x27;</span>: topics&#125;<br>    <span class="hljs-keyword">return</span> render(request, <span class="hljs-string">&#x27;learning_logs/topics.html&#x27;</span>, context)<br></code></pre></td></tr></table></figure><h3 id="Markdown-链接">Markdown 链接</h3><p>休息一下，听首歌吧~ <a href="https://www.bilibili.com/video/BV1ty4y1y76V?share_source=copy_web"><s>神必链接</s></a></p><h3 id="Markdown-图片">Markdown 图片</h3><p>如图：<br><img src="https://pic1.zhimg.com/v2-e81ff8868ed8bde326ae6074eb8dab40_r.jpg" alt="野兽红茶"></p><h3 id="Markdown-表格">Markdown 表格</h3><p>用 | 来分隔不同单元格，用 - 来分隔表头和其他行</p><table><thead><tr><th style="text-align:left">114</th><th style="text-align:right">514</th><th style="text-align:center">1919810</th></tr></thead><tbody><tr><td style="text-align:left">哼</td><td style="text-align:right">哼  啊</td><td style="text-align:center">啊啊啊</td></tr></tbody></table><h3 id="数学公式">数学公式</h3><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>E</mi><mo>=</mo><mi>m</mi><msup><mi>c</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">E=mc^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8641em;"></span><span class="mord mathnormal">m</span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></p><hr><h2 id="堂堂完结">堂堂完结</h2><p>（<s>其实是想上床摆烂了</s></p><hr>]]></content>
    
    
    <categories>
      
      <category>Gossip</category>
      
    </categories>
    
    
    <tags>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
