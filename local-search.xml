<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C#笔记——继承和类和方法</title>
    <link href="/2023/11/04/CSharp-learning-10/"/>
    <url>/2023/11/04/CSharp-learning-10/</url>
    
    <content type="html"><![CDATA[<p>#类<br>##访问修饰符<br>访问修饰符包括：<code>private</code>、<code>public</code>、<code>protected</code>、<code>internal</code>、<code>protected internal</code>。</p><table><thead><tr><th style="text-align:center">修饰符</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">private</td><td style="text-align:center">只在类的内部可见</td></tr><tr><td style="text-align:center">internal</td><td style="text-align:center">对该程序集内所有类可见</td></tr><tr><td style="text-align:center">protected</td><td style="text-align:center">对所有继承该类的类可见</td></tr><tr><td style="text-align:center">internal protected</td><td style="text-align:center">对所有继承该类型或在该程序集内声明的类可访问</td></tr><tr><td style="text-align:center">public</td><td style="text-align:center">对任何类可访问</td></tr></tbody></table><p>##静态量<br>静态量由<code>static</code>修饰。静态字段被类的实例共享，所有实例都访问同一内存位置。因此，如果该内存位置的值被一个实例改变了，这种改变对所有的实例都可见。<br>访问静态成员有两种方式：</p><ul><li>使用类名，如：<code>Math.Sqrt(16)</code></li><li>在调用该成员的类中包含一个<code>using static</code>声明，如：<code>using static System.Math; Sqrt(16);</code></li></ul><p>##常量<br>常量由<code>const</code>修饰符修饰。它们对类的每个实例都是可见的，不需要类的实例也可访问，不能对其进行修改。但常量没有自己的存储位置，会在编译时被编译器替换，类似于 C 与 CPP 的<code>#define</code>宏定义。</p><p>##公共和私有构造函数，利用<code>this</code>调用其他构造函数<br>这其实是一个技巧。<br>第一种应用情况是：<code>public MyClass(int x) : this(x, &quot;Using Default String&quot;)</code>，在这里，单参数的构造函数调用了同一个类中具有两个参数的构造函数，并为第二个参数提供了一个默认值。<br>第二种情况是，一个类有好几个构造函数，并且它们都需要在对象构造的过程中执行一些公共的代码，那我们就可以把这些公共的代码提取出来作为一个私有构造函数，用于被其他构造函数调用，例如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br><span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> firstVar;<br><span class="hljs-keyword">readonly</span> <span class="hljs-built_in">double</span> secondVar;<br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> UserName;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> UserIdNumber;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">MyClass</span>()</span><br>&#123;<br>firstVar = <span class="hljs-number">20</span>;<br>secondVar = <span class="hljs-number">30.5</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyClass</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> firstName</span>) : <span class="hljs-title">this</span>()</span><br>&#123;<br>UserName = firstName;<br>UserIdNumber = <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyClass</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> idNumber</span>) : <span class="hljs-title">this</span>()</span><br>&#123;<br>UserName = <span class="hljs-string">&quot;Anonymous&quot;</span>;<br>UserIdNumber = idNumber;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>#继承<br>##使用基类的引用<br>如果有一个派生类对象的引用，就可以获取该对象基类部分的引用（使用类型转换运算符或<code>as</code>运算符把该引用转换为基类类型）。例如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BaseClass</span> &#123;&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DerivedClass</span> : <span class="hljs-title">BaseClass</span> &#123;&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Example</span><br>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>&#123;<br>DerivedClass d = <span class="hljs-keyword">new</span> DerivedClass();<br><span class="hljs-comment">// 类型转换运算符</span><br>BaseClass b1 = (BaseClass)d;<br><span class="hljs-comment">// as 运算符</span><br>BaseClass b2 = d <span class="hljs-keyword">as</span> BaseClass;  <span class="hljs-comment">// d is BaseClass ? (BaseClass)d : (BaseClass)null</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将派生类对象强制转换为基类对象的作用是产生的变量只能访问基类的成员（在被覆写方法中除外）。</p><p>##虚方法和覆写方法<br>虚方法可以使基类的引用访问提升至派生类内。在基类中，使用<code>virtual</code>修饰符修饰的方法为虚方法。在其派生类中，使用<code>override</code>修饰符修饰的方法为覆写方法。<br>当使用对象基类的引用去调用一个虚方法时，调用的是被标记为<code>override</code>的方法的最高派生的版本。<br>如果我们不想覆写方法，则可以使用<code>new</code>修饰符修饰方法。</p><p>##程序集间的引用<br>要从不同程序集中进行继承，需要添加对包含该基类的程序集的引用，可以在 Visual Studio 工程中的 References 节点中进行添加。注意这里的添加引用不是使用<code>using</code>指令。</p><p>##抽象类<br>抽象类是指设计为被继承的类。抽象类只能被用作其他类的基类。使用<code>abstract</code>修饰符声明抽象类。关于抽象类，要注意以下几点：</p><ul><li>不能创建抽象类的实例。</li><li>抽象类可以包含抽象成员或非抽象成员。</li><li>抽象类可以派生自另一个抽象类。</li><li>其派生类必须实现所有抽象成员，除非它自身也是个抽象类。<br>###抽象成员<br>抽象成员是指设计为被覆写的函数成员，并且只能在抽象类中声明。用<code>abstract</code>修饰符声明抽象成员。不能有实现代码块，用分号取代。必须被覆写。同样地，也是使用<code>override</code>对抽象成员进行覆写。</li></ul><p>##密封类<br>其实就是无法被继承的类。用<code>sealed</code>修饰符声明密封类。</p><p>##静态类<br>用<code>static</code>修饰符声明静态类。静态类中所有的成员都是静态的，用于存放不受实例数据影响的数据和函数（比如创建一个包含一组数学方法的计算类）。静态类是隐式密封的。</p><p>#方法<br>##方法签名<br>方法的签名包括：方法名，参数个数、类型、顺序，参数修饰符；不包括：方法的返回值。</p><p>##形参<br>形参是局部变量，它声明在方法的参数列表中，而不是在方法体中。例如：<code>public void PrintSum(int x, int y)</code>，其中<code>x</code>和<code>y</code>就是形参。</p><p>##实参<br>当代码调用一个方法时，形参的值必须在方法的代码开始执行之前初始化。用于初始化形参的表达式或变量称作实参（actual parameter， 有时也称 argument）。例如：<code>PrintSum(5, a)</code>，其中<code>5</code>和<code>a</code>就是实参。</p><p>##方法参数修饰符<br>###<code>ref</code>参数修饰符<br>用于声明引用参数。使用引用参数时，必须在方法的声明和调用中都使用<code>ref</code>修饰符。实参必须是变量，在用作实参前必须被赋值。<br>引用参数不会在栈上为形参分配内存，而是将形参的参数名作为实参变量的别名，指向相同的内存位置。</p><p>###<code>out</code>参数修饰符<br>用于声明输出参数。输出参数用于从方法体内把数据传出到调用代码。必须在方法的声明和调用中都使用修饰符。实参必须是变量，不需要提前赋值。<br>在方法内部，给输出参数赋值之后才能读取它。<strong>这意味着参数的初始值是无关的，而且没有必要在方法调用之前为实参赋值。</strong></p><p>###<code>in</code>参数修饰符<br>用于声明输入参数。输入参数用于从调用代码把数据传到方法体内，其传递的是<strong>只读引用</strong>。可以不在方法的调用中使用修饰符。实参必须是变量。</p><p>###<code>param</code>参数修饰符<br>用于声明参数数组。一个参数列表中最多只能有一个参数数组，且必须位于最后。只能声明一维数组类型。</p><hr>]]></content>
    
    
    <categories>
      
      <category>Learning Log</category>
      
      <category>CSharp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
      <tag>类</tag>
      
      <tag>方法</tag>
      
      <tag>继承</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初级排序介绍</title>
    <link href="/2023/10/29/algorithm-elementary-sorts/"/>
    <url>/2023/10/29/algorithm-elementary-sorts/</url>
    
    <content type="html"><![CDATA[<h1>排序算法类模板</h1><p>该类定义一些排序算法会用到的辅助方法，例如：<code>less</code>和<code>exch</code>方法。前者对元素进行比较，后者交换元素位置。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Sorts</span><br>&#123;<br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 待实现的排序方法</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;a&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Sort</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">T[] a</span>) <span class="hljs-keyword">where</span> T : IComparable&lt;T&gt;</span> &#123; &#125;<br><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 对元素进行比较，若 a1 小于 a2 则返回 true</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;a1&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;a2&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span><span class="hljs-doctag">&lt;/returns&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">Less</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">T a1, T a2</span>) <span class="hljs-keyword">where</span> T : IComparable&lt;T&gt;</span><br>&#123;<br><span class="hljs-keyword">return</span> a1.CompareTo(a2) &lt; <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 交换两个元素的位置</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;a&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;index1&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;index2&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Exch</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">T[] a, <span class="hljs-built_in">int</span> index1, <span class="hljs-built_in">int</span> index2</span>)</span><br>&#123;<br><span class="hljs-keyword">var</span> temp = a[index1];<br>a[index1] = a[index2];<br>a[index2] = temp;<br>&#125;<br><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 打印数据</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;a&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Show</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">T[] a</span>)</span><br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; a.Length; i++)<br>&#123;<br>Console.Write(a[i] + <span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br>Console.WriteLine();<br>&#125;<br><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 检查数组是否有序</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;a&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span><span class="hljs-doctag">&lt;/returns&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">IsSoreted</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">T[] a</span>) <span class="hljs-keyword">where</span> T : IComparable&lt;T&gt;</span><br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= a.Length; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (Less(a[i], a[i - <span class="hljs-number">1</span>]))<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1>选择排序</h1><p>选择排序的基本思想：首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素进行交换。如此反复，直到将整个数组排序。<br>选择排序是<strong>稳定</strong>的。<br><img src="https://z1.ax1x.com/2023/11/04/piQSw0x.jpg" alt="选择排序"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Selection</span> : <span class="hljs-title">Sorts</span><br>&#123;<br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 重写方法，实现选择排序</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;a&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Sort</span>(<span class="hljs-params">IComparable[] a</span>)</span><br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i &lt; a.Length;i++)<br>&#123;   <span class="hljs-comment">// 将 a[i] 和 a[i + 1]...a[a.Length]中的最小元素进行交换</span><br><span class="hljs-built_in">int</span> min = i;  <span class="hljs-comment">// 最小元素的索引</span><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = i; j &lt; a.Length - <span class="hljs-number">1</span>;j++)<br>&#123;<br><span class="hljs-keyword">if</span> (Less(a[j], a[min]))<br>&#123;<br>min = j;<br>&#125;<br>&#125;<br>Exch(a, i, min);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1>插入排序</h1><p>插入排序的基本思想：从数组的第二个数开始，将它插入到其左边数组中的合适位置，保持左边的数组一直是有序状态，直至数组遍历完成，整个数组都为有序状态。<br>插入排序是稳定的。<br><img src="https://z1.ax1x.com/2023/11/04/piQS076.jpg" alt="插入排序"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Insertion</span> : <span class="hljs-title">Sorts</span><br>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Sort</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">T[] a</span>)</span><br>&#123;   <span class="hljs-comment">// 将 a[i] 插入到 a[i - 1]，a[i - 2]，a[i - 3]...中</span><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; a.Length; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = i; j &gt; <span class="hljs-number">0</span> &amp;&amp; Less(a[j], a[j - <span class="hljs-number">1</span>]); j--)<br>&#123;<br>Exch(a, j, j - <span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>要对插入排序进行改进，只需要在内循环中将较大的元素向右移动，而不是每次都进行交换，就能减少一半的数组访问次数，改进后的代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">InsertionImproved</span> : <span class="hljs-title">Sorts</span><br>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Sort</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">T[] a</span>)</span><br>&#123;<br><span class="hljs-built_in">int</span> n = a.Length;<br><br><span class="hljs-comment">// 找哨兵</span><br><span class="hljs-built_in">int</span> min = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (Less(a[i], a[min]))<br>&#123;<br>min = i;<br>&#125;<br>&#125;<br>Exch(a, min, <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 减少了一半交换</span><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i++)<br>&#123;<br>T temp = a[i];<br><span class="hljs-built_in">int</span> j = i;<br><span class="hljs-keyword">while</span> (Less(temp, a[j - <span class="hljs-number">1</span>]))<br>&#123;<br>a[j] = a[j - <span class="hljs-number">1</span>];<br>j--;<br>&#125;<br>a[j] = temp;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1>希尔排序</h1><p>希尔排序其实就是改进过的插入排序，因为插入排序只交换相邻的元素，如果一个很小的元素排在很后面，就需要进行很多次移动，所以希尔排序的思想就是先对数组进行局部排序，交换不相邻的元素，保持数组局部有序，最后再进行一次插入排序来完成排序。</p><blockquote><p>希尔排序的思想是使数组中任意间隔为 h 的元素都是有序的。这样的数组被称为 h 有序数组。换句话说，一个 h 有序数组就是 h 个互相独立的有序子数组编织在一起组成的一个数组。在进行排序时，如果 h 很大，我们就能将元素移动到很远的地方，为实现更小的 h 有序创造方便。<br><img src="https://z1.ax1x.com/2023/11/04/piQSDAK.jpg" alt="希尔排序"></p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Shell</span> : <span class="hljs-title">Sorts</span><br>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Sort</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">T[] a</span>)</span><br>&#123;<br><span class="hljs-built_in">int</span> n = a.Length;<br><span class="hljs-built_in">int</span> h = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (h &lt; n / <span class="hljs-number">3</span>) &#123; h = h * <span class="hljs-number">3</span> + <span class="hljs-number">1</span>; &#125;  <span class="hljs-comment">// 1, 4, 13, 40, 121, 364, 1093, ...</span><br><span class="hljs-keyword">while</span> (h &gt;= <span class="hljs-number">1</span>)<br>&#123;   <span class="hljs-comment">// 将数组变为 h 有序</span><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = h; i &lt; n; i++)<br>&#123;   <span class="hljs-comment">// 将 a[i] 插入到 a[i - h]，a[i - 2*h]，a[i - 3*h]...中</span><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = i; j &gt;= h &amp;&amp; Less(a[j], a[j - h]); j -= h)<br>&#123;<br>Exch(a, j, j - h);<br>&#125;<br>&#125;<br>h /= <span class="hljs-number">3</span>;<br>&#125;<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1>编写的测试方法</h1><p>算法模板类提供了一个<code>IsSorted</code>方法来判断数组是否有序，可以用<code>Debug.Assert</code>来进行测试，不过我这里没用。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ElementarySortsTest</span>()</span><br>&#123;<br>Selection selection = <span class="hljs-keyword">new</span> Selection();<br>Insertion insertion = <span class="hljs-keyword">new</span> Insertion();<br>InsertionImproved insertionImproved = <span class="hljs-keyword">new</span> InsertionImproved();<br>Shell shell = <span class="hljs-keyword">new</span> Shell();<br><br><span class="hljs-built_in">int</span>[] intList = &#123; <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">9</span> &#125;;<br><span class="hljs-built_in">char</span>[] charList = <span class="hljs-string">&quot;SHELLSORTEXAMPLE&quot;</span>.ToCharArray();<br><br>Sorts s = shell;  <span class="hljs-comment">// 想要测试某一个排序算法，直接更改此处即可。</span><br><br><span class="hljs-keyword">var</span> a = charList;<br>s.Show(a);<br>s.Sort(a);<br>s.Show(a);<br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>Solution</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
      <tag>Python</tag>
      
      <tag>选择排序</tag>
      
      <tag>插入排序</tag>
      
      <tag>希尔排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Union-Find 算法（并查集）</title>
    <link href="/2023/10/29/algorithm-union-find/"/>
    <url>/2023/10/29/algorithm-union-find/</url>
    
    <content type="html"><![CDATA[<h1>问题描述</h1><p>Union-Find 算法用于确定网络中任意给定的两个触点是否相通。这样说可能不好理解，所以让我们通过一个简单的问题来了解一下它。<br>看到下面这张图，图上有九个点，现在任意给出两个点，我们需要快速判断这两个点是否相连，或者说这两个点是否相通，有什么好办法吗？<br><img src="https://z1.ax1x.com/2023/10/29/pime7dI.jpg" alt=""><br>为了更好理解这个问题，我们可以将九个点转化为 0-8 这九个数字，并把其当成一个数组来看待，然后再假设问题的输入就是一些元组，如<code>(1, 4)</code>，就代表 1 和 4 之间是连通的。<br>就以上面图为参考，我们想要知道相邻的两个点是否连通是很容易的，比如 0 和 1；但是，如果想要知道 0 和 4 是否是连通的，该用什么方法呢？对输入进行<code>dfs</code>或是<code>bfs</code>吗？那太复杂了，毕竟我们不需要给出两点间的详细路径，只需要知道两者是否连通，没必要浪费资源，所以我们需要换种思路。</p><h1>Union-Find 算法的 API</h1><p>为此，我们需要先为这个算法设计一些 API，这些操作既可以处理输入，也能够解决问题。下面给出<code>UnionFind</code>类的基本框架：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span><br>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span>[]? _id;<br><span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> _count;<br><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 以整数标识（0 到 N-1）初始化 N 个触点</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;N&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UnionFind</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> N</span>)</span><br>&#123;<br>_count = N;<br>_id = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[N];<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>&#123;<br>_id[i] = i;<br>&#125;<br>&#125;<br><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 连通分量的数量</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span><span class="hljs-doctag">&lt;/returns&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Count</span>()</span><br>&#123;<br><span class="hljs-keyword">return</span> _count;<br>&#125;<br><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 如果 p 和 q 存在于同一个（连通）分量中则返回 true</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;p&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;q&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span><span class="hljs-doctag">&lt;/returns&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">Connected</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> p, <span class="hljs-built_in">int</span> q</span>)</span><br>&#123;<br><span class="hljs-keyword">return</span> Find(p) == Find(q);<br>&#125;<br><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> p 所在的分量的标识符</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;p&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span><span class="hljs-doctag">&lt;/returns&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Find</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> p</span>)</span><br>&#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotImplementedException();<br>&#125;<br><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 在 p 和 q 之间添加一条连接</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;p&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;q&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Union</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> p, <span class="hljs-built_in">int</span> q</span>)</span><br>&#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotImplementedException();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到框架中有两个方法还未实现，这两个方法其实正是这个算法的关键，而我们接下来要干的事就是实现这两个方法。</p><h1>Union 和 Find 方法的实现</h1><h2 id="quick-find-算法">quick-find 算法</h2><p>该算法的思路就是保证当且仅当<code>id[p]</code>等于<code>id[q]</code>时<code>p</code>和<code>q</code>是连通的，换句话说，在同一个连通分量里的所有触点在<code>id[]</code>中的值必须全部相同。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">uint</span> <span class="hljs-title">Find</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> p</span>)</span><br>&#123;<br><span class="hljs-comment">// quick-find</span><br><span class="hljs-keyword">return</span> _id![p];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Union</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> p, <span class="hljs-built_in">uint</span> q</span>)</span><br>&#123;<br><span class="hljs-comment">// quick-find</span><br><span class="hljs-comment">// 将 p 和 q 归并到相同的连通分量中</span><br><span class="hljs-built_in">uint</span> pId = Find(p);<br><span class="hljs-built_in">uint</span> qId = Find(q);<br><span class="hljs-comment">// 如果 p 和 q 已经在相同分量中则不需要采取任何行动</span><br><span class="hljs-keyword">if</span> (pId == qId) &#123; <span class="hljs-keyword">return</span>; &#125;<br><span class="hljs-comment">// 将 p 的分量重命名为 q 的分量</span><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">uint</span> i = <span class="hljs-number">0</span>; i &lt; _id!.Length; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (_id[i] == pId) &#123; _id[i] = qId; &#125;<br>&#125;<br>_count--;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="quick-union-算法">quick-union 算法</h2><p>这个算法的思路其实就是通过构造<strong>森林</strong>来确定连通分量和两个触点是否相连。下面的图将有助于理解该算法：<br><img src="https://z1.ax1x.com/2023/11/04/piQSshD.jpg" alt=""><br>也就是说，我们调用<code>Find</code>方法的话，应该沿着其找到其所在分量的标识符，也就是根触点。而调用<code>Union</code>方法对<code>p</code>和<code>q</code>进行归并的话，就利用<code>Find</code>方法找到两个触点的根触点，若不同，更改其中一个根触点的标识符为另一个根触点即可。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">uint</span> <span class="hljs-title">Find</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> p</span>)</span><br>&#123;<br><span class="hljs-comment">// quick-union</span><br><span class="hljs-keyword">while</span> (p != _id![p])<br>&#123;<br>p = _id[p];<br>&#125;<br><span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Union</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> p, <span class="hljs-built_in">uint</span> q</span>)</span><br>&#123;<br><span class="hljs-comment">// quick union</span><br><span class="hljs-comment">// 找到两个触点的根触点</span><br><span class="hljs-built_in">uint</span> pRoot = Find(p);<br><span class="hljs-built_in">uint</span> qRoot = Find(q);<br><span class="hljs-comment">// 如果 p 和 q 的根触点相同，说明在同一棵树下（换句话说，在相同分量中）</span><br><span class="hljs-keyword">if</span> (pRoot == qRoot) &#123; <span class="hljs-keyword">return</span>; &#125;<br><span class="hljs-comment">// 否则合并两棵树</span><br>_id![pRoot] = qRoot;<br>_count--;<br>&#125;<br></code></pre></td></tr></table></figure><h1>Union 和 Find 方法的优化</h1><h2 id="加权quick-union">加权quick-union</h2><p>当然，普通的<code>quick-union</code>算法是不会判断树的大小的，所以可能会出现一颗大树归并到小树上，或者出现更糟糕的情况：0链接到1，1链接到2，如此下去。<br>那么，为了改进我们的<code>union</code>方法，我们现在需要记录一下每棵树的大小，并且总是将小树连接到大树上。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">WeightedUnionFind</span><br>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-built_in">uint</span>[] _id;  <span class="hljs-comment">// 以触点作为索引</span><br><span class="hljs-keyword">private</span> <span class="hljs-built_in">uint</span> _count;  <span class="hljs-comment">// 连通分量的数量</span><br><span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span>[] _size;  <span class="hljs-comment">// 各个根节点所对应的分量的大小</span><br><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 以整数标识（0 到 N-1）初始化 N 个触点</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;N&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WeightedUnionFind</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> N</span>)</span><br>&#123;<br>_count = N;<br>_id = <span class="hljs-keyword">new</span> <span class="hljs-built_in">uint</span>[N];<br>_size = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[N];<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">uint</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>&#123;<br>_id[i] = i;<br>_size[i] = <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 连通分量的数量</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span><span class="hljs-doctag">&lt;/returns&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">uint</span> <span class="hljs-title">Count</span>()</span><br>&#123;<br><span class="hljs-keyword">return</span> _count;<br>&#125;<br><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 如果 p 和 q 存在于同一个（连通）分量中则返回 true</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;p&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;q&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span><span class="hljs-doctag">&lt;/returns&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">Connected</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> p, <span class="hljs-built_in">uint</span> q</span>)</span><br>&#123;<br><span class="hljs-keyword">return</span> Find(p) == Find(q);<br>&#125;<br><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> p 所在的分量的标识符</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;p&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span><span class="hljs-doctag">&lt;/returns&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">uint</span> <span class="hljs-title">Find</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> p</span>)</span><br>&#123;<br><span class="hljs-comment">// quick-union</span><br><span class="hljs-keyword">while</span> (p != _id[p])<br>&#123;<br>p = _id[p];<br>&#125;<br><span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 在 p 和 q 之间添加一条连接</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;p&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;q&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Union</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> p, <span class="hljs-built_in">uint</span> q</span>)</span><br>&#123;<br><span class="hljs-comment">// quick union</span><br><span class="hljs-comment">// 找到两个触点的根触点</span><br><span class="hljs-built_in">uint</span> pRoot = Find(p);<br><span class="hljs-built_in">uint</span> qRoot = Find(q);<br><span class="hljs-comment">// 如果 p 和 q 的根触点相同，说明在同一棵树下（换句话说，在相同分量中）</span><br><span class="hljs-keyword">if</span> (pRoot == qRoot) &#123; <span class="hljs-keyword">return</span>; &#125;<br><span class="hljs-comment">// 否则将小树合并到大树上</span><br><span class="hljs-keyword">if</span> (_size[pRoot] &lt; _size[qRoot])<br>&#123;<br>_id[p] = q;<br>_size[qRoot] += _size[pRoot];<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>_id[q] = p;<br>_size[pRoot] += _size[qRoot];<br>&#125;<br>_count--;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="路径压缩">路径压缩</h2><p>理想情况下，我们希望每个节点都直接链接到它的根节点上。为了实现这种理想情况，只需要为<code>Find()</code>添加一个循环，将在路径上遇到的所有节点都直接链接到根节点。这样我们所得到的结果是几乎完全扁平化的树。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">WeightedPathCompressUnionFind</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">uint</span>[] _id;  <span class="hljs-comment">// 以触点作为索引</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">uint</span> _count;  <span class="hljs-comment">// 连通分量的数量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span>[] _size;  <span class="hljs-comment">// 各个根节点所对应的分量的大小</span><br><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 以整数标识（0 到 N-1）初始化 N 个触点</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;N&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WeightedPathCompressUnionFind</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> N</span>)</span><br>    &#123;<br>        _count = N;<br>        _id = <span class="hljs-keyword">new</span> <span class="hljs-built_in">uint</span>[N];<br>        _size = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[N];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">uint</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>        &#123;<br>            _id[i] = i;<br>            _size[i] = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 连通分量的数量</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span><span class="hljs-doctag">&lt;/returns&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">uint</span> <span class="hljs-title">Count</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> _count;<br>    &#125;<br><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 如果 p 和 q 存在于同一个（连通）分量中则返回 true</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;p&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;q&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span><span class="hljs-doctag">&lt;/returns&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">Connected</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> p, <span class="hljs-built_in">uint</span> q</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> Find(p) == Find(q);<br>    &#125;<br><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> p 所在的分量的标识符</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;p&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span><span class="hljs-doctag">&lt;/returns&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">uint</span> <span class="hljs-title">Find</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> p</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 找到根节点</span><br>        <span class="hljs-built_in">uint</span> root = p;<br>        <span class="hljs-keyword">while</span> (root != _id[root])<br>        &#123;<br>            root = _id[root];<br>        &#125;<br>        <span class="hljs-comment">// 路径上所有节点直接链接到根节点上</span><br>        <span class="hljs-keyword">while</span> (p != root)<br>        &#123;<br>            <span class="hljs-built_in">uint</span> temp = _id[p];<br>            _id[p] = root;<br>            p = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 在 p 和 q 之间添加一条连接</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;p&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;q&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Union</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> p, <span class="hljs-built_in">uint</span> q</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 找到两个触点的根触点</span><br>        <span class="hljs-built_in">uint</span> pRoot = Find(p);<br>        <span class="hljs-built_in">uint</span> qRoot = Find(q);<br>        <span class="hljs-comment">// 如果 p 和 q 的根触点相同，说明在同一棵树下（换句话说，在相同分量中）</span><br>        <span class="hljs-keyword">if</span> (pRoot == qRoot) &#123; <span class="hljs-keyword">return</span>; &#125;<br>        <span class="hljs-comment">// 否则将小树合并到大树上</span><br>        <span class="hljs-keyword">if</span> (_size[pRoot] &lt; _size[qRoot])<br>        &#123;<br>            _id[p] = q;<br>            _size[qRoot] += _size[pRoot];<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            _id[q] = p;<br>            _size[pRoot] += _size[qRoot];<br>        &#125;<br>        _count--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1>编写的测试方法</h1><p>本来想说实现一下读取文件的，但是搁置了（逃</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UnionFindTest</span>()</span><br>&#123;<br>    <span class="hljs-comment">// 读取触点数量并初始化 N 个分量</span><br>    <span class="hljs-built_in">uint</span> N = <span class="hljs-number">9</span>;<br>    <span class="hljs-keyword">try</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Please enter a number(e.g: 9):&quot;</span>);<br>        N = UInt32.Parse(Console.ReadLine());<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (FormatException)<br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Please enter a correct number.&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    UnionFind unionFind = <span class="hljs-keyword">new</span> UnionFind(N);<br><br>    <span class="hljs-comment">// 建立触点间的连接</span><br>    Console.WriteLine(<span class="hljs-string">&quot;Please enter p and q(e.g: 1 4):&quot;</span>);<br>    <span class="hljs-built_in">string</span>? numbers = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">string</span>.IsNullOrEmpty(numbers = Console.ReadLine()))<br>    &#123;<br>        <span class="hljs-keyword">try</span><br>        &#123;<br>            <span class="hljs-built_in">uint</span>[] tmp = Array.ConvertAll(numbers.Split(<span class="hljs-string">&quot; &quot;</span>), <span class="hljs-built_in">uint</span>.Parse);<br>            <span class="hljs-keyword">if</span> (tmp.Length != <span class="hljs-number">2</span> || tmp[<span class="hljs-number">0</span>] &gt;= N || tmp[<span class="hljs-number">1</span>] &gt;= N)<br>            &#123;<br>                Console.WriteLine(<span class="hljs-string">&quot;Please check your input.(Wrong format)&quot;</span>);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-built_in">uint</span> p = tmp[<span class="hljs-number">0</span>];<br>            <span class="hljs-built_in">uint</span> q = tmp[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (unionFind.Connected(p, q)) &#123; <span class="hljs-keyword">continue</span>; &#125;<br>            unionFind.Union(p, q);<br>        &#125;<br>        <span class="hljs-keyword">catch</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;Please check your input.(Not a num)&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 打印连通分量数</span><br>    Console.WriteLine(unionFind.Count() + <span class="hljs-string">&quot; components.&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>Solution</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#笔记——使用ASP.NET和Entity Framework Core</title>
    <link href="/2023/10/19/CSharp-learning-9/"/>
    <url>/2023/10/19/CSharp-learning-9/</url>
    
    <content type="html"><![CDATA[<h1>环境配置</h1><p>首先检查下自己电脑装没装 .NET，建议用 vs 当懒狗，直接全装了。在终端中输入命令：<code>dotnet --list-sdks</code>，如果没列出任何版本或者未找到命令就是没装，赶紧给我装啊！.jpg<br>至于项目文件，全都是文档中有提到的，看看文档就找到了！</p><h1>项目基本结构</h1><p>属于十分经典的 API 项目结构啊：</p><ul><li>Models: 保存实体模型，如 POCO 或者说 DTO。</li><li>Services: 业务逻辑层。</li><li>Controllers: 控制器层，负责搜集参数、参数校验、调用 Service（服务）等。</li><li>Data: 保存数据库相关，如<code>DbContext</code>。</li></ul><h1>使用 <a href="http://ASP.NET">ASP.NET</a> Core 控制器创建 Web API</h1><h2 id="创建-Web-API-项目">创建 Web API 项目</h2><h3 id="Visual-Studio">Visual Studio</h3><p>新建项目中搜索： <a href="http://ASP.NET">ASP.NET</a> Core Web API ，然后创建即可。</p><h3 id="Visual-Studio-Code">Visual Studio Code</h3><p>在终端窗口中进入对应文件夹，运行命令：<code>dotnet new webapi -f net7.0</code>。该命令根据当前文件夹名称命名 C# 项目文件。</p><h2 id="接口测试工具">接口测试工具</h2><p>我们可以用 Postman 来测试接口，也可以用 .NET HTTP REPL 工具来测试接口。前者直接官网下载即可，后者则在终端运行该命令：<code>dotnet tool install -g Microsoft.dotnet-httprepl</code>。</p><h3 id="NET-HTTP-REPL-食用方法">.NET HTTP REPL 食用方法</h3><p>通过以下命令连接：<code>httprepl https://localhost:&#123;port&#125;</code>；或者，在<code>Httprepl</code>运行时随时运行以下命令：<code>connect https://localhost:&#123;port&#125;</code>。</p><div class="note note-success">            <p>如果<code>Httprepl</code>工具发出“找不到 OpenAPI 说明”的警告，最有可能的原因是开发证书不受信任。执行命令：<code>dotnet dev-certs https --trust</code>配置系统以信任开发证书。</p>          </div><p>浏览可用的 endpoint：<code>ls</code><br>进入某一个 endpoint：<code>cd endpointName</code><br>发出请求：<code>get</code>、<code>post</code>、<code>put</code>、<code>patch</code>、<code>delete</code>，若带参数，加在后面即可，如：<code>get 5</code>。需要 body，那就用<code>-c</code>然后加在后边，如：<code>post -c &quot;&#123;&quot;id&quot;: 3, &quot;name&quot;: &quot;MyTest&quot;, &quot;isFree&quot;: false&#125;&quot;</code>和<code>put 3 -c &quot;&#123;&quot;id&quot;: 3, &quot;name&quot;: &quot;MyTest&quot;, &quot;isFree&quot;: false&#125;&quot;</code><br>结束当前<code>Httprepl</code>会话：<code>exit</code></p><h2 id="创建-ASP-NET-Core-Web-API-控制器">创建 <a href="http://ASP.NET">ASP.NET</a> Core Web API 控制器</h2><p>控制器应该放在 Controllers 文件夹下，操作通过路由被公开为 HTTP endpoint。命名格式为：<code>XxxController</code>，其实就是加一个<code>Controller</code>后缀。我们的<code>https://localhost:&#123;port&#125;/xxx</code>的各种 HTTP 请求将执行<code>XxxController</code>类下的对应方法。</p><div class="note note-info">            <p>注意<code>Web API</code>的控制器的基类应该是<code>ControllerBase</code>而不是<code>Controller</code>，后者派生自前者并且添加了对视图的支持，用来处理网页而不是<code>Web API</code>请求。</p>          </div><p>我们还需要将两个重要属性应用到我们创建的控制器上，这两个属性分别是：<code>[ApiController]</code>和<code>[Route(&quot;[controller]&quot;)]</code>。<br><code>[ApiController]</code>启用固定行为，使生成 Web API 更加容易。如果要在多个控制器上应用该属性，一种方法是创建通过<code>[ApiController]</code>属性批注的自定义基控制器类，比如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#">[<span class="hljs-meta">ApiController</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyControllerBase</span> : <span class="hljs-title">ControllerBase</span> &#123;&#125;<br><br>[<span class="hljs-meta">Route(<span class="hljs-string">&quot;[controller]&quot;</span>)</span><br><span class="hljs-meta">public class MyController : MyControllerBase</span><br><span class="hljs-meta">&#123;</span><br><span class="hljs-meta">...</span><br><span class="hljs-meta">&#125;</span><br></code></pre></td></tr></table></figure><p>又或者是将该属性应用到程序集，如修改<code>Program.cs</code>：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> Microsoft.AspNetCore.Mvc;<br>[<span class="hljs-meta">assembly: ApiController</span>]<br><span class="hljs-keyword">var</span> builder = WebApplication.CreateBuilder(args);<br>...<br></code></pre></td></tr></table></figure><p>不过需要的是，如果某个控制器应用了<code>[ApiController]</code>属性，那么同时也要对该控制器应用<code>[Route]</code>属性，该属性说明见下面。<br><code>[Route(&quot;[controller]&quot;)]</code>属性定义路由模式。<code>[controller]</code>令牌（参数）替换为控制器的名称（不区分大小写，无 Controller 后缀）。举两个例子：</p><ol><li><code>[Route(&quot;[controller]&quot;)]</code>应用到<code>AnimalController</code>类上，则该控制器处理对<code>https://localhost:&#123;port&#125;/animal</code>的请求。</li><li><code>[Route(&quot;api/[controller]&quot;)]</code>应用到<code>AnimalController</code>类上，则该控制器处理对<code>https://localhost:&#123;port&#125;/api/animal</code>的请求。</li></ol><h2 id="在控制器中实现-REST-谓词">在控制器中实现 REST 谓词</h2><h3 id="Get">Get</h3><p>不带参数的实现：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#">[<span class="hljs-meta">HttpGet</span>]<br><span class="hljs-function"><span class="hljs-keyword">public</span> ActionResult&lt;TEntity&gt; <span class="hljs-title">GetMethodName</span>()</span><br>&#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>带参数的实现（注意<code>int</code>只是举个例子，实际是什么类型就填什么）：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#">[<span class="hljs-meta">HttpGet(<span class="hljs-string">&quot;&#123;id&#125;&quot;</span>)</span>]<br><span class="hljs-function"><span class="hljs-keyword">public</span> ActionResult&lt;TEntity&gt; <span class="hljs-title">GetMethodName</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> id</span>)</span><br>&#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="POST">POST</h3><p>将项作为参数传递入方法时，<a href="http://ASP.NET">ASP.NET</a> Core 会自动发送到 endpoint 的任何应用程序/JSON 转换为填充的 .NET TEntity 对象。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#">[<span class="hljs-meta">HttpPost</span>]<br><span class="hljs-function"><span class="hljs-keyword">public</span> IActionResult <span class="hljs-title">CreateMethodName</span>(<span class="hljs-params">TEntity entity</span>)</span><br>&#123;<br><span class="hljs-comment">// This code will save the entity and return a result</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="PUT">PUT</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#">[<span class="hljs-meta">HttpPut(<span class="hljs-string">&quot;&#123;id&#125;&quot;</span>)</span>]<br><span class="hljs-function"><span class="hljs-keyword">public</span> IActionResult <span class="hljs-title">Update</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> id, TEntity entity</span>)</span><br>&#123;<br><span class="hljs-comment">// This code will update the entity and return a result</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="PATCH">PATCH</h3><p>基本包貌似不提供这个词操作，详情见：<a href="https://learn.microsoft.com/zh-cn/aspnet/core/web-api/jsonpatch?view=aspnetcore-7.0">ASP.NET Core Web API 中的 JSON 修补程序</a></p><h3 id="DELETE">DELETE</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#">[<span class="hljs-meta">HttpDelete(<span class="hljs-string">&quot;&#123;id&#125;&quot;</span>)</span>]<br><span class="hljs-function"><span class="hljs-keyword">public</span> IActionResult <span class="hljs-title">DeleteMethodName</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> id</span>)</span><br>&#123;<br><span class="hljs-comment">// This code will delete the entity and return a result</span><br>&#125;<br></code></pre></td></tr></table></figure><h1>Swashbuckle 和 <a href="http://ASP.NET">ASP.NET</a> Core 入门</h1><h2 id="如何为我的-Web-API-应用添加-Swashbuckle">如何为我的 Web API 应用添加 Swashbuckle</h2><h3 id="包安装">包安装</h3><h4 id="Visual-Studio-2">Visual Studio</h4><p>用 NuGet 可以快速管理当前项目的各个包，将“包源”设置为“<a href="http://nuget.org">nuget.org</a>”，然后直接在搜索框中搜索“Swashbuckle.AspNetCore”，安装最新的“Swashbuckle.AspNetCore”包即可。下面的步骤根据 Visual Studio 2022 编写：</p><ol><li>“工具” -&gt; “NuGet 包管理器” -&gt; “管理解决方案的 NuGet 包”，然后会打开一个窗口。</li><li>选择浏览，然后直接在搜索框中搜索“Swashbuckle.AspNetCore”，安装最新的“Swashbuckle.AspNetCore”包即可。</li></ol><h4 id="Visual-Studio-Code-2">Visual Studio Code</h4><p>从“终端”窗口中运行命令（注意在项目文件夹下）：<code>dotnet add Xxx.csproj package Swashbuckle.AspNetCore -v 6.5.0</code>。命令中的<code>Xxx</code>换成自己的项目文件名。根据自己的需要选择版本号，编写该文章时候的最新稳定版为<code>6.5.0</code>。</p><h3 id="添加并配置-Swagger-中间件">添加并配置 Swagger 中间件</h3><p>添加以下代码到<code>Program.cs</code>中：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#">builder.Services.AddSwaggerGen();<br><br><span class="hljs-keyword">if</span> (app.Environment.IsDevelopment())<br>&#123;<br>    app.UseSwagger();<br>    app.UseSwaggerUI();<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-info">            <p>注意到<code>app.Environment.IsDevelopment()</code>，这句代码表明：仅当将当前环境设置为“开发”时，才会添加 Swagger 中间件。</p>          </div><div class="note note-warning">            <p>如果使用目录及 IIS 或反向代理，请使用<code>./</code>前缀将 Swagger 终结点设置为相对路径。例如<code>./swagger/v1/swagger.json</code>。</p>          </div><h2 id="自定义和扩展">自定义和扩展</h2><h3 id="API-信息和说明">API 信息和说明</h3><p>传递给<code>AddSwaggerGen</code>方法的配置操作会添加诸如作者、许可证和说明的信息。例如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c#">builder.Services.AddSwaggerGen(options =&gt;<br>&#123;<br>    options.SwaggerDoc(<span class="hljs-string">&quot;v1&quot;</span>, <span class="hljs-keyword">new</span> OpenApiInfo<br>    &#123;<br>        Version = <span class="hljs-string">&quot;v1&quot;</span>,<br>        Description = <span class="hljs-string">&quot;Pizza API&quot;</span>,<br>        TermsOfService = <span class="hljs-keyword">new</span> Uri(<span class="hljs-string">&quot;https://example.com/terms&quot;</span>),<br>        Contact = <span class="hljs-keyword">new</span> OpenApiContact<br>        &#123;<br>            Name = <span class="hljs-string">&quot;MaP1e-G&#x27;s Blog&quot;</span>,<br>            Url = <span class="hljs-keyword">new</span> Uri(<span class="hljs-string">&quot;https://map1e-g.github.io/about&quot;</span>)<br>        &#125;,<br>        License = <span class="hljs-keyword">new</span> OpenApiLicense<br>        &#123;<br>            Name = <span class="hljs-string">&quot;Example License&quot;</span>,<br>            Url = <span class="hljs-keyword">new</span> Uri(<span class="hljs-string">&quot;https://example.com/license&quot;</span>)<br>        &#125;<br>    &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>启动来看看效果：<img src="https://z1.ax1x.com/2023/10/26/piZPH6P.jpg" alt="Swagger Information"></p><h3 id="XML-注释">XML 注释</h3><p>要启用 XML 注释功能，就将<code>GenerateDocumentationFile</code>添加到<code>.csproj</code>（C#项目）文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">PropertyGroup</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">GenerateDocumentationFile</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">GenerateDocumentationFile</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">PropertyGroup</span>&gt;</span><br></code></pre></td></tr></table></figure><p>一些 Swagger 功能无需使用 XML文档文件即可起作用，但是对于大多数功能（即方法摘要以及参数说明和响应代码说明），必须使用 XML 文件。所以可以添加以下代码，通过反射生成与 Web API 项目相匹配的 XML 文件名：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c#">builder.Services.AddSwaggerGen(options =&gt;<br>&#123;<br><span class="hljs-comment">// other options</span><br>...<br><span class="hljs-comment">// using System.Reflection</span><br><span class="hljs-keyword">var</span> xmlFilename = <span class="hljs-string">$&quot;<span class="hljs-subst">&#123;Assembly.GetExecutingAssembly().GetName().Name&#125;</span>.xml&quot;</span>;<br>options.IncludeXmlComments(Path.Combine(AppContext.BaseDirectory, xmlFilename));<br>&#125;<br>);<br></code></pre></td></tr></table></figure><p><code>AppContext.BaseDirectory</code>属性用于构造 XML 文件的路径。</p><h4 id="summary-元素"><summary>元素</h4><p>启用 XML 注释后，三斜杠注释将被添加到 Swagger UI 中，比如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 查找所有Pizza</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span><span class="hljs-doctag">&lt;/returns&gt;</span></span><br>[<span class="hljs-meta">HttpGet</span>]<br><span class="hljs-function"><span class="hljs-keyword">public</span> IEnumerable&lt;Pizza&gt; <span class="hljs-title">GetAll</span>()</span><br>&#123;<br><span class="hljs-keyword">return</span> _service.GetAll();<br>&#125;<br></code></pre></td></tr></table></figure><p>看看效果：<img src="https://z1.ax1x.com/2023/10/26/piZFHZ8.jpg" alt="Swagger XML "></p><h4 id="remarks-元素"><remarks>元素</h4><p>还可以添加<code>&lt;remarks&gt;</code>元素来提供额外说明，例如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 创建一个新Pizza</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;newPizza&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span><span class="hljs-doctag">&lt;/returns&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;remarks&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 示例：</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> </span><br><span class="hljs-comment"><span class="hljs-doctag">///</span>     POST /Pizza</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span>     &#123;</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span>       &quot;id&quot;: 1,</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span>       &quot;name&quot;: &quot;XxxPizza&quot;,</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span>       &quot;sauce&quot;: &#123; </span><br><span class="hljs-comment"><span class="hljs-doctag">///</span>           &quot;id&quot;: 1,</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span>           &quot;name&quot;: &quot;XxxSauce&quot;,</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span>           &quot;isVegan&quot;: false</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span>       &#125;,</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span>       &quot;topping&quot;: [</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span>         &#123;</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span>           &quot;id&quot;:1,</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span>           &quot;name&quot;: &quot;XxxTopping&quot;,</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span>           &quot;calories&quot;: 100</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span>         &#125;</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span>       ]</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span>     &#125;</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span>     </span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/remarks&gt;</span></span><br>[<span class="hljs-meta">HttpPost</span>]<br><span class="hljs-function"><span class="hljs-keyword">public</span> IActionResult <span class="hljs-title">Create</span>(<span class="hljs-params">Pizza newPizza</span>)</span><br>&#123;<br>    <span class="hljs-keyword">var</span> pizza = _service.Create(newPizza);<br>    <span class="hljs-keyword">return</span> CreatedAtAction(<span class="hljs-keyword">nameof</span>(GetById), <span class="hljs-keyword">new</span> &#123; id = pizza!.Id &#125;, pizza);<br>&#125;<br></code></pre></td></tr></table></figure><p>看看效果：<img src="https://z1.ax1x.com/2023/10/26/piZEPC4.jpg" alt="Swagger XML "></p><h4 id="response-元素"><response>元素</h4><p>我们还可以在 XML 注释中表示错误代码和响应类型，比如在<code>Create</code>方法的 XML 注释中，加入如下注释：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;response code=&quot;201&quot;&gt;</span>Returns the newly created item<span class="hljs-doctag">&lt;/response&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;response code=&quot;400&quot;&gt;</span>If the item is null<span class="hljs-doctag">&lt;/response&gt;</span></span><br></code></pre></td></tr></table></figure><p>我们还需要为<code>Craete</code>方法添加如下的额外的属性：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">[<span class="hljs-meta">ProducesResponseType(StatusCodes.Status201Created)</span>]<br>[<span class="hljs-meta">ProducesResponseType(StatusCodes.Status400BadRequest)</span>]<br></code></pre></td></tr></table></figure><p>来看看效果：<img src="https://z1.ax1x.com/2023/10/27/piZbJdx.jpg" alt="Post"><br>同样的，我们为<code>Get</code>方法也添加下 XML 注释：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 根据输入的id来查找对应的Pizza</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;id&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span><span class="hljs-doctag">&lt;/returns&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;response code=&quot;200&quot;&gt;</span>返回一个美味的 Pizza<span class="hljs-doctag">&lt;/response&gt;</span></span><br>[<span class="hljs-meta">HttpGet(<span class="hljs-string">&quot;&#123;id&#125;&quot;</span>)</span>]<br>[<span class="hljs-meta">ProducesResponseType(typeof(Pizza), StatusCodes.Status200OK)</span>]<br><span class="hljs-function"><span class="hljs-keyword">public</span> ActionResult&lt;Pizza&gt; <span class="hljs-title">GetById</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> id</span>)</span><br>&#123;<br><span class="hljs-keyword">var</span> pizza = _service.GetById(id);<br><br><span class="hljs-keyword">if</span> (pizza <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span>)<br>&#123;<br><span class="hljs-keyword">return</span> pizza;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">return</span> NotFound();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后看看效果:<img src="https://z1.ax1x.com/2023/10/27/piZbYo6.jpg" alt="GetById"></p><h4 id="param-元素和-returns-元素"><param>元素和<returns>元素</h4><p>就如同他们的中文意思一般，为这两个元素写 XML 注释，其实就是给对应参数和返回类型写注释。下面为<code>Get</code>方法额外添加一点注释：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;id&quot;&gt;</span>Pizza的唯一指定ID<span class="hljs-doctag">&lt;/param&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span>返回一个美味的 Pizza<span class="hljs-doctag">&lt;/returns&gt;</span></span><br></code></pre></td></tr></table></figure><p>看看效果：<img src="https://z1.ax1x.com/2023/10/27/piZqV6H.jpg" alt="Swagger XML "></p><h1>使用 Entity Framework Core 持久保存和检索关系数据</h1><h2 id="什么是-EF-Core？">什么是 EF Core？</h2><p>“Entity Framework Core (EF Core) 是对象-关系映射程序 (ORM)。 ORM 在代码和数据库中实现的域模型之间提供一个层。 EF Core 是一种数据访问 API，允许使用 .NET 普通旧公共运行时语言 (CLR) 对象 (POCO) 和强类型语言集成查询 (LINQ) 语法与数据库进行交互。<br>在 EF Core 中，数据库可在 .NET POCO 后面抽象化。 EF Core 处理与基础数据库的直接交互。 使用此 API 时，可以花更少的时间来与数据库之间转换请求以及编写 SQL，从而让你有更多时间专注于重要的业务逻辑。”<br>在 EF Core 中，有一个很重要的类，必须了解和掌握，那就是：<code>DbContext</code>（数据库上下文）类。<br><code>DbContext</code>是表示工作单元的特殊类。<code>DbContext</code>提供的方法可用于配置选项、连接字符串、日志记录以及用于将域映射到数据库的模型。<br>派生自<code>DbContext</code>的类：</p><ul><li>表示与数据库之间的<strong>活动会话</strong></li><li>保存和查询实体的实例</li><li>包括<code>DbSet&lt;T&gt;</code>类型的属性，其表示数据库中的表。</li></ul><h2 id="包安装-2">包安装</h2><p>要使用 EF Core 进行开发，我们依然要安装对应包。前面已经提到过 VS 可以轻松通过 Nuget 包管理器 来进行安装所以这里不提了。主要是通过命令行的安装：</p><ol><li>首先运行：<code>dotnet add package Microsoft.EntityFrameworkCore.Sqlite</code>，因为项目用的是<code>sqlite</code>所以这里最后面是<code>Sqlite</code>，你也可以相应地换成<code>MySQL</code>或是其他数据库。</li><li>然后运行：<code>dotnet add package Microsoft.EntityFrameworkCore.Design</code>，该命令添加 EF Core 工具所需的包。</li><li>最后运行：<code>dotnet tool install --global dotnet-ef</code>，该命令将安装<code>dotnet ef</code>，用于创建迁移和基架的工具。如需更新，则运行<code>dotnet tool update --global dotnet-ef</code>。</li></ol><h2 id="现有模型迁移至数据库">现有模型迁移至数据库</h2><h3 id="搭建模型和-DbContext-的基架">搭建模型和 DbContext 的基架</h3><p>在<code>Models</code>文件夹下搭建我们需要的模型，这些模型在迁移之后就会成为数据库中的各个表，比如例子中的<code>Pizza</code>、<code>Topping</code>、<code>Sauce</code>模型，迁移后就是<code>Pizza</code>、<code>Topping</code>、<code>Sauce</code>三张表。<br>模型搭建完毕后，我们还需要在<code>Data</code>文件夹下添加并配置<code>DbContext</code>实现。<code>DbContext</code>是一个网关，可以通过该网关与数据库进行交互。<br>在本例中，我们添加了一个继承自<code>DbContext</code>类的<code>PizzaContext</code>类，用于跟数据库进行交互。代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> Microsoft.EntityFrameworkCore;<br><span class="hljs-keyword">using</span> ContosoPizza.Models;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">ContosoPizza.Data</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PizzaContext</span> : <span class="hljs-title">DbContext</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PizzaContext</span> (<span class="hljs-params">DbContextOptions&lt;PizzaContext&gt; options</span>)</span><br><span class="hljs-function">        : <span class="hljs-title">base</span>(<span class="hljs-params">options</span>)</span><br>    &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> DbSet&lt;Pizza&gt; Pizzas =&gt; Set&lt;Pizza&gt;();<br>    <span class="hljs-keyword">public</span> DbSet&lt;Topping&gt; Toppings =&gt; Set&lt;Topping&gt;();<br>    <span class="hljs-keyword">public</span> DbSet&lt;Sauce&gt; Sauces =&gt; Set&lt;Sauce&gt;();<br>&#125;<br></code></pre></td></tr></table></figure><p>可以发现，如果没其他要求的话，我们只需要将模型的<code>DbSet</code>集合添加至类中即可，<code>DbSet&lt;T&gt;</code>属性也对应于要在数据库中创建的表。<br>然后，设置数据源，在<code>Program.cs</code>中，添加该代码：<code>builder.Services.AddSqlite&lt;XxxContext&gt;(&quot;Data Source=Xxx.db&quot;)</code>。自己在自己的应用中实现时，将<code>XxxContext</code>和<code>Xxx.db</code>替换掉就好了，例子中这两处地方分别为<code>PizzaContext</code>和<code>ContosoPizza.db</code>。</p><h3 id="创建并运行迁移">创建并运行迁移</h3><p>运行该命令来创建迁移：<code>dotnet ef migrations add MigrationName --context XxxContext</code>。<br>在实际使用中，将命令中的<code>MigrationName</code>替换为自己想要创建的迁移的名字，迁移将被命名为该名字；<code>XxxContext</code>则替换为对应的类的名字，如<code>PizzaContext</code>。<br>运行完该命令后，项目中将会生成<code>Migrations</code>文件夹，在该文件夹下包含<code>&lt;timestamp&gt;_MigrationName.cs</code>文件。<br>创建完迁移后，还需要运行该命令：<code>dotnet ef database update --context XxxContext</code>，该命令将会应用迁移。</p><div class="note note-info">            <p>EF Core 约定通过推断开发者的意图来缩短开发时间。 例如，名为<code>Id</code>或<code>&lt;entity name&gt;Id</code>的属性被推断为生成的表的主键。如果选择不采用命名约定，则该属性必须使用<code>[Key]</code>特性进行批注或配置为<code>DbContext</code>的<code>OnModelCreating</code>方法中的键。</p>          </div><h3 id="更改模型和更新数据库架构">更改模型和更新数据库架构</h3><p>某些时候我们可能需要对之前的模型进行修改，然后再把修改同步至数据库。要执行这样的操作，和上一节“创建并运行迁移”的操作是一样的，即先创建迁移，再应用迁移。不过请注意进行版本控制和备份以防数据丢失。</p><h2 id="与数据交互">与数据交互</h2><p>编写业务代码逻辑一般都是在 Service 层上，所以这里默认是编写在对应的<code>Service</code>类上的。<br>要与对应的数据库进行交互，我们就需要有对应的<code>Context</code>类的字段，如：<code>private readonly PizzaContext _context</code>，并在构造函数中将参数分配给该字段。<br>要访问数据库中的某张表，获取对应的<code>DbSet</code>属性即可，如：<code>_context.Pizzas</code>。这里再放几个链式调用中常见的方法：</p><ul><li><code>AsNoTracking</code>扩展方法指示 EF Core 禁用更改跟踪。如果某个操作是只读的，该方法可以优化性能。</li><li><code>ToList</code>，转换成列表，懂得都懂。</li><li><code>Include</code>扩展方法采用 lambda 表达式来指定将某些导航属性（在例子中是<code>Topping</code>和<code>Sauce</code>，这两个都是 模型/数据库中的表，而且包含在<code>Pizza</code>模型中）通过使用预先加载来包含在结果中，如果不使用此表达式， EF Core 会为这些属性返回<code>null</code>。（我觉得可以理解为如果是引用属性那就需要用这个表达式来将其包含在结果集中）</li><li><code>SingleOrDefault</code>方法返回与 lambda 表达式匹配的结果。如果没有匹配的结果，则返回<code>null</code>；如果有多个匹配的结果，将会引发异常。</li><li><code>Find</code>是按主键查询记录的优化方法。</li><li><code>Remove</code>方法根据传入的对象来移除 EF Core 对象图中的对应实体。<br>在执行修改操作后，我们还需要执行<code>_context.SaveChanges()</code>来将操作结果应用到数据库。</li></ul><h2 id="现有数据库逆向工程至模型">现有数据库逆向工程至模型</h2><p>如果我们已经有了数据库，想要根据现有数据库来生成基架代码，有没有什么方便又减少工作量的办法呢？<br>答案是有的。运行命令：<code>dotnet ef dbcontext scaffold &quot;Data Source=Xxx/Xxx.db&quot; Microsoft.EntityFrameworkCore.Sqlite --context-dir Data --output-dir Models</code>。该命令将使用提供的连接字符串（<code>&quot;Data Source=Xxx.db&quot;</code>）搭建<code>DbContext</code>类和模型类基架；指定使用<code>Microsoft.EntityFrameworkCore.Sqlite</code>数据库提供程序；<code>--context-dir</code>指定<code>DbContext</code>类的目录，<code>--output-dir</code>指定模型（<code>Model</code>）类的目录。<br>创建完后别忘了检查一遍，如果有需要也可以对<code>DbContext</code>和模型类进行修改。</p><div class="note note-success">            <p>如果数据库发生更改，可以生成新的基架文件。生成的文件每次都会被覆盖，<strong>但会创建为<code>partial</code>类</strong>，因此你可以在自己的单独文件中使用自定义属性和行为来扩展它们。</p>          </div><p>最后，别忘了在<code>Program.cs</code>中将新生成的<code>DbContext</code>类注册到依赖项注入系统：<code>builder.Services.AddSqlite&lt;XxxContext&gt;(&quot;Data Source=Xxx.db&quot;);</code></p><h1><a href="http://ASP.NET">ASP.NET</a> Core Web API 中控制器操作的返回类型</h1><h2 id="IActionResult-类型">IActionResult 类型</h2><p>当操作中可能有多个<code>ActionResult</code>返回类型时，适合使用<code>IActionResult</code>返回类型。<code>ActionResult</code>类型表示多中 HTTP 状态代码。派生自<code>ActionResult</code>的任何非抽象类都限定为有效的返回类型，例如：<code>BadRequestResult</code>(400)、<code>NotFoundResult</code>(404)、<code>OkObjectResult</code>(200)。或者，可以使用<code>ControllerBase</code>类中的便利方法从操作返回<code>ActionResult</code>类型，例如：<code>return BadRequest();</code>，是<code>return new BadRequestResult();</code>的简写形式。</p><h3 id="同步操作">同步操作</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#">[<span class="hljs-meta">HttpGet(<span class="hljs-string">&quot;&#123;id&#125;&quot;</span>)</span>]<br>[<span class="hljs-meta">ProducesResponseType(StatusCodes.Status200OK, Type = typeof(Product))</span>]<br>[<span class="hljs-meta">ProducesResponseType(StatusCodes.Status404NotFound)</span>]<br><span class="hljs-function"><span class="hljs-keyword">public</span> IActionResult <span class="hljs-title">GetById_IActionResult</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> id</span>)</span><br>&#123;<br>    <span class="hljs-keyword">var</span> product = _productContext.Products.Find(id);<br>    <span class="hljs-keyword">return</span> product == <span class="hljs-literal">null</span> ? NotFound() : Ok(product);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="异步操作">异步操作</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c#">[<span class="hljs-meta">HttpPost()</span>]<br>[<span class="hljs-meta">Consumes(MediaTypeNames.Application.Json)</span>]<br>[<span class="hljs-meta">ProducesResponseType(StatusCodes.Status201Created)</span>]<br>[<span class="hljs-meta">ProducesResponseType(StatusCodes.Status400BadRequest)</span>]<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task&lt;IActionResult&gt; <span class="hljs-title">CreateAsync_IActionResult</span>(<span class="hljs-params">Product product</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (product.Description.Contains(<span class="hljs-string">&quot;XYZ Widget&quot;</span>))<br>    &#123;<br>        <span class="hljs-keyword">return</span> BadRequest();<br>    &#125;<br><br>    _productContext.Products.Add(product);<br>    <span class="hljs-keyword">await</span> _productContext.SaveChangesAsync();<br><br>    <span class="hljs-keyword">return</span> CreatedAtAction(<span class="hljs-keyword">nameof</span>(GetById_IActionResult), <span class="hljs-keyword">new</span> &#123; id = product.Id &#125;, product);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ActionResult-T-类型">ActionResult<T> 类型</h2><p><code>ActionResult&lt;T&gt;</code>支持返回从<code>ActionResult</code>派生的类型或返回特定类型。</p><h3 id="同步操作-2">同步操作</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#">[<span class="hljs-meta">HttpGet(<span class="hljs-string">&quot;&#123;id&#125;&quot;</span>)</span>]<br>[<span class="hljs-meta">ProducesResponseType(StatusCodes.Status200OK)</span>]<br>[<span class="hljs-meta">ProducesResponseType(StatusCodes.Status404NotFound)</span>]<br><span class="hljs-function"><span class="hljs-keyword">public</span> ActionResult&lt;Product&gt; <span class="hljs-title">GetById_ActionResultOfT</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> id</span>)</span><br>&#123;<br>    <span class="hljs-keyword">var</span> product = _productContext.Products.Find(id);<br>    <span class="hljs-keyword">return</span> product == <span class="hljs-literal">null</span> ? NotFound() : product;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="异步操作-2">异步操作</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c#">[<span class="hljs-meta">HttpPost()</span>]<br>[<span class="hljs-meta">Consumes(MediaTypeNames.Application.Json)</span>]<br>[<span class="hljs-meta">ProducesResponseType(StatusCodes.Status201Created)</span>]<br>[<span class="hljs-meta">ProducesResponseType(StatusCodes.Status400BadRequest)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task&lt;ActionResult&lt;Product&gt;&gt; CreateAsync_ActionResultOfT(Product product)<br>&#123;<br>    <span class="hljs-keyword">if</span> (product.Description.Contains(<span class="hljs-string">&quot;XYZ Widget&quot;</span>))<br>    &#123;<br>        <span class="hljs-keyword">return</span> BadRequest();<br>    &#125;<br><br>    _productContext.Products.Add(product);<br>    <span class="hljs-keyword">await</span> _productContext.SaveChangesAsync();<br><br>    <span class="hljs-keyword">return</span> CreatedAtAction(<span class="hljs-keyword">nameof</span>(GetById_ActionResultOfT), <span class="hljs-keyword">new</span> &#123; id = product.Id &#125;, product);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ActionResult-T-与-IActionResult">ActionResult<T> 与 IActionResult</h2><p>对比一下上面几部分代码，就可以发现，<code>IActionResult</code>返回的是<code>Ok(Entity)</code>，把实体类放入<code>OkObjectResult</code>类中；而<code>ActionResult&lt;T&gt;</code>则是直接返回实体类。</p><hr>]]></content>
    
    
    <categories>
      
      <category>Learning Log</category>
      
      <category>CSharp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
      <tag>ASP.NET</tag>
      
      <tag>EF CORE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity学习笔记-2</title>
    <link href="/2023/09/23/unity-learning-2/"/>
    <url>/2023/09/23/unity-learning-2/</url>
    
    <content type="html"><![CDATA[<h1>编辑器的一些设置</h1><h2 id="Scene窗口下的Pivot和Center">Scene窗口下的Pivot和Center</h2><p>Center（中心）：据网上说是由Unity计算出来的模型的中心。<br>Pivot（轴心/锚点）：建模本身的中心，也就是这个资源先前（或者说建模时？）就设置好的中心。</p><h2 id="Scene-View设置">Scene View设置</h2><p><code>Edit</code> -&gt; <code>Preferences</code> -&gt; <code>Scene View</code>，看到其中的<code>Create Objects at Origin</code>选项，建议启用。鼠标悬停在此选项上可以看到详细说明。<br>启用后，当我们创建新的<code>objects</code>时，会将<code>objects</code>生成于<code>(0, 0, 0)</code>坐标上（也就是<code>Transform</code>的<code>Position</code>属性上的<code>x</code>、<code>y</code>、<code>z</code>都为0）。</p><h2 id="Main-Camera设置">Main Camera设置</h2><p>我们实际在游戏中看到的画面，就是<code>Main Camera</code>能够看到的画面。如果画面大小不是你所期待的大小，可以在<code>Hierarchy</code>窗口中点击<code>Main Camera</code>，然后在<code>Inspector</code>窗口中修改其<code>Projection</code>属性下的<code>Size</code>的值。</p><h1>素材导入和整理</h1><h2 id="素材导入">素材导入</h2><p>美术素材记得分好类，分好文件夹，这样结构层次分明好看容易找。然后可以新建一个整体的名字叫<code>Art Assets</code>的文件夹，把所有分好类后的美术资源放进这个文件夹中，然后将<code>Art Assets</code>文件夹拖入<code>Project</code>窗口中，放在<code>Assets</code>目录下，就能完成美术素材的导入了。</p><h2 id="素材处理">素材处理</h2><h3 id="像素游戏的美术素材的处理示范">像素游戏的美术素材的处理示范</h3><p>比如我们导入的素材中，有一个是我们的游戏背景，名为<code>Background</code>，其文件格式是<code>.png</code>，直接在<code>Project</code>窗口里边点击它，这个时候<code>Inspector</code>视窗中就会出现素材的各项属性。<br>需要关注的属性有：<code>Pixels Per Unit</code>、<code>Filter Mode</code>和<code>Compression</code>：</p><ul><li><code>Pixels Per Unit</code>，即每单元像素。我们在<code>Scene</code>窗口下看到的每一个小方格就是一个单元，而这个选项就是每个格子可以显示多少像素单位。我们的美术素材在绘制时其实就是按照一定比例绘制的，比如16*16，而这个数字其实就是我们需要在这里填上去的数字了。</li><li><code>Filter Mode</code>，即过滤模式。当我们将小图片放大的时候，它可以用一些临近点去采取像素补充。在像素游戏中一般选择<code>Point(no filter)</code>，也就是没有过滤器。</li><li><code>Compression</code>，即压缩。我们不需要对图片进行压缩，所以直接使用<code>None</code>就好。</li></ul><h3 id="图集切割">图集切割</h3><p>我们导入的人物素材是一个图集，也就是一张图里包含了人物的各种状态（动作），要使用这些素材，就需要先对图集进行切割，将他们区分开来。<br>在<code>Project</code>窗口中选择图集，然后在<code>Inspector</code>窗口中找到<code>Sprite Editor</code>并点击，可以看到如下窗口：<img src="" alt=""><br>左上角的<code>slice</code>选项可以选择切片方法，这里不使用自动切片是因为中心点难以确定，会导致后续动画制作的麻烦。这里可以选择<code>Grid By Cell Count</code>，然后数一下一行有几个人，一列有几个人，然后分别填入<code>C</code>和<code>R</code>中就好了。图中的<code>C</code>和<code>R</code>分别为8和11。<br>还有另外一点，在<code>slice</code>选项中还有个<code>Pivot</code>选项，也就是确定切片的轴心，这里可以选择<code>Center</code>，也可以选择<code>Bottom</code>，如果选择<code>Bottom</code>就会以脚底为中心，这样贴近地图的时候方便计算。</p><h3 id="场景切割">场景切割</h3><p>接下来来处理我们的场景素材。在素材中找到<code>Tiles</code>并打开它的<code>Sprite Editor</code>，不同于人物素材，我们使用<code>Grid By Cell Size</code>进行切割，直接用16*16大小的格子将素材进行切割，效果如图所示：<img src="" alt=""></p><div class="note note-warning">            <p>这里要注意切割的时候<code>Pivot</code>选择<code>Center</code>！否则在绘制场景的时候会发现格子对不上！</p>          </div><h2 id="场景绘制">场景绘制</h2><p>场景绘制一般都是使用unity内置的工具，<code>Windows</code> -&gt; <code>2D</code> -&gt; <code>Tile Palette</code>，打开我们的“瓦片调色盘”。在当前项目初次使用这个工具，我们需要创建新的<code>Palette</code>（调色盘），以及新的<code>Tilemap</code>（瓦片地图），可以看到窗口上也显示出<code>No Valid Palette</code>和<code>No Valid Target</code>，这时候就需要我们<code>Create New Tile Palette</code>和<code>Create New Tilemap</code>。根据提示进行创建即可（瓦片地图看下面）。这里教程中保存的路径为：<code>Assets/Tilemap/Palettes</code>。<br>调色盘创建完毕后，直接把切割好的场景素材拖拽到<code>Tile Palette</code>窗口中即可，这个时候unity会问我们需要将切割好的<code>Tiles</code>（瓦片）保存到哪，教程中保存在<code>Assets/Tilemap/Tiles</code>中。<br>最后一步创建我们的<code>Tilemap</code>，切换到<code>Hierarchy</code>窗口，<code>+</code> -&gt; <code>2D Object</code> -&gt; <code>Tilemap</code>，选择<code>Rectangular</code>并创建，然后切换回<code>Tile Palette</code>窗口，就会发现最上方切换成了我们刚创建好的<code>Tilemap</code>对象。<br>至此，我们就可以从<code>Tile Palette</code>中框选一定的单元，然后在<code>Scene</code>中进行绘制了。</p><h1>叠层</h1><p>在进行场景绘制的时候，我们发现人物的图层在场景的图层的下方，场景把人物挡住了；要让人物处于场景的上方，这个时候就需要用到叠层了。</p><h2 id="Layer（层）">Layer（层）</h2><p>在<code>Hierarchy</code>窗口中，选中一个<code>GameObject</code>（比如选择我们的人物），然后在<code>Inspector</code>窗口中，可以看到它的<code>Renderer</code>组件中有<code>Additional Settings</code>选项，这个选项里面就包含了我们需要用到的<code>Sorting Layer</code>和<code>Order in Layer</code>属性。<br>前者是这个<code>GameObject</code>所处于的层级，后者则是这个<code>GameObject</code>在其所属层级中的“优先级”，优先级越高（数字越大），则该<code>GameObject</code>在当前层级越优先显示（处于更上方）。<br>创建图层如下图所示，注意在下图中处于下方的图层会遮挡处于上方的图层：<br><img src="" alt="图层创建"><br>当然，要分多少个图层、怎么分配图层等，这种东西看自己就好，比如在麦扣老师的视频中，创建了 Back 、Middle 和 Front 三个图层，然后创建了 7 张<code>Tilemap</code>，其中 Platform 处于 Middle 图层，三张 Back 瓦片地图就处于 Back 图层，但是优先级不同，同样的，三张 Front 瓦片地图处于 Front 图层但优先级不同。<br>该如何去绘制场景，可以直接看素材给出的例子：<br><img src="https://img.itch.zone/aW1hZ2UvMzk3MDM0LzEwNDE2ODc1LmdpZg==/original/%2Fv41b3.gif" alt="场景参考"></p><ul><li>其实就是绘画里的图层的概念（</li></ul><h1>瓦片</h1><p>我们可以创建一些特殊的瓦片来帮助我们快速地绘制地图，比如有规则瓦片，就可以根据我们为其设定的规则从而自动选择相应的瓦片进行填充绘制。<br>可以将我们自定义的瓦片也同样地放在<code>Assets/Tilemap/Tiles</code>文件夹中，并根据瓦片的不同类型进行命名，如： Rule Tiles（有规则瓦片） 和 Animated Tile（动态瓦片）。</p><h2 id="有规则瓦片">有规则瓦片</h2><p>要创建有规则瓦片，右键对应文件夹：<code>Create</code> -&gt; <code>2D</code> -&gt; <code>Tiles</code> -&gt; <code>Rule Tile</code><br>上面也已经说过了，这个规则瓦片能够根据我们设定的规则从而自行选择相应的瓦片进行填充。</p><h2 id="动态瓦片">动态瓦片</h2><p>要创建动态瓦片，右键对应文件夹：<code>Create</code> -&gt; <code>2D</code> -&gt; <code>Tiles</code> -&gt; <code>Animated Tile</code><br>如果我们想要一些能够动态变化的瓦片，就应该选择动态瓦片。我们可以为这个瓦片设置动画的张数，这个瓦片就会在运行时在这几张设定的瓦片之间来回切换，达到一个动画的效果。</p><hr>]]></content>
    
    
    <categories>
      
      <category>Learning Log</category>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
      <tag>Unity</tag>
      
      <tag>素材</tag>
      
      <tag>场景</tag>
      
      <tag>叠层</tag>
      
      <tag>瓦片</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#笔记——序列化</title>
    <link href="/2023/09/23/CSharp-learning-8/"/>
    <url>/2023/09/23/CSharp-learning-8/</url>
    
    <content type="html"><![CDATA[<h1>.NET中的序列化</h1><p>序列化是将对象状态转换为可保持或可传输的形式的过程（比如对象转换为 JSON 格式的输出）。反序列化则是将流转换为对象（比如将 JSON 格式的输入转换为一个对象）。</p><h2 id="JSON序列化">JSON序列化</h2><p>在 .NET 中我们可以使用<code>System.Text.Json</code>命名空间向/从 JavaScript 对象表示法（JSON）进行序列化和反序列化。</p><h3 id="将-NET-对象编写为-JSON（序列化）">将 .NET 对象编写为 JSON（序列化）</h3><h4 id="使用JsonSerializer-Serialize方法直接序列化为字符串">使用<code>JsonSerializer.Serialize</code>方法直接序列化为字符串</h4><p><code>JsonSerializer.Serialize</code>方法可以直接将对象序列化为 JSON 字符串：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">namespace</span> <span class="hljs-title">Learning1</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">enum</span> Gender<br>    &#123;<br>        male,<br>        female<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PersonalInformation</span><br>    &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span>? Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>        <span class="hljs-keyword">public</span> Gender Sex &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SerializeLearning</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>        &#123;<br>            <span class="hljs-keyword">var</span> personalInformation = <span class="hljs-keyword">new</span> PersonalInformation<br>            &#123;<br>                Name = <span class="hljs-string">&quot;MaP1e&quot;</span>,<br>                Age = <span class="hljs-number">18</span>,<br>                Sex = Gender.male,<br>            &#125;;<br><br>            <span class="hljs-built_in">string</span> jsonString = JsonSerializer.Serialize(personalInformation);<br><br>            Console.WriteLine(jsonString);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="创建额外的-JSON-文件">创建额外的 JSON 文件</h4><p>如果需要创建 JSON 文件，加上几句就好：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">string</span> fileName = <span class="hljs-string">&quot;PersonalInformation.json&quot;</span>;<br>File.WriteAllText(fileName, jsonString);<br></code></pre></td></tr></table></figure><p>当然，我们也可以使用异步代码来创建 JSON 文件：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">string</span> fileName = <span class="hljs-string">&quot;PersonalInformation.json&quot;</span>;<br><span class="hljs-keyword">using</span> FileStream createStream = File.Create(fileName);<br><span class="hljs-keyword">await</span> JsonSerializer.SerializeAsync(createStream, personalInformation);<br><span class="hljs-keyword">await</span> createStream.DisposeAsync();<br></code></pre></td></tr></table></figure><ul><li>还记得<code>using</code>语句的作用吗？它能够确保发生异常时程序也能够释放可释放实例。<br>既然我们创建了 JSON 文件，那我们就不需要打印<code>jsonString</code>了，可以直接读取文件的内容并将其打印出来，看看创建的 JSON 文件里的内容是否正确：<code>Console.WriteLine(File.ReadAllText(filename));</code></li></ul><h4 id="使序列化后的-JSON-字符串具有可读性（美化序列化输出）">使序列化后的 JSON 字符串具有可读性（美化序列化输出）</h4><p>但是我们会发现直接转换的 JSON 字符串输出差强人意，不具有易读性，如果对象中还存在着集合属性或者用户定义类型的类的话，就更难读了。为了使输出的 JSON 具有可读性，可以使用<code>JsonSerializerOptions</code>来为序列化进行自定义（客制）：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">var</span> options = <span class="hljs-keyword">new</span> JsonSerializerOptions &#123; WriteIndented = <span class="hljs-literal">true</span> &#125;;<br>srting jsonString = JsonSerializer.Serialize(personalInformation, options);<br></code></pre></td></tr></table></figure><p>这将会产生如下输出：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;Name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;MaP1e&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;Age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">18</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;Sex&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="序列化需要注意的一些点">序列化需要注意的一些点</h4><p>参照文档以获得更详细的信息：<a href="https://learn.microsoft.com/zh-cn/dotnet/standard/serialization/system-text-json/how-to?pivots=dotnet-8-0#serialization-behavior">序列化行为</a></p><h3 id="将-JSON-读取为-NET-对象（反序列化）">将 JSON 读取为 .NET 对象（反序列化）</h3><h4 id="使用JsonSerializer-Deserialize方法对-JSON-字符串进行反序列化">使用<code>JsonSerializer.Deserialize</code>方法对 JSON 字符串进行反序列化</h4><p>要注意的是，反序列化会默认忽略类中未表示的任何 JSON 属性；而如果类型上的任何属性是必需（<code>required</code>修饰符或<code>[JsonRequired]</code>）的，但不存在于 JSON 字符串中，反序列化将失败。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">namespace</span> <span class="hljs-title">Learning1</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">WeatherForecast</span><br>    &#123;<br>        <span class="hljs-keyword">public</span> DateTimeOffset Date &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> TemperatureCelsius &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span>? Summary &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DeserializeLearning</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>        &#123;<br>            <span class="hljs-built_in">string</span> jsonString =<br><span class="hljs-string">@&quot;&#123;</span><br><span class="hljs-string">  &quot;&quot;Date&quot;&quot;: &quot;&quot;2019-08-01T00:00:00-07:00&quot;&quot;,</span><br><span class="hljs-string">  &quot;&quot;TemperatureCelsius&quot;&quot;: 25,</span><br><span class="hljs-string">  &quot;&quot;Summary&quot;&quot;: &quot;&quot;Hot&quot;&quot;,</span><br><span class="hljs-string">  &quot;&quot;DatesAvailable&quot;&quot;: [</span><br><span class="hljs-string">    &quot;&quot;2019-08-01T00:00:00-07:00&quot;&quot;,</span><br><span class="hljs-string">    &quot;&quot;2019-08-02T00:00:00-07:00&quot;&quot;</span><br><span class="hljs-string">  ],</span><br><span class="hljs-string">  &quot;&quot;TemperatureRanges&quot;&quot;: &#123;</span><br><span class="hljs-string">                &quot;&quot;Cold&quot;&quot;: &#123;</span><br><span class="hljs-string">                    &quot;&quot;High&quot;&quot;: 20,</span><br><span class="hljs-string">      &quot;&quot;Low&quot;&quot;: -10</span><br><span class="hljs-string">                &#125;,</span><br><span class="hljs-string">    &quot;&quot;Hot&quot;&quot;: &#123;</span><br><span class="hljs-string">                    &quot;&quot;High&quot;&quot;: 60,</span><br><span class="hljs-string">      &quot;&quot;Low&quot;&quot;: 20</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">            &#125;,</span><br><span class="hljs-string">  &quot;&quot;SummaryWords&quot;&quot;: [</span><br><span class="hljs-string">    &quot;&quot;Cool&quot;&quot;,</span><br><span class="hljs-string">    &quot;&quot;Windy&quot;&quot;,</span><br><span class="hljs-string">    &quot;&quot;Humid&quot;&quot;</span><br><span class="hljs-string">  ]</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&quot;</span>;<br><br>            WeatherForecast? weatherForecast = JsonSerializer.Deserialize&lt;WeatherForecast&gt;(jsonString);<br><br>            Console.WriteLine(<span class="hljs-string">$&quot;Date: <span class="hljs-subst">&#123;weatherForecast?.Date&#125;</span>&quot;</span>);<br>            Console.WriteLine(<span class="hljs-string">$&quot;TemperatureCelsius: <span class="hljs-subst">&#123;weatherForecast?.TemperatureCelsius&#125;</span>&quot;</span>);<br>            Console.WriteLine(<span class="hljs-string">$&quot;Summary: <span class="hljs-subst">&#123;weatherForecast?.Summary&#125;</span>&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面产生的输出如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Date</span>: <span class="hljs-number">2019</span>/<span class="hljs-number">8</span>/<span class="hljs-number">1</span> <span class="hljs-number">0</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> -<span class="hljs-number">07</span>:<span class="hljs-number">00</span><br><span class="hljs-attribute">TemperatureCelsius</span>: <span class="hljs-number">25</span><br><span class="hljs-attribute">Summary</span>: Hot<br></code></pre></td></tr></table></figure><h4 id="从文件中进行反序列化">从文件中进行反序列化</h4><p>其实就是先从文件中读取 JSON 字符串，再把这个 JSON 字符串用<code>JsonSerializer.Deserialize</code>方法反序列化。<br>同步版本：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">string</span> fileName = <span class="hljs-string">&quot;WeatherForecast.json&quot;</span>;<br><span class="hljs-built_in">string</span> jsonString = File.ReadAllText(fileName);<br>WeatherForecast weatherForecast = JsonSerializer.Deserialize&lt;WeatherForecast&gt;(jsonString)!;<br></code></pre></td></tr></table></figure><p>异步版本稍微不同，是通过打开一个流，然后将这个流作为参数传入<code>JsonSerializer.Deserialize</code>方法中来进行反序列化。<br>异步版本：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">string</span> fileName = <span class="hljs-string">&quot;WeatherForecast.json&quot;</span>;<br><span class="hljs-keyword">using</span> FileStream openStream = File.OpenRead(fileName);<br>WeatherForecast? weatherForecast = <span class="hljs-keyword">await</span> JsonSerializer.DeserializeAsync&lt;WeatherForecast&gt;(openStream);<br></code></pre></td></tr></table></figure><h4 id="反序列化需要注意的点">反序列化需要注意的点</h4><p>参考官方文档：<a href="https://learn.microsoft.com/zh-cn/dotnet/standard/serialization/system-text-json/how-to?pivots=dotnet-8-0#deserialization-behavior">反序列化行为</a></p><div class="note note-info">            <p>其实还可以序列化成 UTF-8 和从 UTF-8 反序列化的，但是我懒而且觉得我没那么常用就没写了。</p>          </div><h3 id="HttpClient-和-HttpContent-扩展方法">HttpClient 和 HttpContent 扩展方法</h3><h3 id="枚举类型的序列化">枚举类型的序列化</h3><h2 id="二进制序列化">二进制序列化</h2><h2 id="XML和SOAP序列化">XML和SOAP序列化</h2><hr>]]></content>
    
    
    <categories>
      
      <category>Learning Log</category>
      
      <category>CSharp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
      <tag>序列化</tag>
      
      <tag>serialization</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#笔记——异步编程</title>
    <link href="/2023/09/21/CSharp-learning-7/"/>
    <url>/2023/09/21/CSharp-learning-7/</url>
    
    <content type="html"><![CDATA[<h1>异步编程</h1><h2 id="什么事异步">什么事异步</h2><p>启动程序时，系统会在内存中创建一个新的<strong>进程</strong>。进程是构成运行程序的资源的集合。这些资源包括虚地址空间、文件句柄和程序运行所需的其他许多东西。<br>在进程内部，系统创建了一个称为<strong>线程</strong>的内核（kernel）对象，它代表了真正执行的程序。一旦进程建立，系统会在<code>Main</code>方法的第一行语句处开始线程的执行。<br>以下是关于线程的一些知识点：</p><ul><li>默认情况下，一个进程只包含一个线程，从程序的开始一直执行到结束。</li><li>线程可以派生其他线程，因此在任意时刻，一个进程都可能包含不同状态的多个进程，它们执行程序的不同部分。</li><li>如果一个进程拥有多个线程，它们将共享进程的资源。</li><li>系统为处理器执行所调度的单元是线程，不是进程。</li></ul><h2 id="应用场景">应用场景</h2><p>一个例子是，有时候我们的程序会向其他服务器发起请求获取数据，或是从数据库获取数据。但是一般情况下这里都会耗费大量的时间来等待其他服务器的响应，而我们不希望这种情况发生，我们更希望在等待的同时可以继续执行后面的代码，并在其他服务器回复后再返回。<br>另一个例子是，我们在设计交互式GUI程序时，有一些操作可能需要耗费大量时间，比如按下一个按钮后计算机执行大量计算，此时如果不使用异步操作的话，将冻结我们的GUI界面，使得用户在计算机执行完这个任务前无法继续与GUI界面进行交互。<br>这里也正好涉及到两个概念：I/O 绑定和 CPU 绑定。在这里，前者是 I/O 绑定，后者是 CPU 绑定。</p><h2 id="如何区别-CPU-绑定与-I-O绑定？">如何区别 CPU 绑定与 I/O绑定？</h2><p>以下是编写代码前应考虑的两个问题：</p><ol><li>你的代码是否会“等待”某些内容，例如数据库中的数据？  如果答案为“是”，则你的工作是 I/O 绑定。</li><li>你的代码是否要执行开销巨大的计算？  如果答案为“是”，则你的工作是 CPU 绑定。<br>如果你的工作为 I/O 绑定，请使用<code>async</code>和<code>await</code>（而不使用<code>Task.Run</code>）。不应使用任务并行库。<br>如果你的工作属于 CPU 绑定，并且你重视响应能力，请使用<code>async</code>和<code>await</code>，但在另一个线程上使用<code>Task.Run</code>生成工作。如果该工作同时适用于并发和并行，还应考虑使用任务并行库。</li></ol><h2 id="async-await-特性的结构">async/await 特性的结构</h2><p>该特性由三个部分组成：</p><ol><li>调用方法（calling method）：该方法调用异步方法，然后在异步方法执行其任务的时候继续执行（可能在相同的线程上，也可能在不同的线程上）。</li><li>异步方法（async method）：该方法异步执行其工作，然后立即返回到调用方法。</li><li>await 表达式：用于异步方法内部，指明需要异步执行的任务。一个异步方法可以包含任意多个<code>await</code>表达式，不过如果一个都不包含的话编译器会发出警告。</li></ol><h2 id="什么事异步方法">什么事异步方法</h2><p>异步方法就是：在完成其工作之前即返回到调用方法，然后在调用方法继续执行的时候完成其工作。<br>在语法上，异步方法具有如下特点：</p><ul><li>方法头中包含<code>async</code>方法修饰符。</li><li>包含一个或多个<code>await</code>表达式，表示可以异步完成的任务。</li><li>必须具备以下几种返回类型之一：<ol><li>void</li><li>Task</li><li>Task<T></li><li>ValueTask<T></li><li>任何具有公开可访问的<code>GetAwaiter</code>方法的类型。</li></ol></li><li>异步方法的形参可以为任意类型、任意数量，但不能为<code>out</code>或<code>ref</code>参数。</li><li>按照约定，异步方法的名称应该以<code>Async</code>为后缀</li><li>除了方法以外，<code>lambda</code>表达式和匿名方法也可以作为异步对象。<br>以下是一个异步方法的例子：</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">async</span> Task&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-title">CountCharactersAsync</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> id, <span class="hljs-built_in">string</span> site</span>)</span><br>&#123;<br>Console.WriteLine(<span class="hljs-string">&quot;Starting CountCharacters&quot;</span>);<br>WebClient wc = <span class="hljs-keyword">new</span> WebClient(); <br><br><span class="hljs-built_in">string</span> result = <span class="hljs-keyword">await</span> wc.DownloadStringTaskAsync(<span class="hljs-keyword">new</span> Uri(site));<br><br>Console.WriteLine(<span class="hljs-string">&quot;CountCharacters Completed&quot;</span>);<br><span class="hljs-keyword">return</span> result.Length;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="异步方法的返回类型">异步方法的返回类型</h2><p>上面提到异步方法的返回类型必须是：<code>void</code>、<code>Task</code>、<code>Task&lt;T&gt;</code>、<code>ValueTask&lt;T&gt;</code>其中之一，下面介绍一下这几种返回类型。</p><h3 id="Task">Task</h3><p>如果调用方法不需要从异步方法中返回某个值，但需要检查异步方法的状态，那么异步方法可以返回一个<code>Task</code>类型的对象。<br>在这种情况下，如果异步方法中包含任何<code>return</code>语句，则它们不能返回任何东西。</p><h3 id="Task-T">Task<T></h3><p>如果调用方法要从调用中获取一个<code>T</code>类型的值，异步方法的返回类型就必须是<code>Task&lt;T&gt;</code>。<br>调用方法将通过读取<code>Task</code>的<code>Result</code>属性来获取这个<code>T</code>类型的值。</p><h3 id="ValueTask-T">ValueTask<T></h3><p>这是一个值类型对象，它与<code>Task&lt;T&gt;</code>类似，但用于任务结果可能已经可用的情况。<br>因为它是一个值对象，所以它可以放在栈上，而无须像<code>Task&lt;T&gt;</code>对象那样在堆上分配空间。</p><h3 id="void">void</h3><p>如果调用方法仅仅想执行异步方法，而不需要与它做任何进一步的交互时，异步方法可以返回<code>void</code>类型。</p><div class="note note-warning">            <p>任何返回<code>Task&lt;T&gt;</code>类型的异步方法，其返回值必须为<code>T</code>类型或可以隐式转换为<code>T</code>的类型。</p>          </div><h2 id="await表达式"><code>await</code>表达式</h2><p><code>await</code>表达式制定了一个异步执行的任务。其语法为：<code>await task</code>，由<code>await</code>关键字和一个空闲对象（称为任务）组成。默认情况下，这个任务在当前线程上异步运行。<br>一个空闲对象即是一个<code>awaitable</code>类型的实例。<code>awaitable</code>类型是指包含<code>GetAwaiter</code>方法的类型，该方法没有参数，返回一个<code>awaitable</code>类型的对象。这也是为什么上文提到的异步方法返回的类型需要是那几种之一。</p><h3 id="创建自己的Task">创建自己的<code>Task</code></h3><p>当然我们也可以自行编写方法，作为<code>await</code>表达式的任务。最简单的方式是在你的方法中使用<code>Task.Run</code>方法来创建一个<code>Task</code>。</p><div class="note note-warning">            <p>关于<code>Task.Run</code>，有一点很重要，即它在不同的线程上运行你的方法。</p>          </div><p>下面以<code>Task.Run</code>的其中一种签名<code>Task Run(Func&lt;TReturn&gt; func)</code>作为例子，以三种不同的方式来编写任务：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">GetNum</span>()</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Random().Next(<span class="hljs-number">10</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">DoWorkAsync</span>()</span><br>&#123;<br>Func&lt;<span class="hljs-built_in">int</span>&gt; getNum = <span class="hljs-keyword">new</span> Func&lt;<span class="hljs-built_in">int</span>&gt;(GetNum);<br><span class="hljs-built_in">int</span> a = <span class="hljs-keyword">await</span> Task.Run(getNum);<br><span class="hljs-built_in">int</span> b = <span class="hljs-keyword">await</span> Task.Run(<span class="hljs-keyword">new</span> Func&lt;<span class="hljs-built_in">int</span>&gt;(GetNum));<br><span class="hljs-built_in">int</span> c = <span class="hljs-keyword">await</span> Task.Run(() =&gt; &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Random().Next(<span class="hljs-number">10</span>); &#125;);<br><br>Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;a&#125;</span> <span class="hljs-subst">&#123;b&#125;</span> <span class="hljs-subst">&#123;c&#125;</span>&quot;</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AsyncLearning</span><br>&#123;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>&#123;<br>Task t = (<span class="hljs-keyword">new</span> MyClass()).DoWorkAsync();<br>t.Wait();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码的运行结果为随机输出三个不大于10的非负整型数，例如：<code>1 4 2</code>。<br>下面来解释一下上面的三种<code>Task.Run</code>写法：</p><ul><li>第一个实例（变量<code>a</code>）使用<code>GetNum</code>创建名为<code>getNum</code>的<code>Func&lt;int&gt;</code>委托。然后在下一行将该委托用于<code>Task.Run</code>方法。</li><li>第二个实例（变量<code>b</code>）在<code>Task.Run</code>方法的参数列表中创建<code>Func&lt;int&gt;</code>委托。</li><li>第三个实例（变量<code>c</code>）直接使用与<code>Func&lt;int&gt;</code>委托兼容的<code>lambda</code>表达式，该<code>lambda</code>表达式将隐式转换为该委托。<br>其实<code>Task.Run</code>有八种重载，下表列出了这八种重载：<br>| 返回类型 | 签名 |<br>| :—: | :—: |<br>| <code>Task</code> | <code>Run(Action action)</code> |<br>| <code>Task</code> | <code>Run(Action action, CancellationToken token)</code> |<br>| <code>Task&lt;TResult&gt;</code> | <code>Run(Func&lt;TResult&gt; function)</code> |<br>| <code>Task&lt;TResult&gt;</code> | <code>Run(Func&lt;TResult&gt; function, CancellationToken token)</code> |<br>| <code>Task</code> | <code>Run(Func&lt;Task&gt; function)</code> |<br>| <code>Task</code> | <code>Run(Func&lt;Task&gt; function, CancellationToken token)</code> |<br>| <code>Task&lt;TResult&gt;</code> | <code>Run(Func&lt;Task&lt;TResult&gt;&gt; function)</code> |<br>| <code>Task&lt;TResult&gt;</code> | <code>Run(Func&lt;Task&lt;TResult&gt;&gt; function, CancellationToken token)</code> |</li></ul><p>下表是可作为<code>Task.Run</code>方法第一个参数的委托类型：</p><table><thead><tr><th style="text-align:center">委托类型</th><th style="text-align:center">签名</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center"><code>Action</code></td><td style="text-align:center"><code>void Action()</code></td><td style="text-align:center">不需要参数且无返回值的方法</td></tr><tr><td style="text-align:center"><code>Func&lt;TResult&gt;</code></td><td style="text-align:center"><code>TResult Func()</code></td><td style="text-align:center">不需要参数，但返回<code>TResult</code>类型对象的方法</td></tr><tr><td style="text-align:center"><code>Func&lt;Task&gt;</code></td><td style="text-align:center"><code>Task Func()</code></td><td style="text-align:center">不需要参数，但返回简单<code>Task</code>对象的方法</td></tr><tr><td style="text-align:center"><code>Func&lt;Task&lt;TResult&gt;&gt;</code></td><td style="text-align:center"><code>Task&lt;TResult&gt; Func()</code></td><td style="text-align:center">不需要参数，但返回<code>Task&lt;T&gt;</code>类型对象的方法</td></tr></tbody></table><h3 id="取消一个异步操作">取消一个异步操作</h3><p>一些 .NET 异步方法允许我们请求终止执行。这里涉及到两个不同的类：<code>CancellationToken</code>和<code>CancellationTokenSource</code>。<br>下面是一些需要注意的点：</p><ul><li><code>CancellationToken</code>对象包含一个任务是否应被取消的信息</li><li>拥有<code>CancellationToken</code>对象的任务需要定期检查其令牌（<code>token</code>）状态。如果<code>CancellationToken</code>对象的<code>IsCancellationRequested</code>属性为<code>true</code>，任务需停止其操作并返回。</li><li><strong><code>CancellationToken</code>是不可逆的，并且只能使用一次</strong>。一旦<code>IsCancellationRequested</code>属性被设置为<code>true</code>，就不能再更改了。</li><li><code>CancellationTokenSource</code>对象创建可分配给不同任务的<code>CancellationToken</code>对象。任何持有<code>CancellationTokenSource</code>的对象都可以调用其<code>Cancel</code>方法，这会将<code>CancellationToken</code>的<code>IsCancellationRequested</code>属性设置为<code>true</code>。<br>下面是一个例子：</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncCancelClass</span><br>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">RunAsync</span>(<span class="hljs-params">CancellationToken ct</span>)</span><br>&#123;<br><span class="hljs-keyword">if</span> (ct.IsCancellationRequested) <span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">await</span> Task.Run(() =&gt; CycleMethod(ct), ct);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CycleMethod</span>(<span class="hljs-params">CancellationToken ct</span>)</span><br>&#123;<br>Console.WriteLine(<span class="hljs-string">&quot;Starting Method...&quot;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br><span class="hljs-keyword">if</span> (ct.IsCancellationRequested) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// 监控 CancellationToken</span><br>Thread.Sleep(<span class="hljs-number">1000</span>);<br>Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123; i+<span class="hljs-number">1</span> &#125;</span> of 5 iterations completed.&quot;</span>);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncLearning</span><br>&#123;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>&#123;<br>CancellationTokenSource cts = <span class="hljs-keyword">new</span> CancellationTokenSource();<br>CancellationToken ct = cts.Token;<br><br>AsyncCancelClass asyncCancelClass = <span class="hljs-keyword">new</span> AsyncCancelClass();<br>Task t = asyncCancelClass.RunAsync(ct);<br><br>Thread.Sleep(<span class="hljs-number">3000</span>);<br>cts.Cancel();  <span class="hljs-comment">// 执行取消操作</span><br><br>t.Wait();<br>Console.WriteLine(<span class="hljs-string">$&quot;Was Cancelled: <span class="hljs-subst">&#123; ct.IsCancellationRequested &#125;</span>&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码的输出结果如下：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs erlang">Starting Method...<br><span class="hljs-number">1</span> <span class="hljs-keyword">of</span> <span class="hljs-number">5</span> iterations completed.<br><span class="hljs-number">2</span> <span class="hljs-keyword">of</span> <span class="hljs-number">5</span> iterations completed.<br><span class="hljs-number">3</span> <span class="hljs-keyword">of</span> <span class="hljs-number">5</span> iterations completed.<br>Was Cancelled: True<br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>需要注意的是，该过程是<strong>协同</strong>的，即调用<code>CancellationTokenSource</code>的<code>Cancel</code>时，它本身并不会执行取消操作，而是会将<code>CancellationToken</code>的<code>IsCancellationRequested</code>属性设置为<code>true</code>。<strong>包含<code>CancellationToken</code>的代码负责检查该属性，并判断是否需要停止执行并返回。</strong></p>          </div><h3 id="异常处理和await表达式">异常处理和<code>await</code>表达式</h3><p><strong>to do…</strong></p><h3 id="再调用方法中同步地等待任务">再调用方法中同步地等待任务</h3><p>我们在等待单个<code>Task</code>对象完成其任务时，可以使用<code>Wait()</code>方法。但是如果我们需要等待一组<code>Task</code>对象的话呢？<code>Task</code>类提供了两个静态方法：</p><ul><li><code>WaitAll</code>：等待所有任务结束</li><li><code>WaitAny</code>：等待某一个任务结束<br>下面是一个例子：</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">WaitAsyncClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoRun</span>()</span><br>    &#123;<br>        Task t1 = Task.Run(() =&gt; &#123; Thread.Sleep(<span class="hljs-number">5000</span>); &#125;);<br>        Task t2 = Task.Run(() =&gt; &#123; Thread.Sleep(<span class="hljs-number">3000</span>); &#125;);<br><br>        <span class="hljs-comment">// Task.WaitAll(t1, t2);</span><br>        <span class="hljs-comment">// Task.WaitAny(t1, t2);</span><br><br>        Console.WriteLine(<span class="hljs-string">&quot;Task 1: &#123;0&#125;Finishied&quot;</span>, t1.IsCompleted ? <span class="hljs-string">&quot; &quot;</span> : <span class="hljs-string">&quot;Not &quot;</span>);<br>        Console.WriteLine(<span class="hljs-string">&quot;Task 2: &#123;0&#125;Finishied&quot;</span>, t2.IsCompleted ? <span class="hljs-string">&quot; &quot;</span> : <span class="hljs-string">&quot;Not &quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncLearning</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">new</span> WaitAsyncClass().DoRun();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果既不调用<code>WaitAll()</code>也不调用<code>WaitAny()</code>的话，输出如下：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">Task</span> <span class="hljs-number">1</span>: <span class="hljs-keyword">Not</span> Finishied<br><span class="hljs-keyword">Task</span> <span class="hljs-number">2</span>: <span class="hljs-keyword">Not</span> Finishied<br></code></pre></td></tr></table></figure><p>如果调用<code>WaitAll()</code>方法，输出如下：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">Task</span> <span class="hljs-number">1</span>:  Finishied<br><span class="hljs-keyword">Task</span> <span class="hljs-number">2</span>:  Finishied<br></code></pre></td></tr></table></figure><p>如果调用<code>WaitAny()</code>方法，输出如下：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">Task</span> <span class="hljs-number">1</span>: <span class="hljs-keyword">Not</span> Finishied<br><span class="hljs-keyword">Task</span> <span class="hljs-number">2</span>:  Finishied<br></code></pre></td></tr></table></figure><p><code>WaitAll</code>和<code>WaitAny</code>分别还包含4个重载，除了完成任务之外，还允许以不同的方式继续执行，如设置超时时间或使用<code>CancellationToken</code>来强制执行处理的后续部分。</p><h3 id="在异步方法中异步地等待任务">在异步方法中异步地等待任务</h3><p>下面是一个例子：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">DelayAsyncClass</span><br>&#123;<br>Stopwatch sw = <span class="hljs-keyword">new</span> Stopwatch();<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoRun</span>()</span><br>&#123;<br>Console.WriteLine(<span class="hljs-string">&quot;Caller: Before call.&quot;</span>);<br>DelayAsync();<br>Console.WriteLine(<span class="hljs-string">&quot;Caller: After call.&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DelayAsync</span>()</span><br>&#123;<br>sw.Start();<br>Console.WriteLine(<span class="hljs-string">$&quot;Before delay: <span class="hljs-subst">&#123; sw.ElapsedMilliseconds &#125;</span>&quot;</span>);<br><span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">1000</span>);<br><span class="hljs-comment">// Thread.Sleep(1000);</span><br>Console.WriteLine(<span class="hljs-string">$&quot;After delay: <span class="hljs-subst">&#123; sw.ElapsedMilliseconds &#125;</span>&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncLearning</span><br>&#123;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>&#123;<br><span class="hljs-keyword">new</span> DelayAsyncClass().DoRun();<br>Console.Read();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用<code>Task.Delay</code>方法的输出如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#">Caller: Before call.<br>Before delay: <span class="hljs-number">0</span><br>Caller: After call.<br>After delay: <span class="hljs-number">1006</span><br></code></pre></td></tr></table></figure><p>使用<code>Thread.Sleep</code>方法的输出如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#">Caller: Before call.<br>Before delay: <span class="hljs-number">0</span><br>After delay: <span class="hljs-number">1006</span><br>Caller: After call.<br></code></pre></td></tr></table></figure><p>可以看出，<code>Task.Delay</code>不会阻塞线程，线程可以继续处理其他工作。</p><h2 id="异步方法的应用">异步方法的应用</h2><h3 id="await-async模式"><code>await</code>/<code>async</code>模式</h3><p><code>MainWindow.xaml</code>中的代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Window</span> <span class="hljs-attr">x:Class</span>=<span class="hljs-string">&quot;WpfAwait.MainWindow&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">xmlns:x</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">xmlns:d</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/expression/blend/2008&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">xmlns:mc</span>=<span class="hljs-string">&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">xmlns:local</span>=<span class="hljs-string">&quot;clr-namespace:WpfAwait&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">mc:Ignorable</span>=<span class="hljs-string">&quot;d&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">Title</span>=<span class="hljs-string">&quot;MainWindow&quot;</span> <span class="hljs-attr">Height</span>=<span class="hljs-string">&quot;150&quot;</span> <span class="hljs-attr">Width</span>=<span class="hljs-string">&quot;250&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">StackPanel</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Name</span>=<span class="hljs-string">&quot;btnProcess&quot;</span> <span class="hljs-attr">Width</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">Click</span>=<span class="hljs-string">&quot;btnProcess_Click&quot;</span> <span class="hljs-attr">HorizontalAlignment</span>=<span class="hljs-string">&quot;Right&quot;</span> <span class="hljs-attr">Margin</span>=<span class="hljs-string">&quot;10,15,10,10&quot;</span>&gt;</span>Process<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Name</span>=<span class="hljs-string">&quot;btnCancel&quot;</span> <span class="hljs-attr">Width</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">Click</span>=<span class="hljs-string">&quot;btnCancel_Click&quot;</span> <span class="hljs-attr">HorizontalAlignment</span>=<span class="hljs-string">&quot;Right&quot;</span> <span class="hljs-attr">Margin</span>=<span class="hljs-string">&quot;10,0&quot;</span>&gt;</span>Cancel<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">ProgressBar</span> <span class="hljs-attr">Name</span>=<span class="hljs-string">&quot;progressBar&quot;</span> <span class="hljs-attr">Height</span>=<span class="hljs-string">&quot;20&quot;</span> <span class="hljs-attr">Width</span>=<span class="hljs-string">&quot;200&quot;</span> <span class="hljs-attr">Margin</span>=<span class="hljs-string">&quot;10&quot;</span> <span class="hljs-attr">HorizontalAlignment</span>=<span class="hljs-string">&quot;Right&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ProgressBar</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">StackPanel</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Window</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>MainWindow.xaml.cs</code>中的代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System.Threading;<br><span class="hljs-keyword">using</span> System.Threading.Tasks;<br><span class="hljs-keyword">using</span> System.Windows;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">WpfAwait</span><br>&#123;<br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> MainWindow.xaml 的交互逻辑</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MainWindow</span> : <span class="hljs-title">Window</span><br>    &#123;<br>        CancellationTokenSource cancellationTokenSource;<br>        CancellationToken cancellationToken;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MainWindow</span>()</span><br>        &#123;<br>            InitializeComponent();<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">void</span> <span class="hljs-title">btnProcess_Click</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, RoutedEventArgs e</span>)</span><br>        &#123;<br>            btnProcess.IsEnabled = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 将Process按钮设为不可用</span><br><br>            cancellationTokenSource = <span class="hljs-keyword">new</span> CancellationTokenSource();  <span class="hljs-comment">// 设置新的取消标志</span><br>            cancellationToken = cancellationTokenSource.Token;<br><br>            <span class="hljs-built_in">int</span> completedPercent = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 百分比</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)  <span class="hljs-comment">// 处理事务（迫真）</span><br>            &#123;<br>                <span class="hljs-keyword">if</span> (cancellationToken.IsCancellationRequested)  <span class="hljs-comment">// 定期检查取消标志的值以及时停止任务</span><br>                &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br><br>                <span class="hljs-keyword">try</span><br>                &#123;<br>                    <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">500</span>, cancellationToken);  <span class="hljs-comment">// 实际上这里不传 cancellationToken 也能正常工作</span><br>                    completedPercent = (i + <span class="hljs-number">1</span>) * <span class="hljs-number">10</span>;<br>                &#125;<br>                <span class="hljs-keyword">catch</span> (TaskCanceledException ex)<br>                &#123;<br>                    completedPercent = i * <span class="hljs-number">10</span>;<br>                &#125;<br>                progressBar.Value = completedPercent;  <span class="hljs-comment">// 设置进度条的值</span><br>            &#125;<br><br>            <span class="hljs-built_in">string</span> message = cancellationToken.IsCancellationRequested ? <span class="hljs-built_in">string</span>.Format(<span class="hljs-string">$&quot;Process was cancelled at <span class="hljs-subst">&#123;completedPercent&#125;</span>%.&quot;</span>) : <span class="hljs-string">&quot;Process completed normally.&quot;</span>;<br>            MessageBox.Show(message, <span class="hljs-string">&quot;Completion Status&quot;</span>);  <span class="hljs-comment">// 弹窗显示相关信息</span><br><br>            progressBar.Value = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 重置相关控件状态</span><br>            btnProcess.IsEnabled = <span class="hljs-literal">true</span>;<br>            btnCancel.IsEnabled = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">btnCancel_Click</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, RoutedEventArgs e</span>)</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (!btnProcess.IsEnabled)  <span class="hljs-comment">// 如果Process按钮不可用，说明正在处理事务，此时取消按钮可正常工作</span><br>            &#123;<br>                btnCancel.IsEnabled = <span class="hljs-literal">false</span>;<br>                cancellationTokenSource.Cancel();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BackgroundWorker模式"><code>BackgroundWorker</code>模式</h3><p><code>MainWindow.xaml</code>中的代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Window</span> <span class="hljs-attr">x:Class</span>=<span class="hljs-string">&quot;SimpleWorker.MainWindow&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">xmlns:x</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">xmlns:d</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/expression/blend/2008&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">xmlns:mc</span>=<span class="hljs-string">&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">xmlns:local</span>=<span class="hljs-string">&quot;clr-namespace:SimpleWorker&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">mc:Ignorable</span>=<span class="hljs-string">&quot;d&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">Title</span>=<span class="hljs-string">&quot;MainWindow&quot;</span> <span class="hljs-attr">Height</span>=<span class="hljs-string">&quot;150&quot;</span> <span class="hljs-attr">Width</span>=<span class="hljs-string">&quot;350&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">StackPanel</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">ProgressBar</span> <span class="hljs-attr">Name</span>=<span class="hljs-string">&quot;progressBar&quot;</span> <span class="hljs-attr">Height</span>=<span class="hljs-string">&quot;20&quot;</span> <span class="hljs-attr">Width</span>=<span class="hljs-string">&quot;200&quot;</span> <span class="hljs-attr">Margin</span>=<span class="hljs-string">&quot;10&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ProgressBar</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Name</span>=<span class="hljs-string">&quot;btnProcess&quot;</span> <span class="hljs-attr">Width</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">Click</span>=<span class="hljs-string">&quot;btnProcess_Click&quot;</span> <span class="hljs-attr">Margin</span>=<span class="hljs-string">&quot;5&quot;</span>&gt;</span>Process<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Name</span>=<span class="hljs-string">&quot;btnCancel&quot;</span> <span class="hljs-attr">Width</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">Click</span>=<span class="hljs-string">&quot;btnCancel_Click&quot;</span> <span class="hljs-attr">Margin</span>=<span class="hljs-string">&quot;5&quot;</span>&gt;</span>Cancel<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">StackPanel</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Window</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>MainWindow.xaml.cs</code>中的代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System.ComponentModel;<br><span class="hljs-keyword">using</span> System.Threading;<br><span class="hljs-keyword">using</span> System.Windows;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">SimpleWorker</span><br>&#123;<br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> MainWindow.xaml 的交互逻辑</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MainWindow</span> : <span class="hljs-title">Window</span><br>    &#123;<br>        BackgroundWorker bgWorker = <span class="hljs-keyword">new</span> BackgroundWorker();<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MainWindow</span>()</span><br>        &#123;<br>            InitializeComponent();<br><br>            <span class="hljs-comment">// 设置BackgroundWorker属性</span><br>            bgWorker.WorkerReportsProgress = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 允许将进度汇报给主线程</span><br>            bgWorker.WorkerSupportsCancellation = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 允许主线程取消后台任务</span><br><br>            <span class="hljs-comment">// 连接BackgroundWorker对象的处理程序</span><br>            bgWorker.DoWork += DoWork_Handler;<br>            bgWorker.ProgressChanged += ProcessChanged_Handler;<br>            bgWorker.RunWorkerCompleted += RunWorkerCompleted_Handler;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">btnProcess_Click</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, RoutedEventArgs e</span>)</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (!bgWorker.IsBusy)  <span class="hljs-comment">// 如果后台任务未启动，则启动后台任务</span><br>            &#123;<br>                bgWorker.RunWorkerAsync();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">btnCancel_Click</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, RoutedEventArgs e</span>)</span><br>        &#123;<br>            bgWorker.CancelAsync();  <span class="hljs-comment">// 把CancellationPending属性设置为True</span><br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ProcessChanged_Handler</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, ProgressChangedEventArgs args</span>)</span><br>        &#123;<br>            progressBar.Value = args.ProgressPercentage;  <span class="hljs-comment">// 通过触发ProgressChanged事件，事件调用ProcessChanged_Handler方法，从而更新进度条</span><br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoWork_Handler</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, DoWorkEventArgs args</span>)</span><br>        &#123;<br>            BackgroundWorker worker  = sender <span class="hljs-keyword">as</span> BackgroundWorker;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>;  i++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (worker.CancellationPending)  <span class="hljs-comment">// 定期检查CancellationPending属性，以及时取消后台任务</span><br>                &#123;<br>                    args.Cancel = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    worker.ReportProgress(i * <span class="hljs-number">10</span>);  <span class="hljs-comment">// 调用ReportProgress方法来触发ProgressChanged事件</span><br>                    Thread.Sleep(<span class="hljs-number">500</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RunWorkerCompleted_Handler</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, RunWorkerCompletedEventArgs args</span>)</span><br>        &#123;<br>            progressBar.Value = <span class="hljs-number">0</span>;<br><br>            <span class="hljs-keyword">if</span> (args.Cancelled)<br>            &#123;<br>                MessageBox.Show(<span class="hljs-string">&quot;Process was cancelled.&quot;</span>, <span class="hljs-string">&quot;Process Cancelled.&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                MessageBox.Show(<span class="hljs-string">&quot;Process completed normally.&quot;</span>, <span class="hljs-string">&quot;Process Completed.&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="并行循环">并行循环</h2><p>.NET 还提供了一个任务并行库<code>Task Parallel Library</code>，用于并行编程，这里只简单介绍下其中的并行循环，两者都位于<code>System.Threading.Tasks</code>命名空间中。</p><h3 id="Parallel-For"><code>Parallel.For</code></h3><p><code>Parallel.For</code>方法有 12 个重载，其中一个是：<code>public static ParallelLoopResult.For(int fromInclusive, int toExclusive, Action body)</code>。</p><ul><li><code>fromInclusive</code>参数是迭代系列的第一个整数。</li><li><code>toExclusive</code>参数是比迭代系列的最后一个索引号大 1 的整数。</li><li><code>body</code>是接受单个输入参数的委托。<br>下面是一个例子：</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">Parallel.For(<span class="hljs-number">0</span>, <span class="hljs-number">15</span>, i =&gt; &#123; Console.WriteLine(<span class="hljs-string">$&quot;The square of <span class="hljs-subst">&#123;i&#125;</span> is <span class="hljs-subst">&#123;i * i&#125;</span>&quot;</span>); &#125;);<br></code></pre></td></tr></table></figure><p>它的一个输出如下（因为是并行处理所以每次输出都可能不一样）：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">The</span> square of <span class="hljs-number">0</span> is <span class="hljs-number">0</span><br><span class="hljs-attribute">The</span> square of <span class="hljs-number">10</span> is <span class="hljs-number">100</span><br><span class="hljs-attribute">The</span> square of <span class="hljs-number">1</span> is <span class="hljs-number">1</span><br><span class="hljs-attribute">The</span> square of <span class="hljs-number">2</span> is <span class="hljs-number">4</span><br><span class="hljs-attribute">The</span> square of <span class="hljs-number">3</span> is <span class="hljs-number">9</span><br><span class="hljs-attribute">The</span> square of <span class="hljs-number">4</span> is <span class="hljs-number">16</span><br><span class="hljs-attribute">The</span> square of <span class="hljs-number">5</span> is <span class="hljs-number">25</span><br><span class="hljs-attribute">The</span> square of <span class="hljs-number">6</span> is <span class="hljs-number">36</span><br><span class="hljs-attribute">The</span> square of <span class="hljs-number">8</span> is <span class="hljs-number">64</span><br><span class="hljs-attribute">The</span> square of <span class="hljs-number">9</span> is <span class="hljs-number">81</span><br><span class="hljs-attribute">The</span> square of <span class="hljs-number">7</span> is <span class="hljs-number">49</span><br><span class="hljs-attribute">The</span> square of <span class="hljs-number">13</span> is <span class="hljs-number">169</span><br><span class="hljs-attribute">The</span> square of <span class="hljs-number">12</span> is <span class="hljs-number">144</span><br><span class="hljs-attribute">The</span> square of <span class="hljs-number">11</span> is <span class="hljs-number">121</span><br><span class="hljs-attribute">The</span> square of <span class="hljs-number">14</span> is <span class="hljs-number">196</span><br></code></pre></td></tr></table></figure><h3 id="Parallel-ForEach"><code>Parallel.ForEach</code></h3><p>该方法也有很多重载，这里简单地以：<code>static ParallelLoopResult ForEach&lt;TSource&gt;( IEnumerable&lt;TSource&gt; source, Action&lt;TSource&gt; body)</code>举例说明：</p><ul><li><code>TSource</code>是集合中对象的类型。</li><li><code>source</code>是<code>TSource</code>对象的集合。</li><li><code>body</code>是要应用到集合中每一个元素上的<code>Lambda</code>表达式。<br>下面是一个例子：</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">string</span>[] squares = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[] &#123; <span class="hljs-string">&quot;We&quot;</span>, <span class="hljs-string">&quot;hold&quot;</span>, <span class="hljs-string">&quot;these&quot;</span>, <span class="hljs-string">&quot;truths&quot;</span>, <span class="hljs-string">&quot;to&quot;</span>, <span class="hljs-string">&quot;be&quot;</span>, <span class="hljs-string">&quot;self-evident&quot;</span>, <span class="hljs-string">&quot;that&quot;</span>, <span class="hljs-string">&quot;all&quot;</span>, <span class="hljs-string">&quot;men&quot;</span>, <span class="hljs-string">&quot;are&quot;</span>, <span class="hljs-string">&quot;created&quot;</span>, <span class="hljs-string">&quot;equal&quot;</span> &#125;;<br>Parallel.ForEach(squares, i =&gt; Console.WriteLine(<span class="hljs-string">$&quot;\&quot;<span class="hljs-subst">&#123;i&#125;</span>\&quot; has <span class="hljs-subst">&#123;i.Length&#125;</span> letters&quot;</span>));```<br></code></pre></td></tr></table></figure><p>它的一个输出如下（因为是并行处理所以每次输出都可能不一样）：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-string">&quot;created&quot;</span> <span class="hljs-built_in">has</span> <span class="hljs-number">7</span> letters<br><span class="hljs-string">&quot;be&quot;</span> <span class="hljs-built_in">has</span> <span class="hljs-number">2</span> letters<br><span class="hljs-string">&quot;these&quot;</span> <span class="hljs-built_in">has</span> <span class="hljs-number">5</span> letters<br><span class="hljs-string">&quot;hold&quot;</span> <span class="hljs-built_in">has</span> <span class="hljs-number">4</span> letters<br><span class="hljs-string">&quot;We&quot;</span> <span class="hljs-built_in">has</span> <span class="hljs-number">2</span> letters<br><span class="hljs-string">&quot;truths&quot;</span> <span class="hljs-built_in">has</span> <span class="hljs-number">6</span> letters<br><span class="hljs-string">&quot;men&quot;</span> <span class="hljs-built_in">has</span> <span class="hljs-number">3</span> letters<br><span class="hljs-string">&quot;equal&quot;</span> <span class="hljs-built_in">has</span> <span class="hljs-number">5</span> letters<br><span class="hljs-string">&quot;are&quot;</span> <span class="hljs-built_in">has</span> <span class="hljs-number">3</span> letters<br><span class="hljs-string">&quot;all&quot;</span> <span class="hljs-built_in">has</span> <span class="hljs-number">3</span> letters<br><span class="hljs-string">&quot;that&quot;</span> <span class="hljs-built_in">has</span> <span class="hljs-number">4</span> letters<br><span class="hljs-string">&quot;to&quot;</span> <span class="hljs-built_in">has</span> <span class="hljs-number">2</span> letters<br><span class="hljs-string">&quot;self-evident&quot;</span> <span class="hljs-built_in">has</span> <span class="hljs-number">12</span> letters<br></code></pre></td></tr></table></figure><h2 id="定时器">定时器</h2><p>简单介绍一下<code>System.Threading</code>命名空间中的<code>Timer</code>类，也就是定时器类，它提供了一种定期重复运行异步方法的方式。</p><div class="note note-info">            <p>在 .NET BCL 中还存在着好几个<code>Timer</code>类，比如<code>System.Windows.Forms.Timer</code>和<code>System.Timers.Timer</code>，可以了解下。</p>          </div><p><code>Timer</code>类的其中一个常用构造函数是：<code>Timer(TimerCallback callback, object state, uint dueTime, uint period)</code>。<br>其中第一个参数是回调的名字，第二个参数是传给回调的对象（可以通过这个对象来传递信息），第三个参数是等待多少毫秒后第一次调用，最后一个参数是每隔多少毫秒进行一次调用。<br>如果想要改变已创建的<code>Timer</code>类对象的<code>dueTime</code>和<code>period</code>，可以使用<code>Change</code>方法。<br>下面是一个演示：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">TimerLearning</span><br>&#123;<br>Stopwatch sw = <span class="hljs-keyword">new</span> Stopwatch();<br><span class="hljs-built_in">int</span> TimesCalled = <span class="hljs-number">0</span>;<br><br>TimerLearning() &#123; sw.Start(); &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MyCallbackMethod</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> state</span>)</span><br>&#123;<br>Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;(<span class="hljs-built_in">string</span>)state&#125;</span> <span class="hljs-subst">&#123;++TimesCalled&#125;</span> <span class="hljs-subst">&#123;sw.ElapsedMilliseconds&#125;</span>&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>&#123;<br>TimerLearning timerLearning = <span class="hljs-keyword">new</span> TimerLearning();<br>Timer timer = <span class="hljs-keyword">new</span> Timer(timerLearning.MyCallbackMethod, <span class="hljs-string">&quot;Processing timer event&quot;</span>, <span class="hljs-number">2000</span>, <span class="hljs-number">1000</span>);<br>Console.WriteLine(<span class="hljs-string">&quot;Timer started.&quot;</span>);<br><br>Thread.Sleep(<span class="hljs-number">5000</span>);  <span class="hljs-comment">// 延时 5s 后改变 timer 的 dueTime 和 period</span><br>timer.Change(<span class="hljs-number">1000</span>, <span class="hljs-number">2000</span>);<br><br>Console.ReadLine();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面是输出结果</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Timer</span> started.<br><span class="hljs-attribute">Processing</span> timer event <span class="hljs-number">1</span> <span class="hljs-number">2024</span><br><span class="hljs-attribute">Processing</span> timer event <span class="hljs-number">2</span> <span class="hljs-number">3000</span><br><span class="hljs-attribute">Processing</span> timer event <span class="hljs-number">3</span> <span class="hljs-number">4001</span><br><span class="hljs-attribute">Processing</span> timer event <span class="hljs-number">4</span> <span class="hljs-number">5001</span><br><span class="hljs-attribute">Processing</span> timer event <span class="hljs-number">5</span> <span class="hljs-number">6015</span><br><span class="hljs-attribute">Processing</span> timer event <span class="hljs-number">6</span> <span class="hljs-number">8014</span><br><span class="hljs-attribute">Processing</span> timer event <span class="hljs-number">7</span> <span class="hljs-number">10014</span><br><span class="hljs-attribute">Processing</span> timer event <span class="hljs-number">8</span> <span class="hljs-number">12014</span><br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>Learning Log</category>
      
      <category>CSharp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
      <tag>异步</tag>
      
      <tag>async</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#笔记——命名空间和程序集、反射和特性</title>
    <link href="/2023/09/21/CSharp-learning-6/"/>
    <url>/2023/09/21/CSharp-learning-6/</url>
    
    <content type="html"><![CDATA[<h1>引用其他程序集</h1><p>在编写自己的程序时，我们有时想要使用别人写好的库里的类和方法，比如<code>python</code>中我们会先用<code>pip</code>命令安装想要的库，再使用<code>import</code>语句引入，那在<code>C#</code>中应该如何引入呢？<br>首先要知道引入的是类库，而这些类库的文件名通常以<code>.dll</code>结尾（很熟悉不是吗）。<br>其次要使用类库，就需要给编译器一个到该程序集的引用，给出程序集的名称和位置。<br>在<code>Visual Studio</code>中，右键<code>Solution Explorer</code>下的对应项目名称下的<code>References</code>，并点击<code>Add Reference</code>就可以为该项目添加类库引用了。<br>当然，引用类库难免会出现多个类库中存在相同名称的类的情况，这个时候如果不在程序中指明我们使用的是哪个类库的该类的话，编译器就会报错，这个时候，命名空间就该登场啦。</p><h1>命名空间</h1><h2 id="基本概念">基本概念</h2><p>其实我们每个<code>cs</code>文件中的最外边的<code>namespace</code>语句就是创建命名空间语法：<code>namespace NamespaceName</code>。<br>我们可以通过命名空间来区别不同命名空间下拥有相同名字的成员，如：<code>MyNamespace.Point</code>和<code>YourNamespace.Point</code>，从而避免类库冲突等情况。<br>命名空间拥有一些命名指南，就像编码规范那样，遵循指南可以让代码拥有良好的可读性：</p><ol><li>以公司（或个人）名称开头</li><li>在公司（或个人）之后跟着技术名称</li><li>不要与类或类型名相同<br>例如：<code>namespace Maple.Media</code>和<code>namespace Maple.Games</code></li></ol><h2 id="命名空间跨文件伸展">命名空间跨文件伸展</h2><p>命名空间不是封闭的，这意味着可以在该源文件的后面或另一个源文件中再次声明它（像不像<code>partial class</code>），以对它增加更多的类型声明。而我们可以源文件编译成单个程序集，也可以编译成单独的程序集。</p><h1><code>using</code>指令</h1><h2 id="using命名空间指令"><code>using</code>命名空间指令</h2><p>我们可以通过在源文件的顶端放置<code>using</code>命名空间指令以避免使用长名称，比如常见的：<code>using System</code>，这样在写代码的时候我们就可以直接<code>Console.WriteLine(&quot; &quot;)</code>而不是<code>System.Console.WriteLine(&quot; &quot;)</code>了，因为<code>using</code>命名空间指令会通知编译器你将要使用来自某个指定命名空间的类型。</p><h2 id="using别名指令"><code>using</code>别名指令</h2><p>对于<code>using</code>还有另外一个作用就是通过它来为命名空间或类取别名，类似于<code>python</code>的<code>import xxx as alias</code>。例如：<code>using SC = System.Console</code>，然后可以直接<code>SC.WriteLine(&quot; &quot;)</code>。</p><h2 id="using-static指令"><code>using static</code>指令</h2><p>可以使用<code>using static</code>指令引用给定命名空间中的特定类、结构体或枚举，这样就可以不带任何前缀地访问该类、结构体或枚举的<strong>静态成员</strong>。比如<code>using static System.Math</code>，然后我们就可以直接调用一系列数学方法如<code>var squareRoot = Sqrt(16)</code>了。</p><div class="note note-warning">            <p>需要注意的是，<code>using static</code>指令指定的类本身可以不是静态的，而它也仅仅引入指定类、结构体或枚举的静态成员</p>          </div><h1>反射</h1><h2 id="基本概念-2">基本概念</h2><p><strong>反射</strong>，即：运行中的程序查看本身的<strong>元数据</strong>或其他程序的元数据的行为。而<strong>元数据</strong>，则是有关程序及其类型的数据，它们保存在程序的程序集中。要反射数据，我们可以使用<code>System.Reflection</code>命名空间中的类和<code>System.Type</code>。</p><h2 id="Type类"><code>Type</code>类</h2><p>BCL(Base Class Library) 声明了一个叫作<code>Type</code>的类，它被设计用来包含类型的特征。使用这个类的对象就获取程序使用的类型的信息（通过类中定义的属性和方法）。</p><h3 id="System-Type类的部分成员"><code>System.Type</code>类的部分成员</h3><table><thead><tr><th style="text-align:center">成员</th><th style="text-align:center">成员类型</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">Name</td><td style="text-align:center">属性</td><td style="text-align:center">返回类型的名字</td></tr><tr><td style="text-align:center">Namespace</td><td style="text-align:center">属性</td><td style="text-align:center">返回包含类型声明的命名空间</td></tr><tr><td style="text-align:center">Assembly</td><td style="text-align:center">属性</td><td style="text-align:center">返回声明类型的程序集</td></tr><tr><td style="text-align:center">GetFields</td><td style="text-align:center">方法</td><td style="text-align:center">返回类型的字段列表</td></tr><tr><td style="text-align:center">GetProperties</td><td style="text-align:center">方法</td><td style="text-align:center">返回类型的属性列表</td></tr><tr><td style="text-align:center">GetMethods</td><td style="text-align:center">方法</td><td style="text-align:center">返回类型的方法列表</td></tr></tbody></table><h2 id="获取Type对象">获取<code>Type</code>对象</h2><p>要获取<code>Type</code>对象，可以使用实例对象的<code>GetType</code>方法和<code>typeof</code>运算符和类名来获取<code>Type</code>对象。</p><h3 id="GetType方法"><code>GetType</code>方法</h3><p><code>object</code>类型包含了一个叫做<code>GetType</code>的方法，它返回对实例的<code>Type</code>对象的引用。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">Type t = myClassInstance.GetType();<br></code></pre></td></tr></table></figure><h3 id="typeof运算符"><code>typeof</code>运算符</h3><p><code>typeof</code>运算符接受一个操作数，这个操作数应是类型名，返回的结果是<code>Type</code>对象的引用。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">Type t = <span class="hljs-keyword">typeof</span>( ClassName );<br></code></pre></td></tr></table></figure><h1>特性</h1><h2 id="基本概念-3">基本概念</h2><p>特性（attribute）是一种允许我们向程序的程序集添加元数据的语言结构。特性的目的是告诉编译器把程序结构的某组元数据嵌入程序集。<br>将应用了特性的程序结构（program construct）叫作目标（target）。<br>设计用来获取和使用元数据的程序叫作特性的消费者（consumer）。</p><h2 id="命名规范">命名规范</h2><p>特性名使用 Pascal 命名法并且以 Attribute 为后缀结尾。当为目标应用特性时，可以不使用后缀。比如命名时是：<code>MyAttributeAttribute</code>，使用时是<code>[MyAttribute]</code>。</p><h2 id="应用特性">应用特性</h2><p>通过在结构前放置<strong>特性片段</strong>来应用特性，<strong>特性片段</strong>由方括号包围特性名，有时候也包括参数列表。<br>可以为单个结构应用多个特性，有两种方式：</p><ol><li>独立的特性片段一个接一个。通常，它们彼此叠加，位于不同的行中。</li><li>单个特性片段，特性之间使用逗号分隔。<br>可以显式地标注特性，让特性应用到特殊的目标结构，例如：<code>[method: MyAttribute(parameter)]</code>。可用的特性目标有10个，分别是：<code>event</code>、<code>method</code>、<code>property</code>、<code>type</code>、<code>assembly</code>、<code>field</code>、<code>param</code>、<code>return</code>、<code>typevar</code>、<code>module</code>。<br>应用了特性的结构称为<strong>被特性装饰</strong>（decorated 或 adorned）。</li></ol><h2 id="建议了解的预定义的保留特性">建议了解的预定义的保留特性</h2><p><code>Obsolete</code>特性，<code>Conditional</code>特性，<code>CallerXxx</code>特性（调用者信息特性），<code>DebuggerStepThrough</code>特性（帮助调试），<code>Serializable</code>特性。</p><h2 id="自定义特性">自定义特性</h2><p>特性就是特殊的类。要自定义一个特性，请遵循命名规范，然后再让其派生自<code>System.Attribute</code>类即可。</p><div class="note note-warning">            <p>为安全起见，通常建议声明一个<code>sealed</code>的特性类。</p>          </div><p>由于特性持有目标的信息，所有特性类的共有成员只能是：字段、属性和构造函数。之所以应用特性时可以带参也可以不带参，是因为我们其实是在指定应该使用哪个构造函数来创建特性的实例。<br>既然我们可以为类应用特性，自然也能够为特性类应用特性。其中有一个很重要的预定义特性<code>AttributeUsage</code>，我们可以用它来限制将某个特性用在某个目标类型上（其实这里像前面提到的“显式地标注特性”），例如：<code>[ AttributeUsage( AttributeTarget.Method ) ] </code>。</p><h2 id="检查某个特性是否应用到了某个类上">检查某个特性是否应用到了某个类上</h2><p>我们可以使用<code>Type</code>对象的<code>IsDefined</code>方法来检测某个特性是否应用到了某个类上。此方法接受两个参数，第一个参数接受需要检查的特性的<code>Type</code>对象；第二个参数是<code>bool</code>类型的，它指示是否搜索类的继承树来查找这个特性。例如：<code>bool isDefined = new MyClass().GetType().IsDefined(typeof(MyAttributeAttribute), false);</code>。</p><hr>]]></content>
    
    
    <categories>
      
      <category>Learning Log</category>
      
      <category>CSharp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
      <tag>命名空间</tag>
      
      <tag>程序集</tag>
      
      <tag>dll</tag>
      
      <tag>反射</tag>
      
      <tag>特性</tag>
      
      <tag>attribute</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#笔记——模式匹配与运算符</title>
    <link href="/2023/09/07/CSharp-learning-5/"/>
    <url>/2023/09/07/CSharp-learning-5/</url>
    
    <content type="html"><![CDATA[<h1>模式匹配</h1><blockquote><p>看到模式匹配就想起被正则表达式<code>regex</code>折磨（悲<br>在<code>C#</code>中，我们可以使用<code>is</code>表达式、<code>switch</code>语句、<code>switch</code>表达式来将输入表达式与任意数量的特征匹配，最简单的例如：<code>if (sth is TargetClass)</code>。<br>就我个人而言，结合在一起的话感觉有点像是switch语法糖。<br><code>C#</code>提供了许多模式匹配，有：声明、类型、常量、关系、逻辑、属性、位置、var、弃元和列表模式等，这里仅对部分模式做出说明。</p></blockquote><h2 id="声明和类型模式">声明和类型模式</h2><p>使用声明和类型模式检查表达式的运行时类型是否与给定类型兼容。借助声明模式，还可以声明新的局部变量。例如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span> a = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">if</span> (a <span class="hljs-keyword">is</span> <span class="hljs-built_in">int</span> b)<br>&#123;<br>Console.WriteLine(<span class="hljs-string">$&quot;a is <span class="hljs-subst">&#123;b&#125;</span>.&quot;</span>);  <span class="hljs-comment">// output: a is 20.</span><br>&#125;<br><span class="hljs-keyword">if</span> (a <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span>)<br>&#123;<br>Console.WriteLine(<span class="hljs-string">$&quot;a is not null.&quot;</span>);  <span class="hljs-comment">// output: a is not null.</span><br>&#125;<br></code></pre></td></tr></table></figure><p>从<code>C#</code>9.0开始，可对此使用类型模式，如以下示例所示：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Vehicle</span> &#123;&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> : <span class="hljs-title">Vehicle</span> &#123;&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Truck</span> : <span class="hljs-title">Vehicle</span> &#123;&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TollCalculator</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">decimal</span> <span class="hljs-title">CalculateToll</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> Vehicle vehicle</span>)</span> =&gt; vehicle <span class="hljs-keyword">switch</span><br>    &#123;<br>        Car =&gt; <span class="hljs-number">2.00</span>m,  <span class="hljs-comment">// or Car _ =&gt; 2.00m,</span><br>        Truck =&gt; <span class="hljs-number">7.50</span>m, <span class="hljs-comment">// or Truck _ =&gt; 7.50m,</span><br>        <span class="hljs-literal">null</span> =&gt; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentNullException(<span class="hljs-keyword">nameof</span>(vehicle)),<br>        _ =&gt; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentException(<span class="hljs-string">&quot;Unknown type of a vehicle&quot;</span>, <span class="hljs-keyword">nameof</span>(vehicle)),<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="常量模式">常量模式</h2><p>可使用常量模式来测试表达式结果是否等于指定的常量，根据匹配的值返回对应的值：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">decimal</span> <span class="hljs-title">GetGroupTicketPrice</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> visitorCount</span>)</span> =&gt; visitorCount <span class="hljs-keyword">switch</span><br>&#123;<br>    <span class="hljs-number">1</span> =&gt; <span class="hljs-number">12.0</span>m,<br>    <span class="hljs-number">2</span> =&gt; <span class="hljs-number">20.0</span>m,<br>    <span class="hljs-number">3</span> =&gt; <span class="hljs-number">27.0</span>m,<br>    <span class="hljs-number">4</span> =&gt; <span class="hljs-number">32.0</span>m,<br>    <span class="hljs-number">0</span> =&gt; <span class="hljs-number">0.0</span>m,<br>    _ =&gt; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentException(<span class="hljs-string">$&quot;Not supported number of visitors: <span class="hljs-subst">&#123;visitorCount&#125;</span>&quot;</span>, <span class="hljs-keyword">nameof</span>(visitorCount)),<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="逻辑和关系模式">逻辑和关系模式</h2><p>从<code>C#</code>9.0开始，可使用关系模式将表达式结果与常量进行比较，当然，你也可以往其中加入逻辑运算符<code>and</code>、<code>or</code>、<code>not</code>来组成更为复杂的模式匹配：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#">Console.WriteLine(GetCalendarSeason(<span class="hljs-keyword">new</span> DateTime(<span class="hljs-number">2021</span>, <span class="hljs-number">3</span>, <span class="hljs-number">14</span>)));  <span class="hljs-comment">// output: spring</span><br>Console.WriteLine(GetCalendarSeason(<span class="hljs-keyword">new</span> DateTime(<span class="hljs-number">2021</span>, <span class="hljs-number">7</span>, <span class="hljs-number">19</span>)));  <span class="hljs-comment">// output: summer</span><br>Console.WriteLine(GetCalendarSeason(<span class="hljs-keyword">new</span> DateTime(<span class="hljs-number">2021</span>, <span class="hljs-number">2</span>, <span class="hljs-number">17</span>)));  <span class="hljs-comment">// output: winter</span><br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span> <span class="hljs-title">GetCalendarSeason</span>(<span class="hljs-params">DateTime date</span>)</span> =&gt; date.Month <span class="hljs-keyword">switch</span><br>&#123;<br>    &gt;= <span class="hljs-number">3</span> <span class="hljs-keyword">and</span> &lt; <span class="hljs-number">6</span> =&gt; <span class="hljs-string">&quot;spring&quot;</span>,<br>    &gt;= <span class="hljs-number">6</span> <span class="hljs-keyword">and</span> &lt; <span class="hljs-number">9</span> =&gt; <span class="hljs-string">&quot;summer&quot;</span>,<br>    &gt;= <span class="hljs-number">9</span> <span class="hljs-keyword">and</span> &lt; <span class="hljs-number">12</span> =&gt; <span class="hljs-string">&quot;autumn&quot;</span>,<br>    <span class="hljs-number">12</span> <span class="hljs-keyword">or</span> (&gt;= <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> &lt; <span class="hljs-number">3</span>) =&gt; <span class="hljs-string">&quot;winter&quot;</span>,<br>    _ =&gt; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentOutOfRangeException(<span class="hljs-keyword">nameof</span>(date), <span class="hljs-string">$&quot;Date with unexpected month: <span class="hljs-subst">&#123;date.Month&#125;</span>.&quot;</span>),<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="属性模式">属性模式</h2><p>可以使用属性模式将表达式的属性或字段与嵌套模式进行匹配：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">IsConferenceDay</span>(<span class="hljs-params">DateTime date</span>)</span> =&gt; date <span class="hljs-keyword">is</span> &#123; Year: <span class="hljs-number">2020</span>, Month: <span class="hljs-number">5</span>, Day: <span class="hljs-number">19</span> <span class="hljs-keyword">or</span> <span class="hljs-number">20</span> <span class="hljs-keyword">or</span> <span class="hljs-number">21</span> &#125;;<br></code></pre></td></tr></table></figure><p>还可以将运行时类型检查和变量声明添加到属性模式：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c#">Console.WriteLine(TakeFive(<span class="hljs-string">&quot;Hello, world!&quot;</span>));  <span class="hljs-comment">// output: Hello</span><br>Console.WriteLine(TakeFive(<span class="hljs-string">&quot;Hi!&quot;</span>));  <span class="hljs-comment">// output: Hi!</span><br>Console.WriteLine(TakeFive(<span class="hljs-keyword">new</span>[] &#123; <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span> &#125;));  <span class="hljs-comment">// output: 12345</span><br>Console.WriteLine(TakeFive(<span class="hljs-keyword">new</span>[] &#123; <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span> &#125;));  <span class="hljs-comment">// output: abc</span><br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span> <span class="hljs-title">TakeFive</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> input</span>)</span> =&gt; input <span class="hljs-keyword">switch</span><br>&#123;<br>    <span class="hljs-built_in">string</span> &#123; Length: &gt;= <span class="hljs-number">5</span> &#125; s =&gt; s.Substring(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>),<br>    <span class="hljs-built_in">string</span> s =&gt; s,<br><br>    ICollection&lt;<span class="hljs-built_in">char</span>&gt; &#123; Count: &gt;= <span class="hljs-number">5</span> &#125; symbols =&gt; <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(symbols.Take(<span class="hljs-number">5</span>).ToArray()),<br>    ICollection&lt;<span class="hljs-built_in">char</span>&gt; symbols =&gt; <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(symbols.ToArray()),<br><br>    <span class="hljs-literal">null</span> =&gt; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentNullException(<span class="hljs-keyword">nameof</span>(input)),<br>    _ =&gt; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentException(<span class="hljs-string">&quot;Not supported input type.&quot;</span>),<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="位置模式">位置模式</h2><p>我将其称之为元组模式匹配，因为它确实跟元组有关，使用元组表达式来将多个输入与各种模式进行匹配：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">decimal</span> <span class="hljs-title">GetGroupTicketPriceDiscount</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> groupSize, DateTime visitDate</span>)</span><br>    =&gt; (groupSize, visitDate.DayOfWeek) <span class="hljs-keyword">switch</span><br>    &#123;<br>        (&lt;= <span class="hljs-number">0</span>, _) =&gt; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentException(<span class="hljs-string">&quot;Group size must be positive.&quot;</span>),<br>        (_, DayOfWeek.Saturday <span class="hljs-keyword">or</span> DayOfWeek.Sunday) =&gt; <span class="hljs-number">0.0</span>m,<br>        (&gt;= <span class="hljs-number">5</span> <span class="hljs-keyword">and</span> &lt; <span class="hljs-number">10</span>, DayOfWeek.Monday) =&gt; <span class="hljs-number">20.0</span>m,<br>        (&gt;= <span class="hljs-number">10</span>, DayOfWeek.Monday) =&gt; <span class="hljs-number">30.0</span>m,<br>        (&gt;= <span class="hljs-number">5</span> <span class="hljs-keyword">and</span> &lt; <span class="hljs-number">10</span>, _) =&gt; <span class="hljs-number">12.0</span>m,<br>        (&gt;= <span class="hljs-number">10</span>, _) =&gt; <span class="hljs-number">15.0</span>m,<br>        _ =&gt; <span class="hljs-number">0.0</span>m,<br>    &#125;;<br></code></pre></td></tr></table></figure><h2 id="列表模式">列表模式</h2><p>从<code>C#11</code>开始，可以将数组或列表与模式的序列进行匹配：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span>[] numbers = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;;<br><br>Console.WriteLine(numbers <span class="hljs-keyword">is</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);  <span class="hljs-comment">// True</span><br>Console.WriteLine(numbers <span class="hljs-keyword">is</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>]);  <span class="hljs-comment">// False</span><br>Console.WriteLine(numbers <span class="hljs-keyword">is</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]);  <span class="hljs-comment">// False</span><br>Console.WriteLine(numbers <span class="hljs-keyword">is</span> [<span class="hljs-number">0</span> <span class="hljs-keyword">or</span> <span class="hljs-number">1</span>, &lt;= <span class="hljs-number">2</span>, &gt;= <span class="hljs-number">3</span>]);  <span class="hljs-comment">// True</span><br></code></pre></td></tr></table></figure><p>如果需要仅匹配开头或结尾的几个元素，可以使用切片模式<code>..</code>：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#">Console.WriteLine(<span class="hljs-keyword">new</span>[] &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> &#125; <span class="hljs-keyword">is</span> [&gt; <span class="hljs-number">0</span>, &gt; <span class="hljs-number">0</span>, ..]);  <span class="hljs-comment">// True</span><br><br>Console.WriteLine(<span class="hljs-keyword">new</span>[] &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span> &#125; <span class="hljs-keyword">is</span> [.., &gt; <span class="hljs-number">0</span>, &gt; <span class="hljs-number">0</span>]);  <span class="hljs-comment">// True</span><br><br>Console.WriteLine(<span class="hljs-keyword">new</span>[] &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span> &#125; <span class="hljs-keyword">is</span> [&gt;= <span class="hljs-number">0</span>, .., <span class="hljs-number">2</span> <span class="hljs-keyword">or</span> <span class="hljs-number">4</span>]);  <span class="hljs-comment">// True</span><br></code></pre></td></tr></table></figure><p>还可以在切片模式中嵌套子模式（比如嵌套逻辑模式什么的）。</p><h1>运算符</h1><p>其实这里主要记录一下对我来说比较陌生的运算符（或者说之前没学过的），所以会不全，要全请前往官方文档捏~</p><h2 id="（null包容）运算符"><code>!</code>（<code>null</code>包容）运算符</h2><p>一元后缀<code>!</code>运算符是<code>null</code>包容运算符或<code>null</code>抑制运算符。在已启用的可为空的注释上下文中，使用<code>null</code>包容运算符来取消上述表达式的所有可为<code>null</code>警告。</p><h2 id="和-运算符——Null合并操作符"><code>??</code>和<code>??=</code>运算符——Null合并操作符</h2><p>先从<code>??</code>运算符（<code>null</code>合并运算符）说起。如果左操作数的值不为<code>null</code>，则返回该值；否则，它会计算右操作数并返回其结果。如果左操作数的计算结果为非<code>null</code>，则<code>??</code>运算符不会计算其右操作数。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span>? a = <span class="hljs-literal">null</span>;<br>Console.WriteLine((a ?? <span class="hljs-number">3</span>));  <span class="hljs-comment">// output: 3</span><br></code></pre></td></tr></table></figure><p>然后是<code>??=</code>运算符（<code>null</code>合并赋值运算符）。仅当左操作数的计算结果为<code>null</code>时，<code>??=</code>才会将其右操作数的值赋值给其左操作数。如果左操作数的计算结果为非<code>null</code>，则<code>??=</code>不会计算其右操作数。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span>? a = <span class="hljs-literal">null</span>;<br>Console.WriteLine((a <span class="hljs-keyword">is</span> <span class="hljs-literal">null</span>));  <span class="hljs-comment">// output: True</span><br>a ??= <span class="hljs-number">3</span>;<br>Console.WriteLine(a);  <span class="hljs-comment">// output: 3</span><br></code></pre></td></tr></table></figure><h2 id="Null条件运算符-和">Null条件运算符<code>?.</code>和<code>?[]</code></h2><p>仅当操作数的计算结果为非<code>null</code>时，<code>null</code>条件运算符才对其操作数应用成员访问(<code>?.</code>)或元素访问(<code>?[]</code>)操作；否则，它会返回<code>null</code>。即：</p><ul><li>如果<code>a</code>的计算结果为<code>null</code>，则<code>a?.x</code>或<code>a?[x]</code>的结果为<code>null</code>。</li><li>如果<code>a</code>的计算结果为非<code>null</code>，则<code>a?.x</code>或<code>a?[x]</code>的结果将分别与<code>a.x</code>或<code>a[x]</code>的结果相同。</li></ul><h2 id="运算符-命名空间别名运算符"><code>::</code>运算符 - 命名空间别名运算符</h2><p>使用命名空间别名限定符<code>::</code>访问已设置别名的命名空间的的成员，比如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> forwinforms = System.Drawing;<br><span class="hljs-keyword">using</span> forwpf = System.Windows;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Converters</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> forwpf::<span class="hljs-function">Point <span class="hljs-title">Convert</span>(<span class="hljs-params">forwinforms::Point point</span>)</span> =&gt; <span class="hljs-keyword">new</span> forwpf::Point(point.X, point.Y);<br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>Learning Log</category>
      
      <category>CSharp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
      <tag>模式匹配</tag>
      
      <tag>运算符</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#笔记——可为空值/引用类型</title>
    <link href="/2023/09/01/CSharp-learning-4/"/>
    <url>/2023/09/01/CSharp-learning-4/</url>
    
    <content type="html"><![CDATA[<h1>可为空值类型</h1><h2 id="基本概念">基本概念</h2><p>可为空值类型<code>T?</code>表示其基础值类型<code>T</code>的所有值及额外的<code>null</code>值。比如<code>bool?</code>的值有：<code>true</code>、<code>false</code>和<code>null</code>，而普通的<code>bool</code>的值只有：<code>true</code>和<code>false</code>，因为基础值类型<code>T</code>本身不能是可为空的值类型。<br>任何可为空的值类型都是泛型<code>System.Nullable&lt;T&gt;</code>结构的实例，比如<code>int?</code>是<code>System.Nullable&lt;int&gt;</code>的实例。</p><h2 id="声明和赋值">声明和赋值</h2><p>声明就是基础值类型后加一个<code>?</code>，赋值则跟基础值类型一样。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">bool</span>? flag = <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><h2 id="检查可为空值类型的实例">检查可为空值类型的实例</h2><p>使用只读属性<code>Nullable&lt;T&gt;.HasValue</code>来检查和获取可为空值类型变量的值：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">if</span> (flag.HasValue)<br>&#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="从可为空的值类型转换为基础类型">从可为空的值类型转换为基础类型</h2><p>如果要将可为空值类型的值分配给不可以为空的值类型变量，则可以使用Null合并操作符<code>??</code>或者<code>Nullable&lt;T&gt;.GetValueOrDefault(T)</code>方法（此方法若不传递参数则使用基础值类型的默认值来替代<code>null</code>）：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span>? a = <span class="hljs-number">28</span>;<br><span class="hljs-built_in">int</span> b = a ?? <span class="hljs-number">-1</span>;<br>Console.WriteLine(<span class="hljs-string">$&quot;b is <span class="hljs-subst">&#123;b&#125;</span>.&quot;</span>);  <span class="hljs-comment">// output: b is 28</span><br><br><span class="hljs-built_in">int</span>? c = <span class="hljs-literal">null</span>;<br><span class="hljs-built_in">int</span> d = c.GetValueOrDefault(<span class="hljs-number">-1</span>);<br>Console.WriteLine(<span class="hljs-string">$&quot;d is <span class="hljs-subst">&#123;d&#125;</span>&quot;</span>);  <span class="hljs-comment">// output: d is -1</span><br></code></pre></td></tr></table></figure><p>也可以使用显式强制转换为不可为空的类型（注意如果可为空的值类型的值为<code>null</code>的话，显式强制转换将抛出<code>InvaildOperationException</code>异常）：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span>? n = <span class="hljs-literal">null</span>;<br><br><span class="hljs-comment">//int m1 = n;    // Doesn&#x27;t compile</span><br><span class="hljs-built_in">int</span> n2 = (<span class="hljs-built_in">int</span>)n; <span class="hljs-comment">// Compiles, but throws an exception if n is null</span><br></code></pre></td></tr></table></figure><h2 id="提升的运算符">提升的运算符</h2><p>预定义的一元运算符和二元运算符或值类型<code>T</code>支持的任何重载运算符也受相应的可为空值类型<code>T?</code>支持。只要有一个操作数为<code>null</code>，那么运算的结果就是<code>null</code>。这里的特殊例子是<code>bool?</code>类型，详情可以参考官方文档。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span>? a = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">int</span>? b = <span class="hljs-literal">null</span>;<br><br>a = a + b;  <span class="hljs-comment">// a is null</span><br></code></pre></td></tr></table></figure><p>对于比较运算符<code>&gt;</code>、<code>&gt;=</code>、<code>&lt;</code>、<code>&lt;=</code>，只要有一个操作数为<code>null</code>，返回的结果就是<code>false</code>。<br>对于相等运算符<code>==</code>，如果两个操作数都为<code>null</code>，则结果为<code>true</code>；如果只有一个操作数为<code>null</code>，则结果为<code>false</code>。<br>对于不等运算符<code>!=</code>，参考相等运算符<code>==</code>。</p><h2 id="装箱和取消装箱">装箱和取消装箱</h2><p>给可为空的值类型的实例进行装箱操作，实质上是对基础值类型<code>T</code>的对应值装箱：</p><ul><li>如果<code>HasValue</code>返回<code>false</code>，则生成空引用。</li><li>如果<code>HasValue</code>返回<code>true</code>，则基础值类型<code>T</code>的对应值将装箱，而不对<code>Nullable&lt;T&gt;</code>的实例进行装箱。</li></ul><h2 id="如何确定可为空的值类型">如何确定可为空的值类型</h2><p>下面的示例演示了如何确定<code>System.Type</code>实例是否表示已构造的可为空值类型：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#">Console.WriteLine(<span class="hljs-string">$&quot;int? is <span class="hljs-subst">&#123;(IsNullable(<span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">int</span>?)) ? <span class="hljs-string">&quot;nullable&quot;</span> : <span class="hljs-string">&quot;non nullable&quot;</span>)&#125;</span> value type&quot;</span>);<br>Console.WriteLine(<span class="hljs-string">$&quot;int is <span class="hljs-subst">&#123;(IsNullable(<span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">int</span>)) ? <span class="hljs-string">&quot;nullable&quot;</span> : <span class="hljs-string">&quot;non-nullable&quot;</span>)&#125;</span> value type&quot;</span>);<br><br><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">IsNullable</span>(<span class="hljs-params">Type type</span>)</span> =&gt; Nullable.GetUnderlyingType(type) != <span class="hljs-literal">null</span>;<br><br><span class="hljs-comment">// Output:</span><br><span class="hljs-comment">// int? is nullable value type</span><br><span class="hljs-comment">// int is non-nullable value type</span><br></code></pre></td></tr></table></figure><p>严格按照上面写就好了，先使用<code>typeof</code>运算符获取<code>System.type</code>实例，再使用<code>Nullable.GetUnderlyingType</code>方法来检查。如果想知道为什么，简洁来说就是<code>Object.GetType</code>方法获取到的<code>Type</code>实例无法区分，<code>is</code>运算符无法确定，详细的原因参考官方文档。</p><h1>可为空引用类型</h1><p>用来干什么？——用于降低代码导致运行时引发<code>System.NullReferenceException</code>异常（尝试取消引用空对象引用时引发的异常）的可能性。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// System.NullReferenceException</span><br><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Example</span><br>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>   &#123;<br>       <span class="hljs-built_in">int</span>[] values = <span class="hljs-literal">null</span>;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> ctr = <span class="hljs-number">0</span>; ctr &lt;= <span class="hljs-number">9</span>; ctr++)<br>          values[ctr] = ctr * <span class="hljs-number">2</span>;<br><br>       <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> <span class="hljs-keyword">value</span> <span class="hljs-keyword">in</span> values)<br>          Console.WriteLine(<span class="hljs-keyword">value</span>);<br>   &#125;<br>&#125;<br><span class="hljs-comment">// The example displays the following output:</span><br><span class="hljs-comment">//    Unhandled Exception:</span><br><span class="hljs-comment">//       System.NullReferenceException: Object reference not set to an instance of an object.</span><br><span class="hljs-comment">//       at Example.Main()</span><br></code></pre></td></tr></table></figure><p>在可为<code>null</code>的感知上下文中：</p><ul><li>引用类型<code>T</code>的变量必须用非<code>null</code>值进行初始化，并且不能为其分配可能为<code>null</code>的值。</li><li>引用类型<code>T?</code>的变量可以用<code>null</code>进行初始化，也可以分配<code>null</code>，但在取消引用之前必须对照<code>null</code>进行检查。</li><li>类型为<code>T?</code>的变量<code>m</code>在应用<code>null</code>包容运算符（<code>!</code>）时被认为是非空的，如<code>m!</code>。</li></ul><h2 id="限制">限制</h2><ul><li>可为空的引用类型不能用作基类或实现的接口</li><li>可为空的引用类型不能用于任何对象创建</li><li>可为空的引用类型不能用于任何类型测试表达式</li><li>可为空的引用类型不能是成员访问表达式的类型</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> MyClass : System.Object? <span class="hljs-comment">// not allowed</span><br>&#123;<br>&#125;<br><br><span class="hljs-keyword">var</span> nullEmpty = System.String?.Empty; <span class="hljs-comment">// Not allowed</span><br><span class="hljs-keyword">var</span> maybeObject = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>?(); <span class="hljs-comment">// Not allowed</span><br><span class="hljs-keyword">try</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (thing <span class="hljs-keyword">is</span> <span class="hljs-built_in">string</span>? nullableString) <span class="hljs-comment">// not allowed</span><br>        Console.WriteLine(nullableString);<br>&#125; <span class="hljs-keyword">catch</span> (Exception? e) <span class="hljs-comment">// Not Allowed</span><br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;error&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>Learning Log</category>
      
      <category>CSharp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
      <tag>可为空引用类型</tag>
      
      <tag>可为空值类型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Koishi来搭建机器人</title>
    <link href="/2023/08/22/Koishi-OneBot-HowToCreate/"/>
    <url>/2023/08/22/Koishi-OneBot-HowToCreate/</url>
    
    <content type="html"><![CDATA[<h1>一级标题（没想好）</h1><h2 id="问题">问题</h2><h3 id="获取T544-sign时出现错误-encoding-hex-invalid-byte-U-0069-‘i’">获取T544 sign时出现错误: encoding/hex: invalid byte: U+0069 ‘i’</h3><p>使用<code>1.1.0</code>版本的<code>unidbg-fetch-qsign</code>，或者使用<code>go-cqhttp</code>的<code>dev</code>分支（需要自行编译）。<br>参考来源：<a href="https://github.com/Mrs4s/go-cqhttp/issues/2304">[Bug]: 获取T544 sign时出现错误: encoding/hex: invalid byte: U+0069 ‘i’ #2304</a></p><h3 id="参考gocq的issue里边使用docker搭建qsign服务跑不起来">参考gocq的issue里边使用docker搭建qsign服务跑不起来</h3><p>用<code>docker container logs qsign</code>看看是不是没填<code>android_id</code>，是的话加个参数：<code>docker run -d --restart=always --name qsign -p 8080:8080 -e ANDROID_ID=3e9e151c8b55af91 xzhouqd/qsign:8.9.63</code>，记得替换成自己的<code>device.json</code>（这个文件就在<code>go-cqhttp</code>根目录下）里面的<code>android_id</code>。<br>参考来源：<a href="https://github.com/Mrs4s/go-cqhttp/issues/2242">签名服务器相关问题 #2242</a></p><hr>]]></content>
    
    
    <categories>
      
      <category>Essay</category>
      
      <category>OneBot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Koishi</tag>
      
      <tag>OneBot</tag>
      
      <tag>go-cqhttp</tag>
      
      <tag>unidbg-fetch-qsign</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#笔记——属性与索引器</title>
    <link href="/2023/08/15/CSharp-learning-3/"/>
    <url>/2023/08/15/CSharp-learning-3/</url>
    
    <content type="html"><![CDATA[<h1>属性</h1><h2 id="写法">写法</h2><p>示例代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassName</span><br>&#123;<br>AccessModifier Type _properName;<br>AccessModifier Type ProperName<br>&#123;<br><span class="hljs-keyword">set</span><br>&#123;<br><span class="hljs-comment">// 赋值代码</span><br>&#125;<br><span class="hljs-keyword">get</span><br>&#123;<br><span class="hljs-comment">// 取值代码</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>所有<code>set</code>访问器都用一个隐藏的，内建的参数（名为value）来传递要写入的数据，比如：<code>this._properName = value</code>。<br>如果是在接口中，那就不需要写方法体了：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">interface</span> <span class="hljs-title">IExampleInterface</span><br>&#123;<br>Type ProperName &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="自动生成">自动生成</h2><p>C#编译器现在能自动为属性生成代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassName</span><br>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> ProperName &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是只能声明只读自动属性，不能声明只写自动属性。</p><h2 id="用属性初始化对象">用属性初始化对象</h2><p>现在有这样一个类：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleClass</span><br>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> _a;<br><span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> _b;<br><span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> _c;<br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> A<br>&#123;<br><span class="hljs-keyword">set</span> &#123; <span class="hljs-keyword">this</span>._a = <span class="hljs-keyword">value</span>; &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> B<br>&#123;<br><span class="hljs-keyword">set</span> &#123; <span class="hljs-keyword">this</span>._b = <span class="hljs-keyword">value</span>; &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> C<br>&#123;<br><span class="hljs-keyword">set</span> &#123; <span class="hljs-keyword">this</span>._c = <span class="hljs-keyword">value</span>; &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建类的时候，可为具有<code>set</code>访问器的任何公共初始属性指定名称和值：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#">ExampleClass object1 = <span class="hljs-keyword">new</span> ExampleClass &#123; A = <span class="hljs-number">1</span> &#125;;<br>ExampleClass object1 = <span class="hljs-keyword">new</span> ExampleClass &#123; A = <span class="hljs-number">1</span>, B = <span class="hljs-number">2</span> &#125;;<br>ExampleClass object1 = <span class="hljs-keyword">new</span> ExampleClass &#123; A = <span class="hljs-number">1</span>, B = <span class="hljs-number">2</span>, C = <span class="hljs-number">3</span> &#125;;<br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>先运行构造器，再对属性进行设置</p>          </div><h1>索引器</h1><p>索引器和属性很相似，只不过属性封装的是类中的一个值（字段），而索引器封装的是一组值（数组）。</p><h2 id="自我感觉很棒的例子">自我感觉很棒的例子</h2><p>有时候我们会将<code>int</code>类型的一个变量来作为二进制标志集合使用，但是操作和可读性上不会太好，比如<code>bits &amp;= ~(1 &lt;&lt; 5)</code>或是<code>bits |= (1 &lt;&lt; 5)</code>，我们或许想要这么干：<code>bits[5] = true</code>，那么这个时候索引器就派上用场了：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">struct</span> IntBits<br>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> bits;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">IntBits</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> initialBitValue</span>)</span><br>&#123;<br>bits = initialBitValue;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-keyword">this</span> [ <span class="hljs-built_in">int</span> index ]<br>&#123;<br><span class="hljs-keyword">get</span><br>&#123;<br><span class="hljs-keyword">return</span> (bit &amp; (<span class="hljs-number">1</span> &lt;&lt; index)) != <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">set</span><br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">value</span>)  <span class="hljs-comment">// 如果value为true，就将指定的位设为1；否则设为0</span><br>bits |= (<span class="hljs-number">1</span> &lt;&lt; index);<br><span class="hljs-keyword">else</span><br>bits &amp;= ~(<span class="hljs-number">1</span> &lt;&lt;index);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个时候，就能使用上面提到的访问数组的方式来访问<code>int</code>变量的每一位了：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span> x = <span class="hljs-number">126</span>;<br>IntBits bits = <span class="hljs-keyword">new</span> IntBits(x);<br><span class="hljs-built_in">bool</span> peek = bits[<span class="hljs-number">6</span>];  <span class="hljs-comment">// 获取索引6的bool值</span><br>bits[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 将索引0的位设为1</span><br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>Learning Log</category>
      
      <category>CSharp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
      <tag>属性</tag>
      
      <tag>索引器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#笔记——垃圾回收与资源管理</title>
    <link href="/2023/08/14/CSharp-learning-2/"/>
    <url>/2023/08/14/CSharp-learning-2/</url>
    
    <content type="html"><![CDATA[<h1>垃圾回收与资源管理</h1><h2 id="析构器">析构器</h2><p>其实就是析构方法。语法就是类名前加一个<code>~</code>，比如<code>~ClassName()&#123; ... &#125;</code><br><strong>最重要的一点，析构器只有在对象被垃圾回收时才运行</strong><br>编译器内部自动将析构器转换成对<code>Object.Finalize</code>方法的一个重写版本的调用，比如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassName</span><br>&#123;<br>~ClassName() &#123; ... &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>就等价于：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassName</span><br>&#123;<br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Finalize</span>()</span> <br>&#123;<br><span class="hljs-keyword">try</span> &#123; ... &#125;<br><span class="hljs-keyword">finally</span> &#123; <span class="hljs-keyword">base</span>.Finalize(); &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="垃圾回收">垃圾回收</h2><h3 id="垃圾回收什么时候进行？">垃圾回收什么时候进行？</h3><p>可以确定的是，在对象不再需要的时候进行。<strong>但是垃圾回收不一定在对象不再需要之后立刻进行</strong>。<code>CLR</code>会自行判断执行垃圾回收的时机。<br>例如，在它认为可用内存不够的时候，或者堆的大小超过系统定义的阈值的时候。</p><h3 id="垃圾回收器的工作原理">垃圾回收器的工作原理</h3><p>大体步骤如下：</p><ol><li>构造所有可达对象的一个映射（map）。为此，它会反复跟随对象中的引用字段。垃圾回收器会非常小心地构造映射，确保循环引用不会造成无限递归。任何不在映射中的对象肯定不可达。</li><li>检查是否有任何不可达对象包含一个需要运行的析构器（运行析构器的过程称为“终结”）。需终结的任何不可达对象都放到一个称为freachable（F-reachable）的特殊队列中。</li><li>回收剩下的不可达对象（即不需要终结的对象）。为此，它会在堆中向下面移动可达的对象，对堆进行“碎片整理”，释放位于堆顶部的内存。一个可达对象被移动之后，会更新对该对象的所有引用。</li><li>然后，允许其他线程恢复执行。</li><li>在一个独立的线程中，对需要终结的不可达对象执行终结操作。</li></ol><h2 id="资源管理">资源管理</h2><p>当我们使用某些资源时，比如内存、数据库、文件句柄等这种稀缺资源，应该尽快释放，所以这个时候就需要我们手动释放资源。<br>即通过自己写的资源清理（disposal）方法来实现资源释放。可显式调用类的资源清理方法，从而控制释放资源的时机。<br>简单举个例子，比如我们使用<code>TextReader</code>类来从顺序输入流读取字符时，读取完毕后应该及时调用<code>Close()</code>方法释放资源：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#">TextReader reader = <span class="hljs-keyword">new</span> StreamReader(filename);<br><span class="hljs-built_in">string</span> line;<br><span class="hljs-keyword">while</span> ((line = reader.ReadLine()) != <span class="hljs-literal">null</span>)<br>&#123;<br>Console.WriteLine(line);<br>&#125;<br>reader.Close();<br></code></pre></td></tr></table></figure><p>但是它其实不是异常安全的，因为如果在<code>reader.ReadLine()</code>或其他地方出现异常的话，就不会执行<code>reader.Close()</code>释放文件句柄了。<br>或许我们会想到<code>try...catch...finally...</code>语句，这确实是一种解决方法，然而也存在更好的方案。</p><h3 id="using语句">using语句</h3><p><code>using</code>语句提供了一个脉络清晰的机制来控制资源的生存期。可以创建一个对象，这个对象会在<code>using</code>语句块结束时销毁。<br><code>using</code>语句的用法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> (type variable = initialization)<br>&#123;<br>statementBlock<br>&#125;<br></code></pre></td></tr></table></figure><p>它等价于下面的代码块：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c#">&#123;<br>type variable = initialization;<br><span class="hljs-keyword">try</span><br>&#123;<br>statementBlock<br>&#125;<br><span class="hljs-keyword">finally</span><br>&#123;<br><span class="hljs-keyword">if</span> (variable != <span class="hljs-literal">null</span>)<br>&#123;<br>((IDisposable)variable).Dispose();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这也说明<code>using</code>语句声明的变量必须实现<code>IDisposable</code>接口。<code>IDisposable</code>接口在<code>System</code>命名空间中，只包含一个名为<code>Dispose</code>的方法。<code>Dispose</code>方法的作用是清理对象使用的任何资源。</p><h3 id="IDisposable接口的实现">IDisposable接口的实现</h3><p>下面是实现<code>IDisposable</code>接口的类的推荐写法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span> : <span class="hljs-title">IDisposable</span><br>&#123;<br><span class="hljs-keyword">private</span> Resource scarce;  <span class="hljs-comment">// 要管理和清理的稀缺资源</span><br><span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> disposed = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 指示资源是否已被清理的标志</span><br>...<br>~Example()<br>&#123;<br><span class="hljs-keyword">this</span>.Dispose(<span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Dispose</span>()</span><br>&#123;<br><span class="hljs-keyword">this</span>.Dispose(<span class="hljs-literal">true</span>);<br>GC.SuppressFinalize(<span class="hljs-keyword">this</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Dispose</span>(<span class="hljs-params"><span class="hljs-built_in">bool</span> disposing</span>)</span><br>&#123;<br><span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.disposed)<br>&#123;<br><span class="hljs-comment">// 在此释放大型托管资源</span><br>...<br>&#125;<br><span class="hljs-comment">// 在此释放非托管资源</span><br>...<br><span class="hljs-keyword">this</span>.disposed = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SomeBehavior</span>()  <span class="hljs-comment">// 示例方法</span></span><br>&#123;<br>checkIfDisposed();  <span class="hljs-comment">// 每个常规方法都要调用这个方法来检查对象是否已经清理</span><br>...<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkIfDisposed</span>()</span><br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.disposed)<br>&#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ObjectDisposedException(<span class="hljs-string">&quot;对象已经清理！&quot;</span>);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面解释一下这么写的好处：</p><ul><li>受保护的<code>Dispose</code>方法可以安全地多次调用，因为变量<code>disposed</code>指出方法以前是否运行过，这样可以防止在并发调用方法时资源被多次清理。</li><li>受保护的<code>Dispose</code>方法支持托管资源（比如大的数组）和非托管资源（比如文件句柄）的清理。如果<code>disposing</code>参数为<code>true</code>，该方法肯定是从公共<code>Dispose()</code>方法中调用的，所以托管和非托管资源都会被释放。如果<code>disposing</code>参数为<code>false</code>，该方法肯定是从析构器中调用的，而且垃圾回收器正在终结对象，所以不需要释放托管资源，因为它们将由（或者已经由）垃圾回收器处理：在这种情况下只需要释放非托管资源。</li><li>静态<code>GC.SuppressFinalize</code>方法可以阻止垃圾回收器为这个对象调用析构器，因为对象已经终结。<br>这里还有另外一种线程安全的方式写代码：</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Dispose</span>()</span><br>&#123;<br><span class="hljs-keyword">lock</span>(<span class="hljs-keyword">this</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (!disposed)<br>&#123;<br>...<br>&#125;<br><span class="hljs-keyword">this</span>.disposed = <span class="hljs-literal">true</span>;<br>GC.SuppressFinalize(<span class="hljs-keyword">this</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>lock</code>语句旨在阻止一个代码块同时在不同线程上运行。像这样使用锁能确保线程安全，但对性能有一些影响。</p><hr>]]></content>
    
    
    <categories>
      
      <category>Learning Log</category>
      
      <category>CSharp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
      <tag>垃圾回收</tag>
      
      <tag>资源管理</tag>
      
      <tag>GC（Garbage Collection）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue2.x 文档笔记-3</title>
    <link href="/2023/06/25/vue-learning-5/"/>
    <url>/2023/06/25/vue-learning-5/</url>
    
    <content type="html"><![CDATA[<h1>Vue2.x 文档笔记-3-深入了解组件部分</h1><h2 id="组件注册">组件注册</h2><h3 id="全局注册">全局注册</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;component-name&#x27;</span>, &#123; ... &#125;)<br></code></pre></td></tr></table></figure><h3 id="局部注册">局部注册</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>  <span class="hljs-attr">components</span>: &#123;<br>    component-<span class="hljs-attr">a</span>: &#123;<br>      <span class="hljs-attr">template</span>:<span class="hljs-string">&quot;&lt;h1&gt;Hello!&lt;/h1&gt;&quot;</span><br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="Prop">Prop</h2><h3 id="prop类型">prop类型</h3><p>我们可以为每个prop指定值类型，这和python的类型提示十分相似，那就是在属性名后面加冒号，然后再带上期待的值类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">props</span>: &#123;<br>  <span class="hljs-attr">title</span>: <span class="hljs-title class_">String</span>,<br>  <span class="hljs-attr">likes</span>: <span class="hljs-title class_">Number</span>,<br>  <span class="hljs-attr">isPublished</span>: boolean<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="传递静态或动态Prop">传递静态或动态Prop</h3><p>如果我们想告诉prop我们将要传递的值不是字符串，而是一个JavaScript表达式的话，就需要使用<code>v-bind</code>指令：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 即便 `false` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;</span><br><span class="hljs-comment">&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span> <span class="hljs-attr">v-bind:is-published</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 即便数组是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;</span><br><span class="hljs-comment">&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span> <span class="hljs-attr">v-bind:comment-ids</span>=<span class="hljs-string">&quot;[234, 266, 273]&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="单向数据流">单向数据流</h3><p>我们不应该一个子组件内部改变prop。如果子组件中需要用到<code>prop</code>的值，可以定义一个本地的data property或者计算属性：</p><ol><li><p>定义本地data property：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;initialCounter&#x27;</span>],<br><span class="hljs-attr">data</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">counter</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">initialCounter</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>定义计算属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;size&#x27;</span>],<br><span class="hljs-attr">computed</span>: &#123;<br>  <span class="hljs-attr">normalizedSize</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span>.<span class="hljs-title function_">trim</span>().<span class="hljs-title function_">toLowerCase</span>()<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="prop验证">prop验证</h3><p>在本节开头的prop类型其实就是prop验证。如果传入的值不满足需求，那么Vue会在浏览器控制台<strong>警告</strong>你（注意了，只是警告）。</p><p>当然prop验证还支持很多定制验证，如多个可能的类型、必填、带默认值等等。</p><h3 id="非Prop的Attribute">非Prop的Attribute</h3><p>一个非prop的attribute是指传向一个组件，但是该组件并没有相应prop定义的attribute。</p><p><strong>虽然组件中没有相关定义，但是这个attribute仍会自动添加到组件的根元素上。</strong></p><h4 id="替换-合并已有的Attribute">替换/合并已有的Attribute</h4><p>对于绝大多数attribute来说，从外部提供给组件的值会替换掉组件内部设置好的值，比如<code>type</code>属性，假设现在有一个组件的根元素上是<code>type=&quot;date&quot;</code>，但如果我们提供了<code>type=&quot;input&quot;</code>的话，那这个组件就会从日期选择器变成输入框，而这不是我们想要的结果。</p><p>但是有两个例外，<code>class</code>和<code>style</code>并不会替换，而是合并。比如组件内部提供了<code>class=&quot;red&quot;</code>，而外部传入了一个<code>class=&quot;big&quot;</code>，那么最终得到的是<code>class=&quot;red big&quot;</code>。</p><h4 id="禁用Attribute继承">禁用Attribute继承</h4><p>如果不希望组件的根元素继承attribute，可以在组件的选项中设置<code>inheritAttrs: false</code>。</p><h2 id="自定义事件">自定义事件</h2><h3 id="事件名">事件名</h3><p><strong>事件名请使用kebab-case命名规范进行命名</strong></p><h3 id="自定义组件的v-model">自定义组件的v-model</h3><p>一个组件上的<code>v-model</code>默认会利用名为<code>value</code>的prop和名为<code>input</code>的事件，但是我们可以对其进行自定义：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;example&#x27;</span>, &#123;<br>  <span class="hljs-attr">model</span>: &#123;<br>    <span class="hljs-attr">prop</span>: <span class="hljs-string">&#x27;prop-name&#x27;</span>,<br>    <span class="hljs-attr">event</span>: <span class="hljs-string">&#x27;event-name&#x27;</span><br>  &#125;,<br>  ...<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="sync修饰符">.sync修饰符</h3><p>我们可以对一个prop进行“双向绑定”，即子组件的值变更时也能够反馈到父组件上。</p><p>假设现在有一个子组件，内含一个名为<code>title</code>的prop，我们想在这个<code>title</code>的值更新时，让父组件的某个值也进行更新，那就可以用<code>update:myPropName</code>的模式触发事件来实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;update:title&#x27;</span>, newTitle)<br></code></pre></td></tr></table></figure><p>在父组件中监听这个事件并根据需要更新即可：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">text-document</span></span><br><span class="hljs-tag">  <span class="hljs-attr">v-bind:title</span>=<span class="hljs-string">&quot;doc.title&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">v-on:update:title</span>=<span class="hljs-string">&quot;doc.title = $event&quot;</span></span><br><span class="hljs-tag">&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">text-document</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这种模式的缩写就是<code>.sync</code>修饰符：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">text-document</span> <span class="hljs-attr">v-bind:title.sync</span>=<span class="hljs-string">&quot;doc.title&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">text-document</span>&gt;</span><br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>注意带有 <code>.sync</code> 修饰符的 <code>v-bind</code> <strong>不能</strong>和表达式一起使用！</p>          </div><h2 id="插槽">插槽</h2><h3 id="具名插槽">具名插槽</h3><p>这个功能使得我们能够在组件里面创建很多个插槽而互不干扰、正常渲染。在创建插槽时，使用<code>&lt;slot&gt;</code>元素的 <code>name</code>属性为这个插槽命名：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;first&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;second&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后在为这些具名插槽提供内容时，就在<code>&lt;template&gt;</code>元素中使用<code>v-slot</code>指令来指定我们需要传入的插槽：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">component-name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:first</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:scecond</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">component-name</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="作用域插槽">作用域插槽</h3><p>其实就是让父组件能访问到子组件中的某些data的功能。比如子组件中有一个<code>user</code>data，要让这个data在父级的插槽内容可用，可以将<code>user</code>作为<code>&lt;slot&gt;</code>元素的一个attribute绑定上去：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">v-bind:user</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>绑定在<code>&lt;slot&gt;</code>元素上的attribute被称为<strong>插槽prop</strong>。</p><p>在父组件中，我们可以使用带值的<code>v-slot</code>来定义我们提供的插槽prop的名字，并且使用该插槽prop：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">component-name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:default</span>=<span class="hljs-string">&quot;slotProps&quot;</span>&gt;</span><br>    &#123;&#123; slotProps.user.name &#125;&#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">component-name</span>&gt;</span><br></code></pre></td></tr></table></figure><div class="note note-warning">            <p><code>default</code>其实就是默认插槽，插槽不带名就等于<code>&lt;slot name=&quot;default&quot;&gt;</code></p>          </div><h3 id="具名插槽的缩写">具名插槽的缩写</h3><p>跟<code>v-on</code>和<code>v-bind</code>一样，<code>v-slot</code>也有缩写，即把参数之前的所有内容 (<code>v-slot:</code>) 替换为字符<code>#</code>。例如<code>v-slot:header</code>可以被重写为<code>#header</code>。</p><hr>]]></content>
    
    
    <categories>
      
      <category>Learning Log</category>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Html</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue2.x 文档笔记-2</title>
    <link href="/2023/06/23/vue-learning-4/"/>
    <url>/2023/06/23/vue-learning-4/</url>
    
    <content type="html"><![CDATA[<h1>Vue2.x 文档笔记-2</h1><h2 id="计算属性和侦听器">计算属性和侦听器</h2><h3 id="计算属性">计算属性</h3><p>计算属性在Vue实例的<code>computed</code>里边进行声明，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>  ...<br>  <span class="hljs-attr">computed</span>: &#123;<br>    <span class="hljs-attr">reversedMsg</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>()<br>    &#125;<br>  &#125;,<br>  ...<br>&#125;)<br></code></pre></td></tr></table></figure><p>在上面<code>reversedMsg</code>属性后面写的函数其实就是<code>reversedMsg</code>属性的<code>getter</code>方法。</p><p>和直接写方法不一样，<strong>计算属性是基于它们的响应式依赖进行缓存的</strong>，也就是说，如果原来的值不发生改变（比如上面的<code>message</code>），那么计算属性会立即返回之前的计算结果，而不会重复执行方法。</p><p>注意计算属性是基于响应式变量的！像：<code>return Date.now()</code>中的<code>Date.now()</code>不是响应式依赖，计算属性不会更新！</p><p>我们也可以手动为计算属性添加一个<code>setter</code>方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">computed</span>: &#123;<br>  <span class="hljs-attr">reversedMsg</span>: &#123;<br>    <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        ...<br>    &#125;,<br>    <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        ...<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="侦听器">侦听器</h3><p>侦听器就是会监控一个变量（数据）的变化然后执行回调函数的东西。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的</p><h2 id="列表渲染">列表渲染</h2><h3 id="v-for">v-for</h3><p>就当成是Vue提供的一个<code>foreach</code>语句吧，可以用它来基于一个数组来渲染一个列表，比如我们向后端发送请求，后端返回给我们数据库里的数据，我们要把这些数据渲染到表格或者列表上，就可以使用<code>v-for</code>指令，当然了，如果返回的是对象列表（数组），取出来的是一个对象，那我们也可以访问这个对象的拥有的属性：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in items&quot;</span>&gt;</span> &#123;&#123; item.value &#125;&#125; <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>v-for</code>还支持一个可选的第二个参数，即当前项的索引（这里顺序和python相反，注意区分）：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item, index in items&quot;</span>&gt;</span> &#123;&#123; index &#125;&#125;：&#123;&#123; item.value &#125;&#125; <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="维护状态">维护状态</h3><p>当 Vue 正在更新使用 <code>v-for</code> 渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。</p><p>为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 <code>key</code> attribute：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in items&quot;</span> <span class="hljs-attr">v-bind:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span>&#123;&#123; item.value &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>总结一下：除非真的很卡（性能很差），不然就乖乖给每个<code>v-for</code>写<code>:key</code>，以避免莫名其妙的bug。</p><h3 id="显示过滤-排序后的结果">显示过滤/排序后的结果</h3><p>如果想将数组里的数据进行过滤或者排序，就对原数组使用<code>filter</code>方法，这个方法会返回一个新数组。当然了，为了保持响应式，可以创建一个计算属性，来返回过滤或排序后的数组，而且这样做不会改变原数组：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><br></code></pre></td></tr></table></figure><p>但是在嵌套循环<code>v-for</code>中，计算属性就不适用了（毕竟我们没办法为数组中的数组来创建一个计算属性），所以在嵌套循环中，直接使用方法即可。（这也说明了方法和计算属性就是互通的，前者泛用广，后者性能高）：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">```<br><br>## 事件处理<br><br>### v-on<br><br>`v-on`指令用于监听DOM事件，如果监听的事件被触发，那么将执行用于处理这个事件的代码。这些代码可以是表达式，也可以是一个事件处理方法。<br><br>```html<br>&lt;button @click=<span class="hljs-string">&quot;cnt += 1&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><h3 id="事件处理方法">事件处理方法</h3><p>如果代码过多的话，就考虑用方法来对事件进行响应。对此，<code>v-on</code>可以接受一个需要调用的方法名称（<code>@</code>是<code>v-on:</code>的缩写！）：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;greet&quot;</span>&gt;</span>Greet<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">...<br><span class="hljs-attr">methods</span>: &#123;<br>  <span class="hljs-attr">greet</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) &#123;<br>    ...<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="事件修饰符">事件修饰符</h3><p>Vue.js为<code>v-on</code>提供了一些特殊的事件修饰符，可以方便我们快速实现一些逻辑，比如阻止事件传播、让提交事件不再重载页面和点击事件只触发一次等等：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.once</span>=<span class="hljs-string">&quot;doThis&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="按键修饰符">按键修饰符</h3><p>Vue允许为<code>v-on</code>监听键盘事件时添加按键修饰符：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-on:keyup.enter</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="系统修饰符">系统修饰符</h3><p>这些修饰符则是用来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。详细参考<a href="https://v2.cn.vuejs.org/v2/guide/events.html#%E7%B3%BB%E7%BB%9F%E4%BF%AE%E9%A5%B0%E9%94%AE">官方文档</a>。</p><h2 id="组件基础">组件基础</h2><p>其实就像安卓的那些小组件，需要时可以把这些小组件拖到桌面用，而Vue的组件也是如此，如果我们的界面需要某一个组件，那么可以直接引入这个组件，而且可以在同一个界面创建多个同一组件的实例，实例之间的数据互不影响。</p><blockquote><p>组件是可以复用的Vue实例</p></blockquote><h3 id="组件注册">组件注册</h3><p>我们可以通过<code>Vue.component('component-name', &#123; ... &#125;)</code>来<strong>全局注册</strong>一个组件。</p><h3 id="data必须是一个函数">data必须是一个函数</h3><p><strong>一个组件的 <code>data</code> 选项必须是一个函数</strong>，这样每个实例可以维护一份被返回对象的独立的拷贝：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">data</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">count</span>: <span class="hljs-number">0</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="通过Prop向子组件传递数据">通过Prop向子组件传递数据</h3><p>当一个值传递给一个 prop attribute 的时候，它就变成了那个组件实例的一个property。我们可以用一个 <code>props</code> 选项将我们需要传递的数据名包含在该组件可接受的<code>prop</code>列表中，并且我们可以像访问<code>data</code>中的值一样访问<code>props</code>中的<code>prop</code>，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;blog-test&#x27;</span>, &#123;<br>  <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;title&#x27;</span>],<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>要把数据作为一个自定义<code>attribute</code>传递进来，直接在组件标签中为对应的<code>prop</code>赋值即可：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">blog-test</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;My First Blog&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-test</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们还可以使用<code>v-bind</code>来动态传递<code>prop</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">blog-test</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;post in posts&quot;</span> <span class="hljs-attr">v-bind:key</span>=<span class="hljs-string">&quot;post.id&quot;</span> <span class="hljs-attr">v-bind:title</span>=<span class="hljs-string">&quot;post.title&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-test</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="单个根元素">单个根元素</h3><p>组件中只能拥有一个根元素，所以如果组件的模板中有多个html标签，我们就需要将这些标签用一个父元素包裹起来，比如<code>&lt;div&gt;</code>标签：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;blog-post&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-html</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="监听子组件事件">监听子组件事件</h3><p>子组件可以使用<code>$emit</code>来发射（直译的，你也可以理解为广播一个事件、抛出一个事件等等）一个事件，比如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;$emit(&#x27;component-button-click&#x27;)&quot;</span>&gt;</span>Click here<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后在父组件中，同样地用<code>v-on</code>指令来监听子组件实例地任意事件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">blog-test</span> <span class="hljs-attr">v-on:component-button-click</span>=<span class="hljs-string">&quot;doSomething&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-test</span>&gt;</span><br></code></pre></td></tr></table></figure><p>有时候不止需要触发事件，还需要抛出一些值，这时可以使用<code>$emit</code>的第二个参数来提供这个值：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;$emit(&#x27;component-button-click&#x27;, 0.1)&quot;</span>&gt;</span>Click here<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后当父级组件监听这个事件的时候，我们可以通过<code>$event</code>访问到被抛出的这个值：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">blog-test</span> <span class="hljs-attr">v-on:component-button-click</span>=<span class="hljs-string">&quot;count += $event&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-test</span>&gt;</span><br></code></pre></td></tr></table></figure><p>又或是成为作为第一个参数传入事件处理方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">methods</span>: &#123;<br>  <span class="hljs-attr">doSomething</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> += value<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们还可以在组件上使用<code>v-model</code>，不过这部分稍微有点复杂，涉及到<code>v-model</code>会被解释成什么样子（会被解释成<code>v-bind</code>和<code>v-on </code>），所以建议看<a href="https://v2.cn.vuejs.org/v2/guide/components.html#%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B8%8A%E4%BD%BF%E7%94%A8-v-model">官方文档</a>。</p><h3 id="通过插槽分发内容">通过插槽分发内容</h3><p>如果我们要向组件里面插入额外的<code>html</code>标签，那就需要给组件添加一个插槽，如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">blog-test</span> <span class="hljs-attr">v-on:component-button-click</span>=<span class="hljs-string">&quot;doSomething&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span><br>        Hello!<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">blog-test</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果要使组件能够正常工作，那么在组件的模板中，应该加入<code>&lt;slot&gt;</code>标签：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;blog-test&#x27;</span>, &#123;<br>  ...<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string">    &lt;div&gt;</span><br><span class="hljs-string">      &lt;slot&gt;&lt;/slot&gt;</span><br><span class="hljs-string">    &lt;/div&gt;</span><br><span class="hljs-string">  `</span><br>  ...<br>&#125;)<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>Learning Log</category>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Html</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue2.x 文档笔记-1</title>
    <link href="/2023/06/22/vue-learning-3/"/>
    <url>/2023/06/22/vue-learning-3/</url>
    
    <content type="html"><![CDATA[<h1>Vue2.x 文档笔记-1</h1><h2 id="数据与方法">数据与方法</h2><h3 id="让对象不再响应">让对象不再响应</h3><p>如果想让某一个对象不再进行响应式，可以用<code>Object.freeze()</code>方法。</p><h3 id="有用的-watch方法">有用的<code>$watch</code>方法</h3><p>Vue实例暴露了一些有用的实例属性与方法，就是带有前缀<code>$</code>的那些（这样以便与用户定义的属性区分开来）。</p><p>这其中有一个很有用的：<code>$watch</code>方法，它可以观察一个变量的变化，然后执行一个回调函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">vm.$watch(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">newVal, oldVal</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newVal, oldVal);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="条件渲染">条件渲染</h2><h3 id="v-if">v-if</h3><p><code>v-if</code>指令用于条件性地渲染一块内容，这块内容只会在指令地表达式返回<code>truthy</code>值得时候被渲染（比如内容是一条文本，表达式返回<code>true</code>时就“看得见”这条文本，返回<code>false</code>时就“看不见”）</p><div class="note note-warning">            <p>注意<code>v-if</code>是决定是否渲染这一块内容，而不是是否显示这一块内容，更多相关信息请看下面的<code>v-show</code>小节。</p>          </div><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;type === &#x27;A&#x27;&quot;</span>&gt;</span>This is a text.<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure><p>此外，<code>vue</code>还提供了<code>v-else</code>和<code>v-else=if</code>指令。</p><p>如果我们需要切换多个元素，可以在那些能包裹多个元素的元素上使用<code>v-if</code>指令，比如：<code>&lt;div&gt;</code>和<code>&lt;template&gt;</code>元素。</p><p><code>vue</code>会复用已有的元素而不是从头开始渲染，如果要告诉<code>vue</code>这两个元素是完全独立的，请不要复用它们，那么可以给这个元素添加一个具有唯一值的<code>key</code> attribute：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;loginType === &#x27;username&#x27;&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>Username<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Enter your username&quot;</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;username-input&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-else</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>Email<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Enter your email address&quot;</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;email-input&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在上面的代码中，只有<code>label</code>元素被复用，而<code>input</code>元素则在每次切换时被重新渲染。</p><div class="note note-warning">            <p><strong>不推荐</strong>同时使用<code>v-if</code>和<code>v-for</code>。请查阅<a href="https://v2.cn.vuejs.org/v2/style-guide/#%E9%81%BF%E5%85%8D-v-if-%E5%92%8C-v-for-%E7%94%A8%E5%9C%A8%E4%B8%80%E8%B5%B7-%E5%BF%85%E8%A6%81">风格指南</a>以获取更多信息。——官方文档</p>          </div><h3 id="v-show">v-show</h3><p>这个指令也是根据条件来展示元素，不过和<code>v-if</code>不同的是，带有<code>v-show</code>指令的元素<strong>始终会被渲染并保留在DOM中</strong>，<code>v-show</code> 只是简单地切换元素的 CSS property <code>display</code>。（也就是说页面上是已经加载出来这个元素了，只不过看不见）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;ok&quot;</span>&gt;</span><br>    Hello!<br><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>注意，<code>v-show</code>不支持<code>&lt;template&gt;</code>元素。</p>          </div><h3 id="小结">小结</h3><p>如果需要非常频繁地切换，则使用 <code>v-show</code> 较好；如果在运行时条件很少改变，则使用 <code>v-if</code> 较好。</p><h2 id="表单输入绑定">表单输入绑定</h2><h3 id="v-model">v-model</h3><p>使用<code>v-model</code>指令来在表单的<code>&lt;input&gt;</code>、<code>&lt;select&gt;</code>等元素上创建双向数据绑定。它负责监听用户的输入事件以更新数据，而且会根据控件类型自动选取正确的方法来更新元素。只要知道表单元素应该是都能用这个进行数据绑定就对了。</p><p>下面的代码是一份大杂烩代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>&lt;meta charset=&quot;utf-8&quot;&gt;<br>&lt;title&gt;&lt;/title&gt;<br>&lt;script src=&quot;vue.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;div id=&quot;app&quot;&gt;<br>&lt;div id=&quot;example-1&quot;&gt;<br>&lt;input v-model=&quot;message&quot; placeholder=&quot;edit me&quot;&gt;<br>&lt;p&gt;Message is: &#123;&#123; message &#125;&#125;&lt;/p&gt;<br>&lt;textarea v-model=&quot;message2&quot; placeholder=&quot;add multiple lines&quot;&gt;&lt;/textarea&gt;<br>&lt;p style=&quot;white-space: pre-line;&quot;&gt;&#123;&#123; message2 &#125;&#125;&lt;/p&gt;<br>&lt;br /&gt;<br><br>&lt;div style=&quot;margin-top:30px;&quot;&gt;<br>&lt;input type=&quot;checkbox&quot; id=&quot;jack&quot; value=&quot;Jack&quot; v-model=&quot;checkedNames&quot;&gt;<br>&lt;label for=&quot;jack&quot;&gt;Jack&lt;/label&gt;<br>&lt;input type=&quot;checkbox&quot; id=&quot;john&quot; value=&quot;John&quot; v-model=&quot;checkedNames&quot;&gt;<br>&lt;label for=&quot;john&quot;&gt;John&lt;/label&gt;<br>&lt;input type=&quot;checkbox&quot; id=&quot;mike&quot; value=&quot;Mike&quot; v-model=&quot;checkedNames&quot;&gt;<br>&lt;label for=&quot;mike&quot;&gt;Mike&lt;/label&gt;<br>&lt;br&gt;<br>&lt;span&gt;Checked names: &#123;&#123; checkedNames &#125;&#125;&lt;/span&gt;<br>&lt;/div&gt;<br><br>&lt;div style=&quot;margin-top:30px;&quot;&gt;<br>&lt;input type=&quot;radio&quot; id=&quot;one&quot; value=&quot;One&quot; v-model=&quot;picked&quot;&gt;<br>&lt;label for=&quot;one&quot;&gt;One&lt;/label&gt;<br>&lt;br&gt;<br>&lt;input type=&quot;radio&quot; id=&quot;two&quot; value=&quot;Two&quot; v-model=&quot;picked&quot;&gt;<br>&lt;label for=&quot;two&quot;&gt;Two&lt;/label&gt;<br>&lt;br&gt;<br>&lt;span&gt;Picked: &#123;&#123; picked &#125;&#125;&lt;/span&gt;<br>&lt;/div&gt;<br><br>&lt;div style=&quot;margin-top: 20px; margin-bottom: 20px;&quot;&gt;<br>&lt;select v-model=&quot;selected&quot;&gt;<br>&lt;option v-for=&quot;option in options&quot; v-bind:value=&quot;option.value&quot;&gt;<br>&#123;&#123; option.text &#125;&#125;<br>&lt;/option&gt;<br>&lt;/select&gt;<br>&lt;br&gt;<br>&lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt;<br>&lt;/div&gt;<br>&lt;div style=&quot;margin-top: 20px; margin-bottom: 20px;&quot;&gt;<br>&lt;input v-model.number=&quot;age&quot; type=&quot;number&quot;/&gt;<br>&lt;/div&gt;<br>&lt;button type=&quot;button&quot; @click=&quot;submit&quot;&gt;提交&lt;/button&gt;<br>&lt;/div&gt;<br><br>&lt;/div&gt;<br>&lt;script type=&quot;text/javascript&quot;&gt;<br>var vm = new Vue(&#123;<br>el : &quot;#app&quot;,<br>data : &#123;<br>message : &quot;test&quot;,<br>message2 :&quot;hi&quot;,<br>checkedNames : [&#x27;Jack&#x27;, &#x27;John&#x27;],<br>picked : &quot;Two&quot;,<br>selected: &quot;A&quot;,<br>options: [<br>&#123; text: &#x27;One&#x27;, value: &#x27;A&#x27;&#125;,<br>&#123; text: &#x27;Two&#x27;, value: &#x27;B&#x27;&#125;,<br>&#123; text: &#x27;Three&#x27;, value: &#x27;C&#x27;&#125;,<br>],<br>age: 0,<br>&#125;,<br>methods: &#123;<br>submit : function () &#123;<br>console.log(this.message);<br>var postObj = &#123;<br>msg2 : this.message2,<br>names : this.checkedNames,<br>picked : this.picked<br>&#125;;<br>console.log(postObj);<br>&#125;<br>&#125;<br>&#125;);<br>&lt;/script&gt;<br>&lt;style type=&quot;text/css&quot;&gt;<br><br>&lt;/style&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br><br></code></pre></td></tr></table></figure><h3 id="修饰符">修饰符</h3><h4 id="lazy">.lazy</h4><p>如果想让<code>v-model</code>在<code>change</code>事件而不是<code>input</code>事件触发后进行数据同步，那就添加<code>lazy</code>修饰符。</p><h4 id="number">.number</h4><p>如果想自动将用户的输入值转为数值类型，就添加<code>.number</code>修饰符</p><h4 id="trim">.trim</h4><p>如果要自动过滤用户输入的首尾空白字符，就添加<code>.trim</code>修饰符</p><h2 id="生命周期">生命周期</h2><p>有了生命周期钩子，就使得在Vue运行的每个阶段，我们都能够来添加并执行一些代码。</p><p>比如<code>created</code>钩子，会在实例创建完成后被立即同步调用，在这一步中，实例已完成对选项的处理，数据帧听、计算属性、方法、事件/侦听器的回调函数都被配置完毕。示例代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>  <span class="hljs-attr">data</span>: &#123;<br>    <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;Created!&quot;</span><br>  &#125;,<br>  <span class="hljs-attr">created</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// `this` 指向 vm 实例</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span>)<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>不要在选项 property 或回调上使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions">箭头函数</a>，比如 <code>created: () =&gt; console.log(this.a)</code> 或 <code>vm.$watch('a', newValue =&gt; this.myMethod())</code>。因为箭头函数并没有 <code>this</code>，<code>this</code> 会作为变量一直向上级词法作用域查找，直至找到为止，经常导致 <code>Uncaught TypeError: Cannot read property of undefined</code> 或 <code>Uncaught TypeError: this.myMethod is not a function</code> 之类的错误。——官方文档</p>          </div><h2 id="模板语法">模板语法</h2><h3 id="插值">插值</h3><h4 id="文本">文本</h4><p>数据绑定最常见的形式就是使用“Mustache”语法 (双大括号) 的文本插值：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Message: &#123;&#123; msg &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure><p>还可以使用<code>v-once</code>指令让其变为一次性插值，即使数据改变，插值也不会更新：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-once</span>&gt;</span>Message: &#123;&#123; msg &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="原始HTML">原始HTML</h4><p>我们可以使用<code>v-html</code>指令来输出原始HTML：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Using v-html directive: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-html</span>=<span class="hljs-string">&quot;rawHtml&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="v-bind动态绑定attribute">v-bind动态绑定attribute</h4><p><code>v-bind</code>指令允许我们动态地绑定某个html标签所具有的属性：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-bind:disabled</span>=<span class="hljs-string">&quot;isButtonDisabled&quot;</span>&gt;</span>Button<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="使用JavaScript表达式">使用JavaScript表达式</h4><p>对于所有的数据绑定，Vue.js都提供了完全的JavaScript表达式支持：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html">&#123;&#123; number + 1 &#125;&#125;<br><br>&#123;&#123; ok ? &#x27;YES&#x27; : &#x27;NO&#x27; &#125;&#125;<br><br>&#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;<br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind:id</span>=<span class="hljs-string">&quot;&#x27;list-&#x27; + id&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>但是要注意，<strong>每个绑定都只能包含单个表达式</strong>。</p><h3 id="指令">指令</h3><p>指令就是带有<code>v-</code>前缀的attribute，而指令attribute的值预期是单个JavaScript表达式（<code>v-for</code>例外）。当表达式的值改变时，指令会将其产生的连带影响，<strong>响应式</strong>地作用于DOM。</p><h4 id="参数">参数</h4><p>一些指令能够接受一个“参数”，在命令之后以冒号表示，比如：<code>v-bind</code>、<code>v-on</code>指令。</p><h4 id="动态参数">动态参数</h4><p>直接看例子：<code>&lt;a v-bind:[attributeName]=&quot;url&quot;&gt;...&lt;/a&gt;</code>，如果<code>attributeName=&quot;href&quot;</code>，那么这里前面的标签就等价于：<code>&lt;a v-bind:href=&quot;url&quot;&gt;...&lt;/a&gt;</code>，这就是动态参数。</p><h4 id="修饰符-2">修饰符</h4><p>修饰符是以半角句号<code>.</code>指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。我们在前面的表单输入绑定的修饰符小节已经见过了适用于<code>v-model</code>的修饰符。</p><h3 id="缩写">缩写</h3><p>Vue为<code>v-bind</code>和<code>v-on</code>这两个最常用的指令，提供了特定简写：</p><h4 id="v-bind缩写">v-bind缩写</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">:href</span>=<span class="hljs-string">&quot;url&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="v-on缩写">v-on缩写</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;doSomething&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Learning Log</category>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Html</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>electron-learning-1</title>
    <link href="/2023/06/11/electron-learning-1/"/>
    <url>/2023/06/11/electron-learning-1/</url>
    
    <content type="html"><![CDATA[<h1>创建第一个Electron应用</h1><h2 id="electron，启动">electron，启动</h2><div class="note note-warning">            <p>需要安装<code>Node.js</code>！请使用<code>node -v</code>和<code>npm -v</code>检查！</p>          </div><p>可以直接使用脚手架创建。用<code>npm init</code>。</p><div class="note note-warning">            <p>注意：<code>entry point</code>应为<code>main.js</code>！</p>          </div><p>然后将<code>electron</code>包安装到应用的开发依赖中：<code>npm install --save-dev electron</code>。<br>安装好后，接着在<code>package.json</code>中增加一条命令：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;start&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;electron .&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="创建页面">创建页面</h2><p><strong>在<code>Electron</code>中，各个窗口显示的内容可以是本地<code>HTML</code>文件，也可以是一个远程<code>url</code>。</strong><br>所以可以现在本地写一些<code>html</code>先，比如官网的例子<code>index.html</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;Content-Security-Policy&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;default-src &#x27;self&#x27;; script-src &#x27;self&#x27;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>你好!<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>你好!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    我们正在使用 Node.js <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;node-version&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>,<br>    Chromium <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;chrome-version&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>,<br>    和 Electron <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;electron-version&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>.<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="在窗口中打开页面">在窗口中打开页面</h2><p>要把页面加载进应用窗口中，需要两个<code>electron</code>模块：</p><ul><li><code>app</code>模块，控制应用程序的事件生命周期</li><li><code>BrowserWindow</code>模块，创建和管理应用程序窗口<br>在<code>main.js</code>文件头部将它们导入作为<code>CommonJS</code>模块：<code>const &#123; app, BrowserWindow &#125; = require('electron')</code><br>然后写一个新的方法，在这个方法中，创建一个新的<code>BrowserWindow</code>实例，并把<code>index.html</code>加载到这个实例中：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">createWindow</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> win = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BrowserWindow</span>(&#123;<br>    <span class="hljs-attr">width</span>: <span class="hljs-number">800</span>,<br>    <span class="hljs-attr">height</span>: <span class="hljs-number">600</span><br>  &#125;)<br><br>  win.<span class="hljs-title function_">loadFile</span>(<span class="hljs-string">&#x27;index.html&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>然后调用这个方法就可以创建窗口了。只有在<code>app</code>模块的<code>ready</code>事件被激发后才能创建浏览器窗口。可以通过使用<code>app.whenReady()</code>来监听此事件，并在成功后调用创建窗口的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">app.<span class="hljs-title function_">whenReady</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">createWindow</span>()<br>&#125;)<br></code></pre></td></tr></table></figure><p>##打包和分发应用程序<br>可以使用<code>Electron Forge</code>。执行以下命令：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> install --save-dev @electron-forge/cli<br>npx electron-forge <span class="hljs-keyword">import</span><br></code></pre></td></tr></table></figure><p>完成上述步骤后，再执行<code>npm run make</code>即可创建可分发的应用程序，软件包在<code>out</code>文件夹下。</p><hr>]]></content>
    
    
    <categories>
      
      <category>Learning Log</category>
      
      <category>Electron</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Elctron</tag>
      
      <tag>JavaScript</tag>
      
      <tag>Html</tag>
      
      <tag>Css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>excel-essay-1</title>
    <link href="/2023/06/10/excel-essay-1/"/>
    <url>/2023/06/10/excel-essay-1/</url>
    
    <content type="html"><![CDATA[<h1>写法</h1><p>自增：<code>=ROW(1:1) &amp;&quot;栋&quot;</code><br>一行数据根据另外一行变化：<code>=&quot;1梯&quot;&amp;AG26&amp;&quot;户&quot;</code></p><hr>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>动态规划专题</title>
    <link href="/2023/06/08/algorithm-dp/"/>
    <url>/2023/06/08/algorithm-dp/</url>
    
    <content type="html"><![CDATA[<h1>为什么写这篇博客</h1><p>哈哈，那是因为今天下午笔试题第一题就是最基本的动态规划（最简单那档），虽然我看出来了这是道动态规划，但是我没写出来（其实也有一部分原因是我写前面的逻辑题太慢了，然后后面要写两份岗位的笔试）。<br>真的很苦露西啊！一出面试的地方脸都直接变了。复杂的心情描写就不写了，真的很难受，当场就觉得自己算法能力有多么差了。<br>所以决定好好学习动态规划了。</p><h1>让我心如死灰的那道题</h1><p>这里只做简单描述：</p><ul><li>有一排柜子，你可以看到柜子里的糖果数量，你可以打开其中的柜子，但是打开后，这个被打开的柜子旁边的柜子都不能打开了，设计一个方案以拿到最多的糖果<br>一眼撇过去就知道是动态规划，当然这里容易混淆的就是贪心。为什么不是贪心呢？因为贪心往往只能找到局部最优解，而无法看到全局最优解。而动态规划就是将大问题细分为小问题，小问题再细分下去，最后小问题解决了归上去给大问题得出解，所以能够找到全局最优解。<br>问题是我看得出来，但是没办法构造dp数组，结果就是做不出来（悲)<br>现在重新梳理题目，尝试自己想出来思路：<br>假设<code>i</code>代表当前第几个柜子，<code>dp[i]</code>代表前第<code>i</code>个柜子能拿到的最多的糖果数量。那么大问题就是到最后一个柜子时，我们能够拿到的最多的糖果数量。<br>显而易见，小问题就是前一个柜子能拿到的最多的糖果数量，以此类推。那么最小的问题就是：第一个柜子时能拿到的最多的糖果数量，很明显这个问题的答案时<code>dp[0] = candies[0]</code>。<br>得到了最小问题的解，归上去（就像递归不是吗？），第二小的问题就是：前两个柜子能拿到的最多的糖果数量<code>dp[1]</code>是多少。这也很好推了，因为我们要么拿第一个柜子的糖果，要么拿第二个柜子的糖果，所以选更多糖果的那个柜子就好了。<br>接下来就是第三小的问题了，<code>dp[2]</code>怎么求呢？其实也很简单。仔细读题，<strong>一个柜子被打开后，这个被打开的柜子旁边的柜子都不能打开了</strong>，也就是说，要么这个柜子的前一个柜子被打开了，那我们就无法取得当前柜子里的糖果了，而此时可以知道<code>dp[2] = dp[1]</code>；要么前一个柜子没打开，那为了拿到更多的糖果，我们肯定选择打开当前柜子，也就是有<code>dp[2] = dp[0] + candies[2]</code>。<br>当然我们要选出最多糖果数量的那种情况，所以有：<code>dp[2] = max(dp[1], dp[0] + candies[2])</code>。所以，我们能够得到公式：<code>dp[i] = max(dp[i - 1], dp[i - 2] + candies[i])</code>。<br>可能有人会觉得，你选了当前柜子你不用考虑后面那个柜子不能选的情况吗？当然不需要了，动态规划主打的就是一个每次找到的都是当前情况的全局最优解，如果当前的柜子是最后一个柜子，你难道还会考虑它后面的“柜子”吗？</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CandyCabinet</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">openCabinets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candies)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numCabinets</span> <span class="hljs-operator">=</span> candies.length;<br>        <span class="hljs-keyword">if</span> (numCabinets == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (numCabinets == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> candies[<span class="hljs-number">0</span>];<br>        &#125;<br><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[numCabinets];<br>        dp[<span class="hljs-number">0</span>] = candies[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">1</span>] = Math.max(candies[<span class="hljs-number">0</span>], candies[<span class="hljs-number">1</span>]);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; numCabinets; i++) &#123;<br>            dp[i] = Math.max(dp[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>] + candies[i]);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[numCabinets - <span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] candies = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>&#125;;  <span class="hljs-comment">// 柜子中的糖果数量</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxCandies</span> <span class="hljs-operator">=</span> openCabinets(candies);<br>        System.out.println(<span class="hljs-string">&quot;最多的糖果数量: &quot;</span> + maxCandies);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>顺便给出<code>python</code>版本的解：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">open_cabinets</span>(<span class="hljs-params">candies</span>):<br>    num_cabinets = <span class="hljs-built_in">len</span>(candies)<br>    <span class="hljs-keyword">if</span> num_cabinets == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> num_cabinets == <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> candies[<span class="hljs-number">0</span>]<br><br>    <span class="hljs-comment"># 使用动态规划记录每个柜子的最优解</span><br>    dp = [<span class="hljs-number">0</span>] * num_cabinets<br>    dp[<span class="hljs-number">0</span>] = candies[<span class="hljs-number">0</span>]<br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(candies[<span class="hljs-number">0</span>], candies[<span class="hljs-number">1</span>])<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, num_cabinets):<br>        dp[i] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>] + candies[i])<br><br>    <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h1>其他的动态规划</h1><h2 id="70-爬楼梯">70. 爬楼梯</h2><p>很经典的一题，你一次可以上一阶或者两阶楼梯，你有多少种方法爬n阶楼梯。<br>那么对于<code>i</code>，表示当前为<code>i</code>阶楼梯，所以<code>dp[i]</code>表示爬<code>i</code>阶楼梯共有几种方法。可以知道<code>dp[0] = 1</code>，<code>dp[1] = 1</code>，<code>dp[2] = 2</code>，而<code>dp[2] = dp[0] + dp[1]</code>，即<code>dp[i] = dp[i - 2] + dp[i - 1]</code>。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">ClimbStairs</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> n</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[n];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i++)<br>        &#123;<br>            dp[i] = dp[i - <span class="hljs-number">2</span>] + dp[i - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>看了下题解，发现还可以使用滚动数组优化：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">ClimbStairs</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> n</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> p = <span class="hljs-number">0</span>, q = <span class="hljs-number">0</span>, r = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            p = q;<br>            q = r; <br>            r = p + q;<br>        &#125;<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>题解上还说了这题如果n太大的话就需要使用矩阵快速幂了，当然我这种数学渣渣看的不是很明白，估计之后有空再去了解。</p><h2 id="509-斐波那契数">509. 斐波那契数</h2><p>这题没什么好说的吧，公式都给了，直接转换成代码。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Fib</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> n</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> p = <span class="hljs-number">0</span>, q = <span class="hljs-number">1</span>, r = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            p = q; q = r; r = p + q;<br>        &#125;<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="746-使用最小花费爬楼梯">746. 使用最小花费爬楼梯</h2><p>这题和拿最多糖果那题十分相似，但又有些许不同。对于我们所处的一阶楼梯，我们需要支付当前楼梯的费用，然后选择往上一阶还是两阶，所以要清楚，这里的楼梯顶部并不是<code>cost.Length</code>，而是<code>cost.Length + 1</code>。<br>比如第一个例子中，<code>cost[2] = 20</code>，此时我们所处位置仍然不算楼梯顶部，真正的楼梯顶部是“<code>cost[3]</code>”，这在之后我们的得到最终问题的答案时要注意。<br>既然清楚了题目的意思，就尝试把<code>dp[i]</code>写出来吧！在这里，<code>dp[i]</code>代表当我们处于第<code>i</code>个楼梯上时，我们需要的最少费用，所以我们到达这个楼梯时，其实并不需要支付当前楼梯的费用的，只有我们要从这个楼梯往上爬时，才需要加上当前楼梯的费用。<br>所以得到：<code>dp[0] = dp[1] = 0</code>，我们能够选择从下标为<code>0</code>或者<code>1</code>的楼梯往上爬。对于<code>dp[2]</code>，很容易推出：<code>dp[2] = min(dp[0] + cost[0], dp[1] + cost[1])</code>，因为要到达下标为<code>2</code>的楼梯，有两种方法，走一步和走两步，分别支付之前所在楼梯的费用，再从中取最小值即可。<br>所以推导公式就出来了：<code>dp[i] = min(dp[i - 2] + cost[i - 2], dp[i - 1]+ cost[i - 1])</code>。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">MinCostClimbingStairs</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] cost</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> n = cost.Length;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> Math.Min(cost[<span class="hljs-number">0</span>], cost[<span class="hljs-number">1</span>]);<br>        <span class="hljs-built_in">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = dp[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)<br>        &#123;<br>            dp[i] = Math.Min(dp[i - <span class="hljs-number">2</span>] + cost[i - <span class="hljs-number">2</span>], dp[i - <span class="hljs-number">1</span>] + cost[i - <span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>Solution</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Leetcode</tag>
      
      <tag>Java</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#笔记——委托、事件、泛型、迭代器和LINQ</title>
    <link href="/2023/06/01/CSharp-learning-1/"/>
    <url>/2023/06/01/CSharp-learning-1/</url>
    
    <content type="html"><![CDATA[<h1>委托（Delegate）</h1><h2 id="委托是什么？">委托是什么？</h2><blockquote><p>委托是一种引用类型，表示对具有特定参数列表和返回类型的方法的引用。——C#编程指南<br>用我的话来说，就是可以按顺序执行一系列方法的对象。<br>比如：现在有两个类，一个“肉铺”类，一个“蔬菜店”类，这两个类里边各自拥有名为“取得肉”和“取得蔬菜”的方法。现在你妈让你去“取得肉”和“取得蔬菜”，也就是调用这两个方法，我们可以怎么办呢？<br>最直接的办法就是直接调用，那要是你妈天天都有这个需求怎么办呢？我们或许会新创建一个方法，并把这两个方法放入这个方法的方法体中，然后调用这个新方法。当然，我们也能够创建一个委托，并把这两个方法交给委托，然后执行委托。</p></blockquote><h2 id="委托的食用方法">委托的食用方法</h2><h3 id="最基本的食用方法">最基本的食用方法</h3><p>首先我们需要使用<code>delegate</code>关键字来<strong>创建委托类型</strong>，然后<strong>实例化委托</strong>，最后<strong>调用委托</strong>。上面例子的完整代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">namespace</span> <span class="hljs-title">Learning1</span><br>&#123;<br>    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        <span class="hljs-comment">// 创建委托类型</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Del</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>)</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            <span class="hljs-built_in">string</span> myName = <span class="hljs-string">&quot;Maple&quot;</span>;<br>            <span class="hljs-comment">// 实例化一个委托</span><br>            Del myDel = ButcherShop.GetMeet;<br>            <span class="hljs-comment">// 为委托多添加一个方法</span><br>            myDel += Greengrocer.GetVegetables;<br>            <span class="hljs-comment">// 调用委托</span><br>            myDel(myName);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 肉铺类，内含一个“取得肉”的静态方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ButcherShop</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GetMeet</span>(<span class="hljs-params">String name</span>)</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">$&quot;Congratulations!<span class="hljs-subst">&#123;name&#125;</span> get meet!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 蔬菜商类，内涵一个“取得蔬菜”的静态方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Greengrocer</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GetVegetables</span>(<span class="hljs-params">String name</span>)</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">$&quot;Congratulations!<span class="hljs-subst">&#123;name&#125;</span> get vegetables!&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行成功后，显示如下：</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">Congratulations!Maple get meet!<br>Congratulations!Maple get vegetables!<br><br>E:\Project\C#\CSharpLearning\Learning1\Learning1\bin\Debug\net6.<span class="hljs-number">0</span>\Learning1.exe (进程 <span class="hljs-number">30208</span>)已退出，代码为 <span class="hljs-number">0</span>。<br>要在调试停止时自动关闭控制台，请启用“工具”-&gt;“选项”-&gt;“调试”-&gt;“调试停止时自动关闭控制台”。<br>按任意键关闭此窗口. . .<br></code></pre></td></tr></table></figure><h3 id="委托作为实参或分配给一个属性">委托作为实参或分配给一个属性</h3><p>因为实例化的委托也是一个对象，所以可以将其作为实参传入方法中，又或者将其分配给一个属性。</p><blockquote><p>这允许方法接受委托作为参数并在稍后调用委托。 这被称为异步回调，是在长进程完成时通知调用方的常用方法。——C#编程指南<br>依旧是上面的例子，不过这次要和朋友去买菜了，所以创建一个新方法<code>BuyWithFriend</code>，该方法接受三个参数，前两个是买菜人的名字，最后一个参数是一个委托。代码如下：</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuyWithFriend</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name1, <span class="hljs-built_in">string</span> name2, Del del</span>)</span><br>&#123;<br>del(name1 + <span class="hljs-string">&quot; and &quot;</span> + name2);<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在主程序使用<code>BuyWithFriend(myName, &quot;Tom&quot;, myDel)</code>来调用新方法，得到如下输出：</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">Congratulations!Maple and Tom get meet!<br>Congratulations!Maple and Tom get vegetables!<br><br>E:\Project\C#\CSharpLearning\Learning1\Learning1\bin\Debug\net6.<span class="hljs-number">0</span>\Learning1.exe (进程 <span class="hljs-number">21864</span>)已退出，代码为 <span class="hljs-number">0</span>。<br>要在调试停止时自动关闭控制台，请启用“工具”-&gt;“选项”-&gt;“调试”-&gt;“调试停止时自动关闭控制台”。<br>按任意键关闭此窗口. . .<br></code></pre></td></tr></table></figure><h3 id="委托也是派生类">委托也是派生类</h3><p>委托类型派生自<code>System.Delegate</code>，而且是密封的(<code>sealed</code>)。我们可以在委托上调用<code>Delegate</code>类定义的方法和属性，比如查询委托调用列表中方法的数量：<code>Console.WriteLine(myDel.GetInvocationList().GetLength(0));</code>。</p><blockquote><p>调用列表中具有多个方法的委托派生自<code>MulticastDelegate</code>，该类属于<code>System.Delegate</code>的子类。</p></blockquote><h2 id="协变和逆变">协变和逆变</h2><p><s>其实这一块应该放在泛型里面说的（？）。</s><br>所谓协变，就是定义的委托类型的返回类型，接受其派生类。如下代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CovarianceAndContravariance</span><br>&#123;<br><span class="hljs-function"><span class="hljs-built_in">delegate</span> T <span class="hljs-title">Factory</span>&lt;<span class="hljs-keyword">out</span> <span class="hljs-title">T</span>&gt;()</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> Dog <span class="hljs-title">MakeDog</span>()</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Dog();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>&#123;<br><span class="hljs-comment">// Covariance</span><br>Factory&lt;Dog&gt; dogMaker = MakeDog;<br>Factory&lt;Animal&gt; animalMaker = dogMaker;<br><br>Console.WriteLine(animalMaker().Legs.ToString());<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span><br>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Legs = <span class="hljs-number">4</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> : <span class="hljs-title">Animal</span><br>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>在这里，如果把<code>out</code>关键字去掉的话，编译是不通过的，这是因为<code>Factory&lt;Dog&gt;</code>并不是从<code>Factory&lt;Animal&gt;</code>派生的。<br>所以这里的<code>out</code>关键字标记委托声明中的类型参数，可以让编译器知道<strong>在这里类型参数只用作于输出值</strong>。这就是协变。<br>那逆变其实和协变差不多，就是<strong>在期望传入基类时允许传入派生对象的特性</strong>，就叫逆变。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CovarianceAndContravariance</span><br>&#123;<br><span class="hljs-function"><span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Action1</span>&lt;<span class="hljs-keyword">in</span> <span class="hljs-title">T</span>&gt;(<span class="hljs-params">T a</span>)</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ActOnAnimal</span>(<span class="hljs-params">Animal a</span>)</span><br>&#123;<br>Console.WriteLine(a.Legs);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>&#123;<br><span class="hljs-comment">// Contravariance</span><br>Action1&lt;Animal&gt; act1 = ActOnAnimal;<br>Action1&lt;Dog&gt; dog1 = act1;<br><br>dog1(<span class="hljs-keyword">new</span> Dog());<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span><br>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Legs = <span class="hljs-number">4</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> : <span class="hljs-title">Animal</span><br>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>有关协变和逆变的理解这块我个人可能不是很透彻，建议参考参考其他文章。</p><h2 id="强委托类型">强委托类型</h2><p>其实就是<code>.Net Core</code>框架里边的泛型委托类型，包括<code>Action</code>、<code>Func</code>和<code>Predicate</code>。<br>其中<code>Action</code>类型用于任何具有<code>void</code>返回类型的委托类型：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Action</span>()</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Action</span>&lt;<span class="hljs-keyword">in</span> <span class="hljs-title">T</span>&gt;(<span class="hljs-params">T arg</span>)</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Action</span>&lt;<span class="hljs-keyword">in</span> <span class="hljs-title">T1</span>, <span class="hljs-keyword">in</span> <span class="hljs-title">T2</span>&gt;(<span class="hljs-params">T1 arg1, T2 arg2</span>)</span>;<br><span class="hljs-comment">// Other variations removed for brevity.</span><br></code></pre></td></tr></table></figure><p><code>Func</code>类型用于具有返回值的委托类型：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> TResult <span class="hljs-title">Func</span>&lt;<span class="hljs-keyword">out</span> <span class="hljs-title">TResult</span>&gt;()</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> TResult <span class="hljs-title">Func</span>&lt;<span class="hljs-keyword">in</span> <span class="hljs-title">T1</span>, <span class="hljs-keyword">out</span> <span class="hljs-title">TResult</span>&gt;(<span class="hljs-params">T1 arg</span>)</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> TResult <span class="hljs-title">Func</span>&lt;<span class="hljs-keyword">in</span> <span class="hljs-title">T1</span>, <span class="hljs-keyword">in</span> <span class="hljs-title">T2</span>, <span class="hljs-keyword">out</span> <span class="hljs-title">TResult</span>&gt;(<span class="hljs-params">T1 arg1, T2 arg2</span>)</span>;<br><span class="hljs-comment">// Other variations removed for brevity</span><br></code></pre></td></tr></table></figure><p><code>Predicate</code>则用于返回单个值的测试结果：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">Predicate</span>&lt;<span class="hljs-keyword">in</span> <span class="hljs-title">T</span>&gt;(<span class="hljs-params">T obj</span>)</span>;<br></code></pre></td></tr></table></figure><blockquote><p>当然你也许已经注意到了，<code>Action</code>就是逆变的应用，<code>Func</code>就是协变的应用。</p></blockquote><h2 id="委托的常见模式">委托的常见模式</h2><h3 id="LINQ查询表达式">LINQ查询表达式</h3><p>LINQ查询表达式模式依赖于其所有功能的委托，比如<code>Where</code>方法的原型：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title">IEnumerable</span>&lt;<span class="hljs-title">TSource</span>&gt; <span class="hljs-title">Where</span>&lt;<span class="hljs-title">TSource</span>&gt; (<span class="hljs-params"><span class="hljs-keyword">this</span> IEnumerable&lt;TSource&gt; source, Func&lt;TSource, <span class="hljs-built_in">bool</span>&gt; predicate</span>)</span>;<br></code></pre></td></tr></table></figure><h3 id="通过委托生成自己的组件">通过委托生成自己的组件</h3><p>下面定义了一个可用于大型系统中日志消息的组件。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">public</span> <span class="hljs-built_in">enum</span> Severity<br>&#123;<br>    Verbose,<br>    Trace,<br>    Information,<br>    Warning,<br>    Error,<br>    Critical<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Logger</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Action&lt;<span class="hljs-built_in">string</span>&gt;? WriteMessage;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Severity LogLevel &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125; = Severity.Warning;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LogMessage</span>(<span class="hljs-params">Severity severity, <span class="hljs-built_in">string</span> component, <span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (severity &lt; LogLevel)<br>            <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-keyword">var</span> outputMsg = <span class="hljs-string">$&quot;<span class="hljs-subst">&#123;DateTime.Now&#125;</span>\t<span class="hljs-subst">&#123;severity&#125;</span>\t<span class="hljs-subst">&#123;component&#125;</span>\t<span class="hljs-subst">&#123;message&#125;</span>&quot;</span>;<br>        WriteMessage?.Invoke(outputMsg);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">LoggingMethod</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LogToConsole</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        Console.Error.WriteLine(message);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">FileLogger</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">string</span> _logPath;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FileLogger</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> logPath</span>)</span><br>    &#123;<br>        _logPath = logPath;<br>        Logger.WriteMessage += LogMessage;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DetachLog</span>()</span> =&gt; Logger.WriteMessage -= LogMessage;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LogMessage</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">try</span><br>        &#123;<br>            <span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> log = File.AppendText(_logPath))<br>            &#123;<br>                log.WriteLine(message);<br>                log.Flush();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Exception)<br>        &#123;<br><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1>事件（Event）</h1><h2 id="什么是事件？">什么是事件？</h2><blockquote><p>类或对象可以通过事件向其他类或对象通知发生的相关事情。 发送（或引发）事件的类称为“发布者”，接收（或处理）事件的类称为“订阅者”。——C#编程指南</p></blockquote><p>事件和委托类似，也是后期绑定机制（实际上，事件是建立在对委托的语言支持之上的）。当然要我说的话，无非就是用来实现发布订阅模式的东西，比如现在我们有一个事件，发布者会发布这个事件，广播这个事件发生了，而广播的对象就是那些订阅了这个事件的订阅者。其实就是图形系统的交互啦，点击一个按钮，然后会发生一些事情，其实就是事件的应用。</p><h2 id="事件食用方法">事件食用方法</h2><p>定义事件：<code>public event EventHandler&lt;FileListArgs&gt; Progress;</code></p><p>在这里，<code>EventHandler</code>是委托类型，而<code>Progress</code>是名称。</p><div class="note note-warning">            <p>事件不是类型！和方法、属性一样，事件是类或结构的成员！</p>          </div><p>引发事件：<code>Progress?.Invoke(this, new FileListArgs(file));</code></p><p>订阅事件：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#">EventHandler&lt;FileListArgs&gt; onProgress = (sender, eventArgs) =&gt;<br>    Console.WriteLine(eventArgs.FoundFile);<br><br>fileLister.Progress += onProgress;<br></code></pre></td></tr></table></figure><p>取消订阅：<code>fileLister.Progress -= onProgress;</code></p><p>举个例子：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleEventArgs</span> : <span class="hljs-title">EventArgs</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Msg &#123; <span class="hljs-keyword">get</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SimpleEventArgs</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> msg</span>)</span> =&gt; Msg = msg;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Publisher</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> EventHandler&lt;SimpleEventArgs&gt;? SimpleEvent;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RaiseTheEvent</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> msg</span>)</span> =&gt;<br>        SimpleEvent?.Invoke(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">new</span> SimpleEventArgs(msg));<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Subscriber</span><br>&#123;<br>    <span class="hljs-keyword">public</span> EventHandler&lt;SimpleEventArgs&gt; onA = (sender, eventArgs) =&gt; &#123; Console.WriteLine(<span class="hljs-string">$&quot;A: <span class="hljs-subst">&#123;eventArgs.Msg&#125;</span>&quot;</span>); &#125;;<br>    <span class="hljs-keyword">public</span> EventHandler&lt;SimpleEventArgs&gt; onB = (sender, eventArgs) =&gt; &#123; Console.WriteLine(<span class="hljs-string">$&quot;B: <span class="hljs-subst">&#123;eventArgs.Msg&#125;</span>&quot;</span>); &#125;;<br>&#125;<br><br><span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Event</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        Publisher publisher = <span class="hljs-keyword">new</span> Publisher();<br>        Subscriber subscriber = <span class="hljs-keyword">new</span> Subscriber();<br><br>        publisher.SimpleEvent += subscriber.onA;<br>        publisher.SimpleEvent += subscriber.onB;<br>        publisher.RaiseTheEvent(<span class="hljs-string">&quot;test&quot;</span>);<br><br>        Console.WriteLine(<span class="hljs-string">&quot;\r\nRemove onB&quot;</span>);<br>        publisher.SimpleEvent -= subscriber.onB;<br>        publisher.RaiseTheEvent(<span class="hljs-string">&quot;test 2&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行后，控制台输出如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cmake">A: <span class="hljs-keyword">test</span><br>B: <span class="hljs-keyword">test</span><br><br><span class="hljs-keyword">Remove</span> onB<br>A: <span class="hljs-keyword">test</span> <span class="hljs-number">2</span><br><br>E:\<span class="hljs-keyword">Project</span>\C<span class="hljs-comment">#\CSharpLearning\Learning1\Learning1\bin\Debug\net6.0\Learning1.exe (进程 26916)已退出，代码为 0。</span><br>要在调试停止时自动关闭控制台，请启用“工具”-&gt;“选项”-&gt;“调试”-&gt;“调试停止时自动关闭控制台”。<br>按任意键关闭此窗口. . .<br></code></pre></td></tr></table></figure><p>然后大致说明一下事件的一个流程：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#">Publisher publisher = <span class="hljs-keyword">new</span> Publisher();<br>Subscriber subscriber = <span class="hljs-keyword">new</span> Subscriber();<br><br>publisher.SimpleEvent += subscriber.onA;<br>publisher.SimpleEvent += subscriber.onB;<br>publisher.RaiseTheEvent(<span class="hljs-string">&quot;test&quot;</span>);<br><br>Console.WriteLine(<span class="hljs-string">&quot;\r\nRemove onB&quot;</span>);<br>publisher.SimpleEvent -= subscriber.onB;<br>publisher.RaiseTheEvent(<span class="hljs-string">&quot;test 2&quot;</span>);<br></code></pre></td></tr></table></figure><p>首先使用<code>+=</code>订阅事件，也就是给事件增加事件处理程序，这里决定之后发布事件的时候会调用哪些事件处理程序进行处理。然后调用<code>RaiseTheEvent</code>方法发布（触发）事件，该方法包含了<code>SimpleEvent?.Invoke()</code>语句。之后事件被触发，执行该事件保存的事件处理程序。</p><div class="note note-warning">            <p><code>EventArgs</code>不能传递任何数据。如果要传递数据，那就声明一个派生自<code>EventArgs</code>的类（比如上面的<code>SimpleEventArgs</code>类）。</p>          </div><p>我们还可以改变<code>+=</code>和<code>-=</code>运算符的行为，只需要为事件定义事件访问器即可：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> EventHandler&lt;SimpleEventArgs&gt;? SimpleEvent<br>&#123;<br><span class="hljs-keyword">add</span><br>    &#123;<br>        ...<br>    &#125;<br>    <span class="hljs-keyword">remove</span><br>    &#123;<br>    ...    <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1>泛型（Generic）</h1><h2 id="泛型是什么">泛型是什么</h2><blockquote><p>泛型（generic）允许我们声明类型参数化（type-parameterized）的代码，用不同的类型进行实例化。也就是，我们可以用“类型占位符”来写代码，然后在创建类的实例时指名真实的类型。</p></blockquote><p>简单来说就是现在我们有一个返回两数中更大数的方法，返回类型可以不再限定是某一个具体的类型（比如<code>int</code>），而是可以是任一类型，这样我们的代码就能够进行复用。</p><h2 id="泛型的食用方法">泛型的食用方法</h2><h3 id="泛型方法">泛型方法</h3><p>首先声明泛型方法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OneGenericMethod</span>&lt;<span class="hljs-title">TFirst</span>, <span class="hljs-title">TSecond</span>&gt;(<span class="hljs-params">TFirst first, TSecond second</span>)</span><br>&#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>需要调用这个泛型方法的时候，用实际类型将类型参数列表的泛型类型替代即可：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">OneGenericMethod&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt;(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>当然编译器能够从方法参数中推断类型参数，所以我们可以省略尖括号：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">OneGenericMethod(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h3 id="泛型类">泛型类</h3><p>要创建泛型类，一共分为三大步：</p><ol><li>声明泛型类</li><li>构造实际类</li><li>创建实例</li></ol><p>首先是声明泛型类：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">OneGenericClass</span>&lt;<span class="hljs-title">TFirst</span>, <span class="hljs-title">TSecond</span>&gt;<br>&#123;<br>    <span class="hljs-keyword">public</span> TFirst First;<br>    <span class="hljs-keyword">public</span> TSecond Second;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后是构造实际类和使用<code>new</code>关键字创建实际类的实例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">public</span> OneGenericClass&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt; A = <span class="hljs-keyword">new</span> OneGenericClass&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt;();<br></code></pre></td></tr></table></figure><h3 id="类型参数的约束">类型参数的约束</h3><blockquote><p>我们可以提供额外信息来让编译器知道参数可以接受哪些类型，这些额外信息就是<strong>约束</strong>。只有符合约束的类型才能替代给定的类型参数来产生构造类型。</p></blockquote><p>利用<code>Where</code>子句来对泛型接受的类型进行约束。</p><p>约束有非常多种，建议直接在官网看：<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/generics/constraints-on-type-parameters">点我</a></p><p>这里列举几个常用的约束：</p><ol><li><code>where T : class</code>限定类型参数必须是引用类型</li><li><code>where T : &lt;基类名&gt;</code>限定类型参数必须是指定的基类或派生自指定的基类</li><li><code>where T : &lt;接口名称&gt;</code>限定类型参数必须是指定的接口或实现指定的接口</li></ol><h3 id="泛型结构">泛型结构</h3><p>泛型结构和泛型类相似，这里不再赘述。</p><h3 id="泛型委托">泛型委托</h3><p>其实在上面已经见过了，C#本身提供了几个泛型委托。</p><h3 id="泛型接口">泛型接口</h3><p>泛型接口其实也跟泛型类差不多，毕竟泛型接口就是为了给泛型类实现的。</p><p>与其他泛型相似，用不同类型参数实例化的泛型接口的实例时不同接口，而且我们也可以在非泛型类型中实现泛型接口，比如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">interface</span> <span class="hljs-title">IExampleIfc</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>    <span class="hljs-function">T <span class="hljs-title">ReturnValue</span>(<span class="hljs-params">T <span class="hljs-keyword">value</span></span>)</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleClass</span> : <span class="hljs-title">IExampleIfc</span>&lt;<span class="hljs-title">int</span>&gt;, <span class="hljs-title">IExampleIfc</span>&lt;<span class="hljs-title">string</span>&gt;<br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">ReturnValue</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">value</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> <span class="hljs-title">ReturnValue</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> <span class="hljs-keyword">value</span></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">value</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不过需要注意的是下面这种情况：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">interface</span> <span class="hljs-title">IExampleIfc</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>    <span class="hljs-function">T <span class="hljs-title">ReturnValue</span>(<span class="hljs-params">T <span class="hljs-keyword">value</span></span>)</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleClass</span>&lt;<span class="hljs-title">S</span>&gt; : <span class="hljs-title">IExampleIfc</span>&lt;<span class="hljs-title">int</span>&gt;, <span class="hljs-title">IExampleIfc</span>&lt;<span class="hljs-title">S</span>&gt;<br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">ReturnValue</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">value</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> S <span class="hljs-title">ReturnValue</span>(<span class="hljs-params">S <span class="hljs-keyword">value</span></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">value</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果这里的<code>S</code>利用<code>int</code>来替代的话，这个类就有两个相同类型的接口了，而这是不允许的。</p><h1>迭代器（Iterator）</h1><p>如果我们要循环访问一个集合中的所有内容，我们就会使用<code>foreach</code>语句。那要在这个集合上使用<code>foreach</code>语句，前提就是这个集合会提供一个叫做**枚举器（enumerator）**的对象。（其实这里不就像python中的<code>for index, item in enumerator(list)</code>吗）</p><p>那么如何让集合提供一个枚举器呢？那就是通过<code>IEnumerable&lt;T&gt;</code>和<code>IEnumerator&lt;T&gt;</code>这两个接口（当然C#也提供了这两个接口的非泛型版本）。</p><blockquote><p>迭代器会为我们创建枚举器。</p></blockquote><p>（其实这部分讲得不是很清楚，自己理解的也不是很清楚，建议还是看看官网吧：<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/iterators">点我</a></p><h2 id="枚举器的食用方法">枚举器的食用方法</h2><p>对于一个方法，可以简单的将其返回类型设置为<code>IEnumerable</code>并在方法体内使用<code>yield return</code>语句来实现返回迭代器。</p><blockquote><p><code>IEnumerable</code>是产生可枚举类型的迭代器，而<code>IEnumerator</code>是产生枚举器的迭代器。</p></blockquote><p>对于一个类，有两种模式。</p><ol><li>枚举器的迭代器模式</li><li>可枚举类型的迭代器模式</li></ol><p>其中第一种模式，是在类里面利用<code>IEnumerator</code>首先实现一个返回枚举器的迭代器，然后再通过实现<code>GetEnumerator</code>来让类可枚举。代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> IEnumerator <span class="hljs-title">GetEnumerator</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> IteratorMethod();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> IEnumerator <span class="hljs-title">IteratorMethod</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> ...;<br>    &#125;<br>&#125;<br><br>Main<br>&#123;<br>    MyClass mc = <span class="hljs-keyword">new</span> MyClass();<br>    <span class="hljs-keyword">foreach</span>( <span class="hljs-built_in">string</span> x <span class="hljs-keyword">in</span> mc )<br>        ...<br>&#125;<br></code></pre></td></tr></table></figure><p>而第二种模式则是在类里用<code>IEnumerable</code>来实现返回可枚举类型的迭代器，这样做的话，我们可以不需要实现<code>GetEnumerator</code>，因为能够直接调用迭代器方法来获取可枚举类型。代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> IEnumerator <span class="hljs-title">GetEnumerator</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> IteratorMethod().GetEnumerator();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> IEnumerable <span class="hljs-title">IteratorMethod</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> ...;<br>    &#125;<br>&#125;<br><br>Main<br>&#123;<br>    MyClass mc = <span class="hljs-keyword">new</span> MyClass();<br>    <span class="hljs-keyword">foreach</span>( <span class="hljs-built_in">string</span> x <span class="hljs-keyword">in</span> mc )<br>        ...<br>    <span class="hljs-keyword">foreach</span>( <span class="hljs-built_in">string</span> x <span class="hljs-keyword">in</span> mc.IteratorMethod() )<br>        ...   <br>&#125;<br></code></pre></td></tr></table></figure><h1>语言集成查询（LINQ）</h1><h2 id="什么事LINQ">什么事LINQ</h2><p>LINQ，即语言集成查询（Language Integrated Query），是 .NET 框架的扩展，它允许我们以使用 SQL 查询数据库的类似方式来查询数据集合。使用 LINQ，我们可以从数据库、对象集合以及 XML 文档等中查询数据。</p><h2 id="查询操作的三个部分">查询操作的三个部分</h2><p>所有 LINQ 查询操作都由以下三个不同的操作组成：</p><ol><li>获取数据源，如：<code>int[] nums = &#123; 0, 1, 2, 3, 4 &#125;;</code></li><li>创建查询，如：<code>IEnumerable&lt;int&gt; numQuery = from num in nums where (num % 2) == 0 select num;</code></li><li>执行查询，如：<code>foreach (int num in num Query)Console.WriteLine(num);</code></li></ol><h2 id="数据源">数据源</h2><p>LINQ 数据源是支持泛型<code>IEnumerable&lt;T&gt;</code>接口或从中继承的接口的任意对象。</p><h2 id="查询">查询</h2><p>查询是一组指令。查询指定要从数据源中检索的信息。查询还可以指定在返回这些信息之前如何对其进行排序、分组和结构化。<br>目前需要注意的是，在 LINQ 中，查询变量本身不执行任何操作并且不返回任何数据，它只是存储在以后某个时刻执行查询时为生成结果而必需的信息。</p><h2 id="执行查询">执行查询</h2><p>查询变量本身只存储查询命令，以前面的代码为例，<code>numQuery</code>就是查询变量，但是它不包含查询的结果，而是包含能够执行这个查询的代码。但是如果查询返回的是标量（即单个值，如：<code>numQuery.Count()</code>），则查询会立即执行，并且把结果保存在查询变量中。</p><ul><li>如果查询表达式返回枚举，则查询一直到处理枚举时才会执行。</li><li>如果枚举被处理多次，查询就会执行多次。</li><li>如果在进行遍历之后、查询执行之前数据有改动，则查询会使用新的数据。</li><li>如果查询表达式返回标量，查询立即执行，并且把结果保存在查询变量中。</li></ul><h2 id="方法语法和查询语法">方法语法和查询语法</h2><p>我们在写 LINQ 查询时可以使用两种形式的语法：查询语法和方法语法。</p><ul><li>方法语法（method syntax）：使用标准的方法调用。方法语法时**命令式（imperative）**的，它指明了查询方法调用的顺序。</li><li>查询语法（query syntax）：和 SQL 语句很相似，使用查询表达式形式书写。查询语法是**声明式（declarative）**的，也就是说，查询描述的是你想返回的东西，但并没有指明如何执行这个查询。</li><li>方法语法 + 查询语法混用</li></ul><div class="note note-info">            <p>微软推荐使用查询语法。不过有一些运算符必须使用方法语法来书写。</p>          </div><h2 id="查询表达式">查询表达式</h2><p>查询表达式是以查询语法表示的查询。查询表达式必须以<code>from</code>子句开头，且必须以<code>select</code>或<code>group</code>子句结尾。</p><h3 id="from-子句">from 子句</h3><p><code>from</code>子句指定了要作为数据源使用的数据集合。<code>from</code>子句的用法如下：<code>from Type Item in Items</code></p><ul><li><code>Type</code>是集合中元素的类型。这是可选的，因为编译器可以从集合中推断类型。</li><li><code>Item</code>是迭代变量的名字。</li><li><code>Items</code>是要查询的集合的名字。集合必须是可枚举的（IEnumerable）。</li></ul><h3 id="join-子句">join 子句</h3><p><code>join</code>子句可基于每个元素中指定的键之间的相等比较，将一个数据源中的元素与另一个数据源中的元素进行关联和/或合并。例如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">var</span> query = <span class="hljs-keyword">from</span> s <span class="hljs-keyword">in</span> students <br><span class="hljs-keyword">join</span> c <span class="hljs-keyword">in</span> stuInCourses <span class="hljs-keyword">on</span> s.StId <span class="hljs-keyword">equals</span> c.StId <br><span class="hljs-keyword">select</span> s.Name;<br></code></pre></td></tr></table></figure><p>注意必须使用上下文关键字<code>equals</code>来比较字段，而不能使用<code>==</code>运算符。</p><h3 id="where-子句">where 子句</h3><p><code>where</code>子句可基于一个或多个谓词表达式，从数据源中筛选出元素。例如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#">IEnumerable&lt;Student&gt; query = <span class="hljs-keyword">from</span> s <span class="hljs-keyword">in</span> students <br> <span class="hljs-keyword">where</span> s.Age = <span class="hljs-number">18</span> <br> <span class="hljs-keyword">select</span> s;<br></code></pre></td></tr></table></figure><h3 id="let-子句">let 子句</h3><p><code>let</code>子句可将表达式（如方法调用）的结果存储在新范围变量中。例如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#">IEnumerable&lt;<span class="hljs-built_in">string</span>&gt; query = <span class="hljs-keyword">from</span> name <span class="hljs-keyword">in</span> names <br><span class="hljs-keyword">let</span> firstName = name.Split(<span class="hljs-string">&#x27; &#x27;</span>)[<span class="hljs-number">0</span>] <br><span class="hljs-keyword">select</span> firstName;<br></code></pre></td></tr></table></figure><h3 id="orderby-子句">orderby 子句</h3><p><code>orderby</code>子句可按升序或降序对结果进行排序，还可以指定次要排序顺序。例如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#">IEnumerable&lt;Student&gt; query = <span class="hljs-keyword">from</span> s <span class="hljs-keyword">in</span> students <br> <span class="hljs-keyword">orderby</span> s.StId, s.Age <span class="hljs-keyword">descending</span> <br> <span class="hljs-keyword">select</span> s;<br></code></pre></td></tr></table></figure><h3 id="select-子句">select 子句</h3><p><code>select</code>子句可生成所有其他类型的序列。比如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#">IEnumerable&lt;Country&gt; sortedQuery = <span class="hljs-keyword">from</span> country <span class="hljs-keyword">in</span> countries <br>   <span class="hljs-keyword">orderby</span> country.Area <br>   <span class="hljs-keyword">select</span> country;<br></code></pre></td></tr></table></figure><p>在这里<code>select</code>子句生成重新排序的<code>Country</code>对象的序列。</p><h3 id="group-子句">group 子句</h3><p><code>group</code>子句可生成按指定键组织的组的序列。不过要注意的是<code>group</code>子句<strong>返回对象集合的集合</strong>（<code>IEnumerable&lt;IGrouping&lt;TKey, TElement&gt;&gt;</code>），而不是对象的集合。</p><h3 id="into-子句">into 子句</h3><p><code>into</code>子句可以接受查询的一部分的结果并赋予一个名字，从而可以在查询的另一个部分中使用。例如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">var</span> query = <span class="hljs-keyword">from</span> a <span class="hljs-keyword">in</span> groupA<br><span class="hljs-keyword">join</span> b <span class="hljs-keyword">in</span> groupB <span class="hljs-keyword">on</span> a <span class="hljs-keyword">equals</span> b<br><span class="hljs-keyword">into</span> groupAandB<br><span class="hljs-keyword">from</span> c <span class="hljs-keyword">in</span> groupAandB<br><span class="hljs-keyword">select</span> c<br></code></pre></td></tr></table></figure><h2 id="标准查询运算符">标准查询运算符</h2><p>标准查询运算符由一系列 API 方法组成，能让我们查询任何 .NET 数组和集合。例如以下两个查询是等效的：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#">IEnumerable&lt;<span class="hljs-built_in">int</span>&gt; qurey1 = <span class="hljs-keyword">from</span> num <span class="hljs-keyword">in</span> numbers<br>  <span class="hljs-keyword">where</span> num % <span class="hljs-number">2</span> == <span class="hljs-number">0</span><br>  <span class="hljs-keyword">orderby</span> num<br>  <span class="hljs-keyword">select</span> num;<br><br>IEnumerable&lt;<span class="hljs-built_in">int</span>&gt; query2 = numbers.Where(num =&gt; num % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).OrderBy(n =&gt; n);<br></code></pre></td></tr></table></figure><p>如果想要了解更多 API 请参考官方文档：<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/linq/standard-query-operators-overview">标准查询运算符概述 (C#)</a></p><hr>]]></content>
    
    
    <categories>
      
      <category>Learning Log</category>
      
      <category>CSharp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
      <tag>泛型</tag>
      
      <tag>委托</tag>
      
      <tag>枚举器和迭代器</tag>
      
      <tag>xml</tag>
      
      <tag>LINQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot的一些杂项</title>
    <link href="/2023/05/23/spring-essay-1/"/>
    <url>/2023/05/23/spring-essay-1/</url>
    
    <content type="html"><![CDATA[<h1>SpringBoot的starter</h1><h2 id="starter的命名规范">starter的命名规范</h2><p>官方启动器：<code>spring-boot-starter-*</code><br>第三方启动器：<code>*-spring-boot-starter</code></p><h2 id="stater的分类">stater的分类</h2><p><code>application starter</code>：应用级<code>starter</code><br><code>production starter</code>：生产级<code>starter</code>，就一个，提供生产功能以帮助开发者监控和管理应用。<br><code>technical starter</code>：技术级别的<code>starter</code>，帮助开发者排除或者替换<code>SpringBoot</code>框架内部默认的技术组件。</p><h2 id="自动配置">自动配置</h2><p><code>SpringBoot</code>都会自动配置，想查看自动配置报告，可以用<code>java -jar xx.jar -debug/Ddebug</code>，或者<code>spring-boot:run -Dspring-boot.run.arguments=&quot;--debug&quot;</code><br>在使用<code>@SpringBootApplication</code>或是<code>@EnableAutoConfiguration</code>注解的时候，可以用<code>exclude</code>或<code>excludeName</code>属性，或是在应用配置文件<code>yml</code>中指定参数<code>spring.autoconfigure.exclude</code>统一排除。</p><h2 id="邮件starter">邮件starter</h2><p>一个很方便的用来发邮件的<code>starter</code>，用法建议百度。</p><h1>SpringBoot启动过程与扩展应用</h1><p>应用启动类，如果没有必要，一般建议启动入口类要放置于根目录下，以便使用注解扫描并管理所有子目录包的组件。</p><h2 id="SpringBoot懒加载">SpringBoot懒加载</h2><p>懒加载的意思是<code>bean</code>不会在应用启动时全部创建，只会在其真正使用时才创建。如果要开启懒加载，<code>yml</code>配置文件中配置<code>spring.main.lazy-initialization: true</code></p><h2 id="Spring-Boot-Runner">Spring Boot Runner</h2><p>它允许Spring Boot应用启动完成之后，在接受请求之前运行一些特定的代码逻辑。可以实现<code>ApplicationRunner</code>或<code>CommandLineRunner</code>接口。</p><h1>SpringBoot日志管理</h1><h2 id="彩色日志配置">彩色日志配置</h2><p>在<code>yml</code>配置文件中配置`spring.output.ansi.enabled: always/detect(默认)/never</p><h1>SpringBootWeb核心应用</h1><p><code>SpringBoot</code>支持两种<code>Web</code>类型：<code>servlet</code>（即传统的<code>WebMVC</code>）和<code>reactive</code>（响应式的<code>WebFlux</code>）</p><h2 id="嵌入式容器">嵌入式容器</h2><h3 id="容器配置">容器配置</h3><p>容器参数绑定类为<code>ServerProperties</code>类，可以通过其绑定的以<code>server.*</code>开头的参数来配置所有容器的通用配置(<code>application.yml</code>中)。<br>还能通过<code>Java</code>类的方式来自定义<code>Servlet</code>容器，只需实现<code>WebServerFactoryCustomizer&lt;ConfigurableServletWebServerFavtory&gt;</code>接口即可。</p><h3 id="随机空闲端口">随机空闲端口</h3><p>把<code>server.port</code>设置成<code>0</code>，<code>SpringBoot</code>就会使用系统随即空闲的端口。</p><h3 id="持久化">持久化</h3><p>要让嵌入式容器支持会话持久化，配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">servlet:</span><br>    <span class="hljs-attr">session:</span><br>  <span class="hljs-attr">persistent:</span> <span class="hljs-literal">true</span>  <span class="hljs-comment"># 开启持久化</span><br>  <span class="hljs-attr">store-dir:</span> <span class="hljs-string">/tmp/session-store</span>  <span class="hljs-comment"># 持久化目录</span><br>  <span class="hljs-attr">tracking-modes:</span> <br>    <span class="hljs-bullet">-</span> <span class="hljs-string">cookie</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">url</span>  <span class="hljs-comment"># 追踪模式</span><br></code></pre></td></tr></table></figure><h3 id="优雅关闭">优雅关闭</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">shutdown:</span> <span class="hljs-string">graceful</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">lifecycle:</span><br>    <span class="hljs-attr">timeout-per-shutdown-phase:</span> <span class="hljs-string">20s</span>  <span class="hljs-comment"># 超时参数</span><br></code></pre></td></tr></table></figure><h2 id="注册拦截器">注册拦截器</h2><p>实现<code>HandlerInterceptor</code>接口来创建一个拦截器，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExampleInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在自定义<code>Web</code>配置类中进行注册：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@RequiredArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ExampleInterceptor exampleInterceptor;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>registry.addInterceptor(exampleInterceptor)<br>.addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>)<br>.excludePathPatterns(<span class="hljs-string">&quot;/example/**&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="注册消息转换器">注册消息转换器</h2><p>可以在自定义<code>Web</code>配置类中覆盖原有配置，或是添加额外的自定义转换器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br><span class="hljs-comment">// 覆盖原有配置</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> MappingJackson2HttpMessageConverter <span class="hljs-title function_">mappingJackson2HttpMessageConverter</span><span class="hljs-params">()</span> &#123;<br>...<br>&#125;<br><br><span class="hljs-comment">// 添加额外转换器</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> HttpMessageConverters <span class="hljs-title function_">customConverters</span><span class="hljs-params">()</span> &#123;<br>HttpMessageConverter&lt;?&gt; a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">aHttpMessageConverter</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpMessageConverters</span>(a);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="注册类型转换器">注册类型转换器</h2><p><code>Converter</code>接口可以转换参数的类型，同样也是在自定义<code>Web</code>配置类中进行注册。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addFormatters</span><span class="hljs-params">(FormatterRegistry registry)</span> &#123;<br>registry.addConverter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExampleConverter</span>());<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExampleConverter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Converter</span>&lt;String, String&gt; &#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="注册Servlet、Fliter、Listener">注册Servlet、Fliter、Listener</h2><p>三种方法：<code>SpringBoot</code>的手动注册、组件扫描注册、动态注册。<br>一帮情况下扫描注册组件是最简洁的。</p><h2 id="静态资源管理">静态资源管理</h2><p>默认情况下，<code>SpringBoot</code>加载的<code>classpath</code>下的几个静态资源目录有：</p><blockquote><p>/static<br>/public<br>/resources<br>/META-INF/resources<br>要自定义，通过<code>spring.web.resources.static-locations</code>参数指定<br>可以添加额外的静态资源目录映射，实现<code>WebMvcConfigurer</code>并覆盖<code>addResourcesHandles</code>即可</p></blockquote><h2 id="参数校验">参数校验</h2><p>要对接口参数进行校验，可以导入<code>spring-boot-starter-validation</code>启动器</p><h2 id="约束注解">约束注解</h2><p>校验接口参数要用到<code>javax(jakarta).validation</code>包下的约束注解<br>有<code>@Valid</code>和<code>@Validated</code><br>校验接口参数类时，将<code>@Validated</code>放在方法参数类前，然后把约束注解放在类成员变量上面；<br>校验接口单个参数时，将<code>@Validated</code>注解放在当前<code>Controller</code>类上面，然后将约束注解放在方法参数类前；<br>要返回具体的参数错误，则需要拦截对应的<code>MethodArgumentNotValidException</code>异常，并做对应的返回处理</p><h2 id="国际化">国际化</h2><p>需要手动切换语言的情况，注册一个<code>LocaleResolver</code>区域解析器和区域拦截器</p><h2 id="跨域请求">跨域请求</h2><p><code>@CrossOrigin</code>可以用在类或者方法上<br>在<code>WebMvcConfigurer</code>配置类中可以实现全局跨域<br>（但是实际应用会在<code>Nginx</code>上配置跨域</p><h1>SpringBoot数据访问</h1><p>分为关系型数据库和非关系型数据库(<code>NoSQL</code>)</p><h2 id="嵌入式数据库">嵌入式数据库</h2><p>相当于“内存形式的关系型数据库”，它在应用中只有一个<code>jar</code>文件，而没有其他的外部环境，所有数据都存储在内存中，也不能持久化数据，应用关闭就会丢弃所有数据<br>（重点：实际工作中很少用</p><h2 id="数据源">数据源</h2><p><code>SpringBoot</code>支持数据库数据源的自动配置，只需要导入<code>spring-boot-starter-data-jdbc</code>启动器依赖及对应的数据库驱动依赖即可</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/database_name</span><br>    <span class="hljs-attr">usernane:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br></code></pre></td></tr></table></figure><p>数据库驱动类参数<code>driver-class-name</code>可以不用指定，<code>SpringBoot</code>可以推断主流数据库类型</p><h2 id="事务管理">事务管理</h2><p><code>SpringBoot</code>提供了事务的自动配置，如果没有自定义的事务需求，那么使用默认自动配置的事务即可，在代理方法上使用<code>@Transactional</code>事务注解即可</p><h2 id="事务失效的场景">事务失效的场景</h2><ol><li>数据库引擎不支持事务</li><li>没有被<code>Spring</code>管理：记得加上<code>@Service</code>注解让这个类被加载成一个<code>Bean</code></li><li>方法不是<code>public</code>的</li><li>发生自身调用：调用了该类自己的方法事务就不会生效</li><li>没有配置事务管理器：<code>Spring</code>框架需要注意，<code>SpringBoot</code>会自动配置（前提是添加了<code>jdbc</code>启动器依赖</li><li>设置了不支持事务：<code>@Transactional(propagation=Propagation.NOT_SUPPORTED)</code></li><li>异常没有被抛出：<code>try&#123;...&#125;catch&#123;&#125;</code>这里<code>catch</code>里面是空的，虽然捕获了异常但是没有抛出，所以事务不会回滚</li><li>异常类型不匹配：<code>Spring</code>默认回滚的是<code>RuntimeException</code>异常，如果要触发其他异常的回滚，则需要在<code>@Transactional</code>事务注解上指定异常类：<code>@Transactional(rollbackFor=Exception.class)</code></li></ol><h2 id="Spring-Data-JPA">Spring Data JPA</h2><p><code>JPA</code>是<code>java</code>提供的持久化<code>API</code>，为<code>POJO</code>提供持久化的标准规范，可以把<code>java</code>对象映射为数据库中的记录<br><code>Hibernate</code>是<code>java</code>最流行的<code>JPA</code>规范的实现框架<br><code>Spring Data JPA</code>则是对<code>Hibernate</code>更上一层的封装<br>使用<code>JPA</code>，在实体类上加上<code>@Entity</code>注解即可<br>（评价是依然不如<code>Mybatis</code></p><h2 id="Mybatis">Mybatis</h2><p>使用<code>MyBatis</code>框架一般需要以下两个组件：<br><code>*Mapper.java</code>：数据库映射接口，提供对应的数据库操作方法<br><code>*Mapper.xml</code>：数据库<code>SQL</code>映射配置文件，提供数据库映射接口执行的<code>SQL</code><br>在配置文件中添加<code>MyBatis</code>配置参数：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">mybatis:</span><br>  <span class="hljs-attr">mapper-locations: classpath:</span> <span class="hljs-string">mapper/*.xml</span><br>  <span class="hljs-attr">type-aliases-package:</span> <span class="hljs-string">com.example.entity</span><br></code></pre></td></tr></table></figure><p>接口需要使用<code>@Mapper</code>注解修饰</p><h1>SpringBoot计划任务</h1><p><em><strong>To do…</strong></em></p><hr>]]></content>
    
    
    <categories>
      
      <category>Essay</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>VSCode</tag>
      
      <tag>Spring</tag>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树专题</title>
    <link href="/2023/05/22/algorithm-tree/"/>
    <url>/2023/05/22/algorithm-tree/</url>
    
    <content type="html"><![CDATA[<h1>说点废话</h1><p>看到今天的力扣的每日一题是一道跟二叉树有关的，递归题目，突然发现自己对树的相关知识有点忘得一干二净了，于是就想复习一下，于是就有了这篇文章。</p><h1>什么事二叉树</h1><p><s>一种数据结构。</s>当然其实我写这篇文章并不想讲这些基础概念什么balabala的，我只是想复习和二叉树有关的算法（逃，所以我选择贴链接：<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91">维基百科——二叉树</a><br>给出最基本的树的结点的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, val=<span class="hljs-number">0</span>, left=<span class="hljs-literal">None</span>, right=<span class="hljs-literal">None</span></span>):<br>        self.val = val<br>        self.left = left<br>        self.right = right<br></code></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span> <br>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> val;<br><span class="hljs-keyword">public</span> TreeNode left;<br><span class="hljs-keyword">public</span> TreeNode right;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TreeNode</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> val=<span class="hljs-number">0</span>, TreeNode left=<span class="hljs-literal">null</span>, TreeNode right=<span class="hljs-literal">null</span></span>)</span> <br>&#123;<br><span class="hljs-keyword">this</span>.val = val;<br><span class="hljs-keyword">this</span>.left = left;<br><span class="hljs-keyword">this</span>.right = right;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1>二叉树的各种操作</h1><h2 id="遍历">遍历</h2><p>对一棵二叉树进行遍历，其实就是用<code>DFS</code>和<code>BFS</code>，而<code>DFS</code>又有三种顺序：前序、中序、后序。前序就是中左右，中序就是左中右，后序就是左右中。<code>BFS</code>的话就是按层次从左到右了。<br>根据上面对树结点的定义和遍历思路，我们可以很快写出代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">preOrder</span>(<span class="hljs-params">node: TreeNode</span>):<br>    <span class="hljs-built_in">print</span>(node.val)<br>    <span class="hljs-keyword">if</span> node.left <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        preOrder(node.left)<br>    <span class="hljs-keyword">if</span> node.right <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        preOrder(node.right)<br></code></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TreeMethods</span> <br>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PreOrder</span>(<span class="hljs-params">TreeNode node</span>)</span> <br>&#123;<br>Console.WriteLine(node.val);<br><span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>)<br>&#123;<br>PreOrder(node.left);<br>&#125;<br><span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>)<br>&#123;<br>PreOrder(node.right);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>只有前序遍历是因为另外两个照葫芦画瓢就好了。<br>下面是用<code>BFS</code>按层次遍历的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">preOrderBFS</span>(<span class="hljs-params">node: TreeNode</span>):<br>    queue = deque([node])<br>    <span class="hljs-keyword">while</span> queue:<br>        cur = queue.popleft()<br>        <span class="hljs-built_in">print</span>(cur.val)<br>        <span class="hljs-keyword">if</span> cur.left <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            preOrderBFS(cur.left)<br>        <span class="hljs-keyword">if</span> cur.right <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            preOrderBFS(cur.right)<br></code></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PreOrderBFS</span>(<span class="hljs-params">TreeNode node</span>)</span><br>&#123;<br>Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> Queue&lt;TreeNode&gt;();<br>queue.Enqueue(node);<br><span class="hljs-keyword">while</span> (queue.Any())<br>&#123;<br>TreeNode cur = queue.Dequeue();<br>Console.WriteLine(cur.val);<br><span class="hljs-keyword">if</span> (cur.left != <span class="hljs-literal">null</span>)<br>&#123;<br>queue.Enqueue(cur.left);<br>&#125;<br><span class="hljs-keyword">if</span> (cur.right != <span class="hljs-literal">null</span>)<br>&#123;<br>queue.Enqueue(cur.right);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二叉树的深度">二叉树的深度</h2><p>思想：遍历，往下递的过程是走完左子树和右子树，往上归的过程是传递当前最深深度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">depth</span>(<span class="hljs-params">node: TreeNode</span>):<br>    <span class="hljs-keyword">if</span> node <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> node.left <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        leftDepth = depth(node.left)<br>    <span class="hljs-keyword">else</span>:<br>        leftDepth = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> node.right <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        rightDepth = depth(node.right)<br>    <span class="hljs-keyword">else</span>:<br>        rightDepth = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">return</span> leftDepth + <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> leftDepth &gt; rightDepth <span class="hljs-keyword">else</span> rightDepth + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Depth</span>(<span class="hljs-params">TreeNode node</span>)</span><br>&#123;<br><span class="hljs-built_in">int</span> leftDepth = <span class="hljs-number">0</span>, rightDepth = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>)<br>&#123;<br>leftDepth = Depth(node.left);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>leftDepth = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>)<br>&#123;<br>rightDepth = Depth(node.right);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>rightDepth = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">return</span> leftDepth &gt; rightDepth ? leftDepth + <span class="hljs-number">1</span> : rightDepth + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>ok，其实到目前为止今天遇到的那道题的知识已经够了，现在来看看题目吧。</p><h1>题目描述</h1><p><a href="https://leetcode.cn/problems/insufficient-nodes-in-root-to-leaf-paths/description/">1080. 根到叶路径上的不足节点</a></p><h1>思路及实现</h1><p>明确<strong>不足节点</strong>的概念，哪些节点应该删除，哪些不能。假如现在有一个叶子节点，它的“根-叶”路径上值的总和全都小于给定的<code>limit</code>，那么这个叶子节点就是不足节点，我们可以删除它。<br>那假如现在有一个非叶子节点，要怎么知道它能不能够删除呢？那就要看它是否还有儿子。如果这个非叶子节点的儿子都被删除了，说明它的儿子都是不足节点（仔细读题（说实话，题目描述有点垃圾了），只要是通过这个非叶子节点<code>node</code>的每种可能的“根-叶”路径上值的总和全都小于给定的<code>limit</code>，那么这个非叶子节点就是不足节点），也就说明当前这个非叶子节点每种可能的“根-叶”路径上值的总和小于<code>limit</code>了，那么就需要删除它。如果它存在一个儿子不是不足节点，那我们就不能够删除它。</p><div class="note note-warning">            <p>如果还是不理解的话，简单来说，非叶子节点<code>node</code>的儿子都被删除的话，那它也需要删除；如果非叶子节点存在儿子未被删除，那它就不能删除。</p>          </div><p>那么就可以利用递归，往下传递的就是当前路径值，往回归的就是自身或者是<code>null</code>（判断为不足节点，被删除了，所以返回<code>null</code>）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sufficientSubset</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode], limit: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:<br>        <span class="hljs-comment"># 计算当前路径和</span><br>        limit -= root.val<br>        <span class="hljs-keyword">if</span> root.left <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> root.right <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:  <span class="hljs-comment"># 当前节点为叶子节点</span><br>            <span class="hljs-keyword">return</span> root <span class="hljs-keyword">if</span> limit &lt;= <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>  <span class="hljs-comment"># 判断是否为不足节点</span><br>        <span class="hljs-keyword">if</span> root.left:<br>            root.left = self.sufficientSubset(root.left, limit)  <span class="hljs-comment"># 把值传递下去，判断这条路是否满足条件</span><br>        <span class="hljs-keyword">if</span> root.right:<br>            root.right = self.sufficientSubset(root.right, limit)<br>        <span class="hljs-keyword">return</span> root <span class="hljs-keyword">if</span> root.left <span class="hljs-keyword">or</span> root.right <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>  <span class="hljs-comment"># 如果非叶子节点的儿子都被删除了，它也应该被删除</span><br></code></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#"><br></code></pre></td></tr></table></figure><p>另外看到一个思路略微不同但是写得很佬的题解：<a href="https://leetcode.cn/problems/insufficient-nodes-in-root-to-leaf-paths/solutions/2277376/python3-di-gui-xiang-jie-1080-gen-dao-xi-cc4a/">Broncos的题解</a></p><h1>关于本篇</h1><p>以后还会更新</p><hr>]]></content>
    
    
    <categories>
      
      <category>Solution</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
      <tag>Python</tag>
      
      <tag>Leetcode</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity学习笔记-1</title>
    <link href="/2023/05/20/unity-learning-1/"/>
    <url>/2023/05/20/unity-learning-1/</url>
    
    <content type="html"><![CDATA[<h1>Essential Unity Concepts</h1><h2 id="GameObject">GameObject</h2><p>unity中最最基本的东西，可以说你放入游戏中的那些东西都是一个<code>GameObject</code>，什么玩家人物、障碍、摄像机之类的。<br>在一个<code>GameObject</code>中，又包含了<code>Components</code>，即它的组件（元件），<code>Components</code>可以为<code>GameObject</code>添加一些属性/性质，比如最基本的<code>Transform</code>组件可以控制<code>GameObject</code>的坐标（Position）、旋转（Rotation）和规模（Scale）等。<br>而脚本（<code>Scripts</code>）也算一种组件，脚本是用来控制<code>GameObject</code>的逻辑的，比如有一个<code>Player</code>的<code>GameObject</code>，要想使其进行移动，我们就需要编写一个<code>Move</code>的<code>Script</code>，然后将其添加到<code>Player</code>的<code>Components</code>中。</p><h2 id="Prefabs">Prefabs</h2><p>即预制件，可以理解为我们做好的<code>GameObject</code>的模板。在我们制作好一个<code>GameObject</code>之后，如果我们想要重复利用，就需要将其保存成<code>Prefab</code>，最简单的保存方法就是将<code>GameObject</code>从<code>Hierarchy</code>（层级）选项卡中拖到<code>Project</code>选项卡的<code>Prefabs</code>文件夹中。<br>保存完了后，什么时候我们想要用到这个<code>GameObject</code>了，就直接从<code>Prefabs</code>文件夹中把它拖到<code>Hierarchy</code>中即可。</p><div class="note note-warning">            <p>创建项目不会默认给你生成<code>Prefabs</code>文件夹！但是我们可以自己创建，一般是在<code>Assets</code>文件夹下创建，即<code>Assets/Prefabs</code>。</p>          </div><h2 id="Tags">Tags</h2><p>即标签，其用于给<code>GameObject</code>贴上标签（从而使得其有一种更为广泛的分类），举个最简单的例子，如果我们想要判断一个<code>GameObject</code>是否为敌人，我们能怎么做呢？<s>（当然是看它是否继承自<code>Enemy</code>抽象类）</s>那就是检查它的标签是否为<code>Enemy</code>标签。<br>要为一个<code>GameObject</code>贴上<code>Tag</code>很简单，从<code>Hierarchy</code>中选中，然后在<code>Inspector</code>中就能找到<code>Tag</code>了。<br>现在已经为<code>GameObject</code>添加完<code>Tag</code>了，在脚本中怎么去使用呢？举个简单的例子，现在创建一个行为脚本，让一个<code>GameObject</code>能够注视着有着名为<code>Player</code>的<code>Tag</code>的<code>GameObject</code>：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">GazeExample</span>: <span class="hljs-title">MonoBehaviour</span> &#123;<br>GameObject player;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span> &#123;<br><span class="hljs-comment">// 找到带有 Player 标签的 GameObject</span><br>player = GameObject.FindWithTag(<span class="hljs-string">&quot;Player&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span> &#123;<br><span class="hljs-comment">// 让当前 GameObject 的视角一直对着 player</span><br>transform.LookAt(Player.transform);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Layers">Layers</h2><p>即层级。层级能允许我们在不相关的<code>GameObject</code>之间添加（定义）通用功能，比如在场景视图中绘制哪些对象应忽略光线投射、或者对相机不可见。要改变一个<code>GameObject</code>的层级，也是在<code>Hierarchy</code>中选中，转到<code>Inspector</code>中即可看见。<br>要单独选择哪些层级可见，可以在<code>Inspector</code>的上方的<code>Layers</code>（或者说在整个界面的右上角）中选择。<br><s>（个人觉得可以理解成画画里边的图层？）</s></p><hr>]]></content>
    
    
    <categories>
      
      <category>Learning Log</category>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IP和字符串的相互转换</title>
    <link href="/2023/05/15/ip2str/"/>
    <url>/2023/05/15/ip2str/</url>
    
    <content type="html"><![CDATA[<h1>来源</h1><p>本文出自：<a href="https://blog.csdn.net/mhmyqn/article/details/48653157">MySQL如何有效的存储IP地址及字符串IP和数值之间如何转换</a></p><h1>写法</h1><p>仔细想想，<code>IPv4</code>的每一部分其实都是<code>0~255</code>的取值，也就是<code>8 bit</code>的大小，如果转换成整型那么就只需要<code>32 bit</code>即<code>4</code>个字节的大小。<br>而转换的方法也是顺着这个思路，先把字符串以<code>.</code>为分隔符分成四部分，再把这四部分进行位操作后加起来，就能得到整型的<code>IPv4</code>地址了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Mikan</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 把字符串IP转换成long</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> ipStr 字符串IP</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> IP对应的long值</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">ip2Long</span><span class="hljs-params">(String ipStr)</span> &#123;<br>String[] ip = ipStr.split(<span class="hljs-string">&quot;\\.&quot;</span>);<br><span class="hljs-keyword">return</span> (Long.valueOf(ip[<span class="hljs-number">0</span>]) &lt;&lt; <span class="hljs-number">24</span>) + (Long.valueOf(ip[<span class="hljs-number">1</span>]) &lt;&lt; <span class="hljs-number">16</span>)<br>+ (Long.valueOf(ip[<span class="hljs-number">2</span>]) &lt;&lt; <span class="hljs-number">8</span>) + Long.valueOf(ip[<span class="hljs-number">3</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><p>那么转换回去的思路也大差不差，先用位操作得到四个部分，再进行转型和字符串合并。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 把IP的long值转换成字符串</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> ipLong IP的long值</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> long值对应的字符串</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">long2Ip</span><span class="hljs-params">(<span class="hljs-type">long</span> ipLong)</span> &#123;<br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">ip</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>ip.append(ipLong &gt;&gt;&gt; <span class="hljs-number">24</span>).append(<span class="hljs-string">&quot;.&quot;</span>);<br>ip.append((ipLong &gt;&gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xFF</span>).append(<span class="hljs-string">&quot;.&quot;</span>);<br>ip.append((ipLong &gt;&gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xFF</span>).append(<span class="hljs-string">&quot;.&quot;</span>);<br>ip.append(ipLong &amp; <span class="hljs-number">0xFF</span>);<br><span class="hljs-keyword">return</span> ip.toString();<br>&#125;<br></code></pre></td></tr></table></figure><p>比较尴尬的是<code>java</code>没有无符号整型，只好直接使用长整型来存储了（不觉得另一种意义上的十分浪费吗.jpg）。</p><h1>写在最后</h1><p>原文中提到<code>MySQL</code>中是自带相应函数来把字符串格式的IP转换成整数的<code>INET_ATON</code>和IP转换成字符串的<code>INET_NTOA</code>的，还有适应<code>IPv6</code>的<code>INET6_ATON</code>和<code>INET6_NTOA</code>，之后可以学习一下。</p>]]></content>
    
    
    <categories>
      
      <category>Essay</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis-Plus学习笔记-1</title>
    <link href="/2023/05/09/mybatis-plus-1/"/>
    <url>/2023/05/09/mybatis-plus-1/</url>
    
    <content type="html"><![CDATA[<h1>快速入门</h1><p>假设我们现在有一个映射数据库中<code>user</code>表的实体类<code>User</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br><span class="hljs-keyword">private</span> Long id;<br><span class="hljs-keyword">private</span> String name;<br><span class="hljs-keyword">private</span> Integer age;<br><span class="hljs-keyword">private</span> String email;<br>&#125;<br></code></pre></td></tr></table></figure><p>要使用<code>MyBatis-Plus</code>进行<code>CRUD</code>操作，就在<code>Mapper</code>文件夹下编写对应的<code>Mapper</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseMapper</span>&lt;User&gt; &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>然后在启动类中添加<code>@MapperScan</code>注解，扫描<code>Mapper</code>文件夹即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@MapperScan(&quot;com.me.quickstart.mapper&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(Application.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1>注解</h1><h2 id="TableName">@TableName</h2><ul><li>描述：表名注解，标识实体类对应的表</li><li>使用位置：实体类<br>一般来说只需要知道<code>value</code>属性（即表名）就行了。用法：<code>@TableName(value=&quot;sys_user&quot;)</code>，<code>@TableName(&quot;sys_user&quot;)</code></li></ul><h2 id="TableId">@TableId</h2><ul><li>描述：主键注解</li><li>使用位置：实体类主键字段<br>用法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@TableId</span><br><span class="hljs-keyword">private</span> Long id;<br></code></pre></td></tr></table></figure><h2 id="TableField">TableField</h2><ul><li>描述：字段注解（非主键）<br>用法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@TableField(&quot;nickname&quot;)</span><br><span class="hljs-keyword">private</span> String name;<br></code></pre></td></tr></table></figure><h1>CRUD接口</h1><p>建议转到文档看：<a href="https://www.baomidou.com/pages/49cc81/#service-crud-%E6%8E%A5%E5%8F%A3">CRUD接口</a></p><h2 id="Chain">Chain</h2><h3 id="query">query</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 链式查询 普通</span><br>QueryChainWrapper&lt;T&gt; <span class="hljs-title function_">query</span><span class="hljs-params">()</span>;<br><span class="hljs-comment">// 链式查询 lambda 式。注意：不支持 Kotlin</span><br>LambdaQueryChainWrapper&lt;T&gt; <span class="hljs-title function_">lambdaQuery</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// 示例：</span><br>query().eq(<span class="hljs-string">&quot;column&quot;</span>, value).one();<br>lambdaQuery().eq(Entity::getId, value).list();<br></code></pre></td></tr></table></figure><h3 id="update">update</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 链式更改 普通</span><br>UpdateChainWrapper&lt;T&gt; <span class="hljs-title function_">update</span><span class="hljs-params">()</span>;<br><span class="hljs-comment">// 链式更改 lambda 式。注意：不支持 Kotlin</span><br>LambdaUpdateChainWrapper&lt;T&gt; <span class="hljs-title function_">lambdaUpdate</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// 示例：</span><br>update().eq(<span class="hljs-string">&quot;column&quot;</span>, value).remove();<br>lambdaUpdate().eq(Entity::getId, value).update(entity);<br></code></pre></td></tr></table></figure><h2 id="ActiveRecord模式">ActiveRecord模式</h2><div class="note note-success">            <p><strong>说明</strong>：</p><ul><li>实体类只需继承Model类即可进行强大的CRUD操作</li><li>需要项目中已注入对应实体的BaseMapper</li></ul>          </div><p>用法：</p><ul><li>继承Model</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Model</span>&lt;User&gt;&#123;<br><span class="hljs-comment">// fields...</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>调用CRUD方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>user.insert();<br></code></pre></td></tr></table></figure><h2 id="Db类">Db类</h2><div class="note note-success">            <p><strong>说明</strong>：</p><ul><li>使用静态调用的方式，执行CRUD方法，避免<code>Service</code>循环注入。</li><li>需要项目中已注入对应实体的BaseMapper</li><li>对于参数为Wrapper的，需要在Wrapper中传入Entity或者EntityClass供寻找对应的Mapper</li><li>不建议在循环中调用，如果是批量保存，建议将数据构造好后使用 Db.saveBatch(数据) 保存</li></ul>          </div><p>用法参见：<a href="https://gitee.com/baomidou/mybatis-plus/blob/3.0/mybatis-plus/src/test/java/com/baomidou/mybatisplus/test/toolkit/DbTest.java">测试用例</a></p><h1>条件构造器</h1><h2 id="AbstractWrapper">AbstractWrapper</h2><p>用于生成<code>sql</code>的<code>where</code>条件，<code>entity</code>属性也用于生成<code>sql</code>的<code>where</code>条件。同时也是<code>QueryWrapper(LambdaQueryWrapper)</code>和<code>UpdateWrapper(LambdaUpdateWrapper)</code>的父类。<br>方法参照：<a href="https://www.baomidou.com/pages/10c804/#abstractwrapper">条件构造器</a></p><h2 id="使用方法">使用方法</h2><p>继续使用最开始提到的<code>User</code>实体类，假设<code>id</code>对应数据库中的<code>uid</code>字段。</p><h3 id="QueryWrapper">QueryWrapper</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 查询条件构造器</span><br>QueryWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br>wrapper.eq(<span class="hljs-string">&quot;uid&quot;</span>, id);<br><span class="hljs-comment">// 查询操作</span><br>List&lt;User&gt; users = userMapper.selectList(wrapper);<br></code></pre></td></tr></table></figure><p>引入<code>lambda</code>来避免硬编码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">QueryWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br>wrapper.lambda().eq(User::getId, id);<br><span class="hljs-comment">// 查询操作</span><br>List&lt;User&gt; users = userMapper.selectList(wrapper);<br></code></pre></td></tr></table></figure><h3 id="LambdaQueryWrapper">LambdaQueryWrapper</h3><p>上面的简化版本，使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">LambdaQueryWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;User&gt;().lambda();<br>wrapper.eq(User::getId, id);<br>List&lt;User&gt; user = userMapper.selectList(wrapper);<br></code></pre></td></tr></table></figure><p>简化再简化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">LambdaQueryWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();<br>wrapper.eq(User::getId, id);<br>List&lt;User&gt; user = userMapper.selectList(wrapper);<br></code></pre></td></tr></table></figure><h3 id="UpdateWrapper">UpdateWrapper</h3><p>既然都有查询用的<code>wrapper</code>那肯定也有更新用的<code>wrapper</code>啦，使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">UpdateWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">UpdateWrapper</span>&lt;&gt;();<br>wrapper.set(<span class="hljs-string">&quot;user_name&quot;</span>, name);<br>wrapper.eq(<span class="hljs-string">&quot;uid&quot;</span>, id);<br>userMapper.update(<span class="hljs-literal">null</span>, wrapper);<br></code></pre></td></tr></table></figure><h3 id="LambdaUpdateWrapper">LambdaUpdateWrapper</h3><p>那其实用法和上面的<code>lambda</code>查询差不多</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">LambdaUpdateWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaUpdateWrapper</span>&lt;User&gt;()<br>.eq(User::getId, id)<br>.set(User::getName, name);<br>userMapper.udpate(<span class="hljs-literal">null</span>, wrapper);<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>Learning Log</category>
      
      <category>MyBatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SQL</tag>
      
      <tag>Spring</tag>
      
      <tag>MyBatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker(🐋)学习笔记-1</title>
    <link href="/2023/04/27/docker-learning-1/"/>
    <url>/2023/04/27/docker-learning-1/</url>
    
    <content type="html"><![CDATA[<h1>Docker是什么？</h1><p><s>是一条🐋</s>是一个应用容器引擎。反正就是你可以用它来打包、传输和新机器上快速部署应用。（为应用提供一个独立的、隔离的沙盒环境）</p><h2 id="什么是容器？">什么是容器？</h2><p>这里引用官方文档的原文，一个容器可以总结以下几点：</p><ul><li>是一个镜像的可运行实例。你能够通过使用DockerAPI和CLI来创建、启动、停止、移动或是删除一个容器。</li><li>可以运行在本地或虚拟机上，又或是部署在云上。</li><li>是便携的（可运行在任何操作系统上）</li><li>和其他的容器是隔离的，并且运行它自己拥有的软件、二进制文件和配置。</li></ul><h1>在自己的机器上安装Docker</h1><p>官方提供了三种平台（Mac、Windows、Linux）的安装文档：<a href="https://docs.docker.com/get-docker/">Get Docker</a>。我自己是Windows平台。</p><div class="note note-warning">            <p>Docker的安装可能比较复杂（因为还需要Windows安装Linux子系统和虚拟机平台支持什么的）！请耐心一步一步来并解决各种问题！</p>          </div><p>安装成功后的<code>Docker Desktop</code>界面：<img src="http://imagehost.map1e-g.cn/Docker/docker_interface_1.jpg" alt="Docker Desktop"><br>同样的，你也可以在命令行中使用<code>docker run hello-world</code>命令进行验证，安装好后应该如图所示：<img src="http://imagehost.map1e-g.cn/Docker/docker_cli_1.jpg" alt="Docker Cli"></p><h1>跟着官方创建一个容器并在其上面启动app</h1><p>首先，我们把项目克隆到本地：<code>git clone https://github.com/docker/getting-started.git</code>。<br>然后在<code>vscode</code>中打开项目文件夹（当然了，<code>vscode</code>需要<strong>安装Docker</strong>扩展）。<br>注意到目录中的<code>Dockerfile</code>了吗？它是个简单的指令脚本，而且没有文件扩展，<code>Docker</code>就是用这个脚本来构建容器镜像的。<br>现在，让我们在当前文件夹的子文件夹<code>app</code>中创建一个<code>Dockerfile</code>脚本。</p><ul><li>第一步，打开<code>vscode</code>的悬浮命令行面板（快捷键为<code>Ctrl+Shift+P</code>），输入<code>Terminal</code>，找到<code>Terminal:Create New Terminal</code>并单击。</li><li>哦，当然，记得使用<code>Command Prompt</code>而不是使用<code>Powershell</code>，下面的命令在<code>Powershell</code>中并不适用。要使用<code>Command Prompt</code>，在刚刚弹出的终端窗口的右上角，点击<code>+</code>和<code>...</code>之间的按钮，在弹出的列表中选择即可。</li><li>第二步，执行以下命令：<code>cd app</code>，进入<code>app</code>文件夹；<code>type nul &gt; Dockerfile</code>，创建<code>Dockerfile</code>脚本文件。<br>然后将以下内容复制到<code>Dockerfile</code>中：</li></ul><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Docker"><span class="hljs-comment"># syntax=docker/dockerfile:1</span><br>   <br><span class="hljs-keyword">FROM</span> node:<span class="hljs-number">18</span>-alpine<br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> . .</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> yarn install --production</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;node&quot;</span>, <span class="hljs-string">&quot;src/index.js&quot;</span>]</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">3000</span><br></code></pre></td></tr></table></figure><p>第一行的<code>FROM</code>指令初始化了一个新的构建阶段并为后续指令设置基本镜像，一个合法的<code>Dockerfile</code>必须以该指令开头。<br>第二行的<code>WORKDIR</code>就是为后续的<code>RUN</code>、<code>CMD</code>、<code>ENTRYPOINT</code>、<code>COPY</code>和<code>ADD</code>设置工作路径。<br>第三行的<code>COPY</code>指令从<code>&lt;src&gt;</code>复制新文件或目录，并将它们添加到容器的文件系统路径<code>&lt;dest&gt;</code> <code>中。   第四行的</code>RUN<code>就是执行跟在其后面的指令。   第五行的</code>CMD<code>指令的主要目的是为正在执行的容器提供默认值，这些默认值可以包含可执行文件，也可以在你指定</code>ENTRYPOINT<code>的情况下省略可执行文件。   第六行的</code>EXPOSE<code>指令告知</code>Docker<code>容器在运行的时候监听指定的网络端口，你可以指定端口是监听UDP还是TCP（</code>EXPOSE 3000/udp<code>），默认为TCP。   那么接下来就能够构建一个容器镜像了。在</code>app<code>目录下使用如下命令：</code>docker build -t getting-started .`（了解更多有关该指令的信息，可以参考<a href="https://docs.docker.com/get-started/02_our_app/">官方文档</a>）</p><div class="note note-warning">            <p>如果本地没有所需要的镜像（<code>FROM</code>指定的），那么<code>Docker</code>就需要从网上拉取。</p>          </div><p>最后一步，在我们的容器里启动app！输入指令：<code>docker run -dp 3000:3000 getting-started</code>来启动。</p><h1>更新应用</h1><p>TO DO…</p><h1>参考文档</h1><p>Docker官方文档。</p><hr>]]></content>
    
    
    <categories>
      
      <category>Learning Log</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>VSCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring学习笔记-1</title>
    <link href="/2023/04/26/spring-learning-1/"/>
    <url>/2023/04/26/spring-learning-1/</url>
    
    <content type="html"><![CDATA[<h1>开发环境搭建</h1><p>我选择的<code>IDE</code>是<code>vscode</code>，原因是轻巧、简单、好用（最重要的是免费），不过在进行开发之前，我们需要对<code>vscode</code>进行一些环境搭建和配置。<br>如何在<code>vscode</code>上面编写<code>Java</code>程序和编写<code>Spring Boot</code>项目，在<code>vscode</code>的官方文档中都能够找到，在这里放出链接：</p><ul><li><a href="https://code.visualstudio.com/docs/java/java-tutorial">Setting up VS Code for Java development</a></li><li><a href="https://code.visualstudio.com/docs/java/java-spring-boot">Spring Boot in Visual Studio Code</a><br>在搭建环境过程中如果遇到问题，请善用搜索引擎<s>或者技术群群友</s>。<br>根据上面两个网站走完流程，应该能够成功启动一个<code>Spring Boot</code>项目。<br>当然了，如果不想自己创建一个<code>Spring Boot</code>应用的话，也可以直接使用<code>git clone</code>拉一个项目直接运行测试结果，这里以<code>https://github.com/spring-guides/gs-spring-boot.git</code>为例。<br>使用<code>Ctrl+Shift+P</code>打开命令面板，输入<code>git clone</code>，然后输入<code>https://github.com/spring-guides/gs-spring-boot.git</code>，选好文件夹，等待完成即可。<br>拉取完成之后，切换到左边侧栏的<code>Spring Boot Dashboard</code>面板，里面应该会自动更新，参考下图：<br><img src="http://imagehost.map1e-g.cn/SpringBootLearning/1/dashboard.jpg" alt="1638"><br>我们可以直接从<code>APPS</code>里面启动我们想要启动的应用，这里我启动的是<code>spring-boot-complete</code>，启动完成后参考下图：<br><img src="http://imagehost.map1e-g.cn/SpringBootLearning/1/greet_from_vscode.jpg" alt="1638"></li></ul><h1>SpringBoot配置</h1><h2 id="自定义配置类">自定义配置类</h2><p>在<code>Spring 3.0</code>之后，不再需要<code>XML</code>配置文件了，可以使用<code>@Configuration</code>注解来代替<code>XML</code>配置文件。而<code>@SpringBootConfiguration</code>是Spring Boot应用的专用配置类注解，其作用等效于<code>@Configuration</code>，用哪个都可以。<br><code>Spring 3.0+</code>中有一整套的注解来代替<code>XML</code>配置文件中的定义，如<code>@Bean</code>等。</p><h2 id="导入配置">导入配置</h2><p><code>Spring Boot</code>会自动扫描当前包下的配置类，但是如果配置类在其他子包中，又或者在依赖的<code>jar</code>包中，我们就需要手动导入配置类，使用<code>@Import</code>注解来导入配置类。<br>不过<code>@SpringBootApplication</code>注解包含了<code>@ComponentScan</code>注解并扫描所有子包目录，所以一般来说即使配置类在其他子包中，我们也不需要自己导入配置类。必要时，直接使用<code>@ComponentScan</code>来添加要扫描的路径，会比<code>@Import</code>方便。<br>如果这些配置类都在类扫描路径下，就不需要通过<code>@Import</code>导入了。<br><code>Spring</code>框架还提供了一个<code>@ImportResource</code>注解，可以用于导入额外的<code>XML</code>配置文件，指定要导入的文件路径即可。</p><h2 id="配置文件">配置文件</h2><p>配置文件有两种格式，一种是<code>.properties</code>格式：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql://$&#123;MYSQL_HOST:localhost&#125;:3306/db_example</span><br><span class="hljs-attr">spring.datasource.username</span>=<span class="hljs-string">springuser</span><br><span class="hljs-attr">spring.datasource.password</span>=<span class="hljs-string">ThePassword</span><br><span class="hljs-attr">spring.datasource.driver-class-name</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br></code></pre></td></tr></table></figure><p>另外一种是<code>.yml</code>格式：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://$&#123;MYSQL_HOST:localhost&#125;:3306/db_example</span><br><span class="hljs-attr">username:</span> <span class="hljs-string">springuser</span><br><span class="hljs-attr">password:</span> <span class="hljs-string">ThePassword</span><br><span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br></code></pre></td></tr></table></figure><p><code>.yml</code>格式的格式说明：</p><ul><li>键冒号后面需要带一个空格</li><li>每个层级的缩进用两个空格<br>需要注意的是<code>.yml</code>配置文件不支持<code>@PropertySource</code>注解来导入配置，但是可以使用<code>@ConfigurationProperties</code>注解。</li></ul><h2 id="配置绑定">配置绑定</h2><h3 id="参数绑定">参数绑定</h3><p>首先编写<code>application.yml</code>配置文件：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">user:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">Maple</span><br>  <span class="hljs-attr">age:</span> <span class="hljs-number">18</span><br>  <span class="hljs-attr">params:</span><br>    <span class="hljs-attr">first:</span> <span class="hljs-string">China</span><br>    <span class="hljs-attr">second:</span> <span class="hljs-number">2</span><br>  <span class="hljs-attr">accountInf:</span><br>    <span class="hljs-attr">account:</span> <span class="hljs-number">123456</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br></code></pre></td></tr></table></figure><p>然后新建<code>UserProperties</code>参数类进行参数绑定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;user&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserProperties</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">private</span> Map&lt;String, String&gt; params;<br>    <span class="hljs-keyword">private</span> AccountInf accountInf;<br>&#125;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AccountInf</span> &#123;<br>    <span class="hljs-keyword">private</span> String account;<br>    <span class="hljs-keyword">private</span> String password;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意一下一般参数类的命名规范：<code>XxxProperties</code>。<br>使用<code>@ConfigurationProperties</code>注解可以将配置参数映射到一个<code>Java Bean</code>上，该注解中的<code>prefix</code>或<code>value</code>参数用于指定要映射的参数前缀，前缀格式为英文小写，多个前缀以<code>-</code>分隔。<br>因为<code>@ConfigurationProperties</code>注解绑定配置参数需要用到类的<code>setter</code>方法，所以这里用了<code>@Data</code>注解。<code>Lombok</code>中的<code>@Data</code>注解用于在编译的时候生成类的<code>setter</code>、<code>getter</code>、构造器、<code>toString</code>等方法。<br>然后在启动类上添加<code>@EnableConfigurationProperties</code>注解，用于指定要启用的<code>@ConfigurationProperties</code>参数类，使其生效：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@RequiredArgsConstructor</span><br><span class="hljs-meta">@EnableConfigurationProperties(value = &#123; UserProperties.class &#125;)</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoApplication</span> &#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> UserProperties userProperties;<br><br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> CommandLineRunner <span class="hljs-title function_">commandLineRunner</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> (args) -&gt; &#123;<br>log.info(<span class="hljs-string">&quot;user properties: &#123;&#125;&quot;</span>, userProperties);<br>&#125;;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>SpringApplication.run(DemoApplication.class, args);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1>乱七八糟的</h1><p>其实这里放的是我看一个项目时候顺道学习的东西</p><h2 id="AOP面向切面编程">AOP面向切面编程</h2><p>先上在哪看的概念（公众号：CoderLi）：<a href="https://mp.weixin.qq.com/s/kX6T-WyJWUhOnj4cyEGHmg">AOP 概念篇</a><br><code>AOP</code>就是<code>Aspect Oriented Programming</code>的缩写，也就是面向切面编程，是<code>Spring</code>（注意不是<code>Spring Boot</code>）框架中的一个重要内容。<br>ok，不整这些看了有的没的东西，对我来说，它十分像<code>C#</code>中的委托。首先，我们在某个业务类中有某个业务方法，在执行这个方法前，我们需要进行检查（或说执行某个方法），在执行完这个方法后，我们也需要进行检查（或说执行另一个方法），这时候我们还有另外一个业务类和业务方法，它也需要和前面所说的那样做，那为了这里能够减少重复工作量，<code>AOP</code>就是为此而生的（确信），它先把执行前和执行后要执行的检查提取出来，如果有什么地方需要用的，直接进行注入即可。<br>一个流行的<code>Java AOP</code>框架就是<code>AspectJ</code>，那么在我这个项目里用到的也是它。<br>与<code>AOP</code>相关的概念有（此处出自上面文章，我怕上边文章哪天挂了看不到了）：</p><ul><li>连接点：程序执行的某个特定位置，比如某个方法调用前、调用后，方法抛出异常后，对类成员的访问以及异常处理程序块的执行等。一个类或一段程序代码拥有一些具有边界性质的特定点，这些代码中的特定点就是连接点。它自身还可以嵌套其他的 Joinpoint。AOP 中的 Joinpoint 可以有多种类型：构造方法调用，字段的设置和获取，方法的调用，方法的执行，异常的处理执行，类的初始化。Spring 仅支持方法执行类型的 Joinpoint。</li><li>切点：如果连接点相当于数据中的记录，那么切点相当于查询条件，一个切点可以匹配多个连接点。所以切点表示一组 Joinpoint ，这些 Jointpoint 或是通过逻辑关系组合起来，或是通过通配、正则表达式等方式集中起来，它定义了相应的 Advice 将要发生的地方。</li><li>通知：是织入到目标类连接点上的一段程序代码。Spring 提供的通知接口都是带方位名的，如：BeforeAdvice、AfterReturningAdvice、ThrowsAdvice 等。我们通过 AOP 将横切关注功能加到原有的业务逻辑上，这是对原有业务逻辑的一种增强，可以是前置、后置、返回后、抛出异常时等。其实 Advice 翻译成“增强”更合理，更能准确表达其本质。既然大部分文献都是称为通知，我们这里也称为通知。</li><li>织入（注入）：织入是将Advice通知添加到目标类具体连接点上的过程。编译器织入、动态织入。</li><li>Aspect 切面：Pointcut（切点）和Advice（通知）组成的</li></ul><h2 id="SpringBoot工程结构">SpringBoot工程结构</h2><p>这部分我直接向ChatGPT发起提问，以下是得到的回答：</p><blockquote><p>在一个Spring Boot工程中，通常会使用一些常见的文件夹来存放特定类型的文件，这样可以更好地组织代码和资源。以下是这些文件夹的作用及其用途的简要说明：</p><ol><li><code>config</code> 文件夹：这个文件夹通常用来存放一些配置文件，例如数据库配置文件、缓存配置文件、Spring配置文件等。在Spring Boot中，我们通常会使用Java类来代替传统的XML配置文件，这些Java类通常位于<code>config</code>文件夹中。</li><li><code>controller</code> 文件夹：这个文件夹通常用来存放控制器（Controller）类，这些类用于处理HTTP请求并返回HTTP响应。控制器类通常是Spring MVC应用程序的核心，用于解析和处理请求，调用其他的服务层（Service）和数据访问层（DAO）类，并最终返回响应。</li><li><code>dao</code> 文件夹：这个文件夹通常用来存放数据访问对象（Data Access Object，DAO）类。DAO类通常是用于访问持久化存储层（例如数据库）的类。这些类通常封装了访问数据的逻辑，并与其他层（例如服务层）进行协作，从而实现应用程序的业务逻辑。</li><li><code>handler</code> 文件夹：这个文件夹通常用来存放异常处理器（Exception Handler）类。异常处理器类用于捕获和处理应用程序中的异常，并将它们转换为适当的HTTP响应。异常处理器通常会拦截控制器抛出的异常，根据异常的类型生成适当的HTTP响应，并将其发送回客户端。</li><li><code>service</code> 文件夹：这个文件夹通常用来存放服务层（Service）类。服务层类用于实现应用程序的业务逻辑。这些类通常封装了业务逻辑，并与其他层（例如数据访问层）进行协作，从而实现应用程序的功能。</li><li><code>utils</code> 文件夹：这个文件夹通常用来存放工具类（Utility Class）。工具类通常包含了一些静态方法，用于执行一些通用的、可重用的功能。例如，可以编写一个<code>StringUtils</code>类，其中包含一些静态方法，用于执行字符串操作。</li><li><code>vo</code> 文件夹：这个文件夹通常用来存放值对象（Value Object，VO）类。值对象通常是一些简单的Java类，用于传递数据。它们通常用于在不同层之间传递数据，例如在控制器层和服务层之间。值对象通常不具有行为，而只包含一些属性和getter/setter方法。<br>那么在某些文件夹中还存在子文件夹，同样的，我向ChatGPT发起提问，问它<code>dao</code>文件夹下的<code>mapper</code>和<code>pojo</code>文件夹是什么：<br>是的，通常情况下在 <code>dao</code> 文件夹下会再次细分为 <code>mapper</code> 和 <code>pojo</code> 文件夹。</li><li><code>mapper</code> 文件夹：该文件夹通常包含一些MyBatis的 Mapper 接口，这些接口用于定义数据访问的 SQL 操作。MyBatis 是一种流行的持久化框架，它使用 XML 或注解来映射 Java 对象和数据库表之间的关系。在 <code>mapper</code> 文件夹中，通常会创建一个接口，该接口定义了一组与数据库交互的方法，例如插入数据、更新数据、查询数据等。同时，MyBatis 还提供了一些注解来描述 SQL 语句，例如 <code>@Select</code>、<code>@Update</code>、<code>@Insert</code> 等，这些注解通常会与接口方法一起使用。</li><li><code>pojo</code> 文件夹：该文件夹通常包含一些与数据库表对应的 Java 类，也称为实体类或 POJO（Plain Old Java Object）类。这些类通常与数据库表的每个字段对应，每个字段通常会映射到类中的一个属性。这些类通常使用注解来描述它们与数据库表之间的映射关系，例如 <code>@Table</code>、<code>@Column</code> 等。在访问数据库时，这些类通常用于存储和传输数据。同时，为了方便使用，通常还会在这些类中提供一些 getter 和 setter 方法。<br>综上所述，<code>mapper</code> 文件夹通常包含与数据库交互相关的 MyBatis Mapper 接口和 SQL 语句的注解，而 <code>pojo</code> 文件夹通常包含与数据库表对应的 Java 实体类或 POJO 类。这两个文件夹通常一起使用，以实现应用程序与数据库的数据访问。<br>继续提问<code>service</code>文件夹下的子文件夹：<br>通常情况下，在 <code>service</code> 文件夹下会再次细分为 <code>excel</code>、<code>impl</code> 和 <code>thread</code> 文件夹。</li><li><code>excel</code> 文件夹：该文件夹通常包含一些处理 Excel 文件的类，例如读取 Excel 文件、写入 Excel 文件、生成 Excel 报表等。在这个文件夹中，通常会使用一些第三方的 Excel 处理库，例如 Apache POI、EasyExcel 等。通过这些库，我们可以方便地读取和写入 Excel 文件，并在应用程序中对 Excel 数据进行处理和分析。</li><li><code>impl</code> 文件夹：该文件夹通常包含一些服务接口的实现类，这些实现类通常与数据库交互，并提供业务逻辑的处理。在这个文件夹中，通常会创建一些与服务接口相对应的实现类，这些实现类通常使用 Spring 框架的注解来标识自己，并与数据库访问相关的 DAO 层进行协作。通过这些实现类，我们可以将服务接口中定义的业务逻辑转化为实际的代码实现，并与数据库进行交互。</li><li><code>thread</code> 文件夹：该文件夹通常包含一些与多线程编程相关的类，例如线程池、任务队列、定时任务等。在这个文件夹中，通常会使用 Java 的多线程编程机制来实现一些并发操作，例如通过线程池来管理并发请求，通过任务队列来实现异步处理等。通过这些类，我们可以提高应用程序的并发性能，并更好地利用多核 CPU 的计算资源。<br>综上所述，<code>excel</code> 文件夹通常包含处理 Excel 文件的类，<code>impl</code> 文件夹通常包含服务接口的实现类，<code>thread</code> 文件夹通常包含与多线程编程相关的类。这三个文件夹通常一起使用，以实现应用程序的业务逻辑处理和并发处理。<br>继续提问，<code>vo</code>文件夹下的<code>dos</code>、<code>excelVo</code>、<code>param</code>和<code>QuesVo</code>是什么：<br>在 Spring Boot 项目中，通常会使用 VO（Value Object，值对象）模式来传递数据，这种模式可以将多个实体类的属性组合成一个对象，便于传递和操作。在 <code>vo</code> 文件夹中，通常会包含一些用于传递数据的 VO 类，例如：</li><li><code>Do</code>：<code>Do</code> 表示 <code>Domain Object</code>，是实体类（Entity）的一种命名方式，通常用于表示数据库中的一张表或者一组相关的表。<code>Do</code> 对象通常包含数据库表的所有字段，以及相应的 getter 和 setter 方法。</li><li><code>ExcelVo</code>：在实际开发中，经常需要将数据导出为 Excel 文件或者从 Excel 文件中导入数据。为了方便数据的导入导出，我们可以定义一个 <code>ExcelVo</code> 类，用于存储导出或者导入的数据，并在类中定义相应的属性和方法，以方便操作。</li><li><code>Param</code>：<code>Param</code> 表示 <code>Parameter</code>，用于封装方法调用所需的参数，通常是一个 Java Bean，包含多个属性和相应的 getter 和 setter 方法。</li><li><code>QuesVo</code>：在实际开发中，经常需要处理问卷调查相关的数据。为了方便数据的传递和操作，我们可以定义一个 <code>QuesVo</code> 类，用于封装问卷调查相关的数据，例如问卷标题、问题列表、答案选项等。<br>综上所述，<code>vo</code> 文件夹下的 <code>Do</code>、<code>ExcelVo</code>、<code>Param</code> 和 <code>QuesVo</code> 分别表示数据库实体类、Excel 数据、方法参数和问卷调查相关数据的 VO 类，它们用于传递和操作相应的数据。</li></ol></blockquote><h2 id="可能有用的写法">可能有用的写法</h2><h3 id="List转换成流获取指定属性">List转换成流获取指定属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;User&gt; users = userMapper.selectList();<br>List&lt;String&gt; ids = users.stream().map(User::getId).collect(Collectors.toList());<br></code></pre></td></tr></table></figure><h3 id="List转换成流再用过滤器过滤获取指定数据">List转换成流再用过滤器过滤获取指定数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 假设用户类型type = 0为管理员，type = 1为普通用户</span><br>List&lt;User&gt; users = userMapper.selectList();<br>List&lt;User&gt; admin = users.stream().filter(e -&gt; Objects.equals(e.getType(), <span class="hljs-number">0</span>).collect(Collectors.toList());<br></code></pre></td></tr></table></figure><h3 id="使用stream进行数据分组">使用stream进行数据分组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 根据用户的年龄进行分组</span><br>List&lt;User&gt; users = userMapper.selectList();<br>Map&lt;String, List&lt;User&gt;&gt; collect = users.stream().collect(Collectors.groupingBy(User::getAge));<br><span class="hljs-comment">// 再将其中所有值提取出来，重新组成一个List</span><br>List&lt;List&lt;User&gt;&gt; collectList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(collect.values());<br></code></pre></td></tr></table></figure><h3 id="使用stream的groupBy统计数据">使用stream的groupBy统计数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 根据用户的性别进行分组，并统计个分组的数据总数</span><br>List&lt;User&gt; users = userMapper.selectList();<br>Map&lt;String, Long&gt; aLong = users.stream().collect(Collectors.groupingBy(User::getSex,Collectors.counting()));<br><span class="hljs-comment">// 要访问其中的数据，使用foreach</span><br><span class="hljs-keyword">for</span> (String key: aLong.keySet())&#123;<br>System.out.println(key + <span class="hljs-string">&quot;: &quot;</span> + aLong.getKey(key));<br>&#125;<br>aLong.forEach((k, v) -&gt; &#123;<br>System.out.println(k + <span class="hljs-string">&quot;: &quot;</span> + v);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="js计算百分比">js计算百分比</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 计算百分比</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>   &#123;<span class="hljs-type">number</span>&#125; num   分子</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>   &#123;<span class="hljs-type">number</span>&#125; total 分母</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> &#123;<span class="hljs-type">number</span>&#125; 返回数百分比</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Percentage</span>(<span class="hljs-params">num, total</span>) &#123; <br>    <span class="hljs-keyword">if</span> (num == <span class="hljs-number">0</span> || total == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(num / total * <span class="hljs-number">10000</span>) / <span class="hljs-number">100.00</span>);<span class="hljs-comment">// 小数点后两位百分比</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Excel表相关">Excel表相关</h3><p>合并相同垂直列写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Excel(name=&#x27;xxx&#x27;, mergeVertical=true)</span><br></code></pre></td></tr></table></figure><p>依赖某一列来合并写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Excel(name = &quot;报表类型&quot;, mergeRely = &#123;0&#125;, mergeVertical = true)</span><br></code></pre></td></tr></table></figure><h3 id="el-date-picker相关">el-date-picker相关</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html">以下两句不加的话，发送的载荷里面显示的日期会往前一天，但是到后端其实又没问题，不是很懂<br><span class="hljs-tag">&lt;<span class="hljs-name">el-date-picker</span></span><br><span class="hljs-tag">  <span class="hljs-attr">...</span></span><br><span class="hljs-tag">  <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">value-format</span>=<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span></span><br><span class="hljs-tag">&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el-date-picker</span>&gt;</span><br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>Learning Log</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>VSCode</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis学习笔记-1</title>
    <link href="/2023/04/22/redis-learning-1/"/>
    <url>/2023/04/22/redis-learning-1/</url>
    
    <content type="html"><![CDATA[<h1>Redis是什么？</h1><p>是一个<code>key-value</code>数据库。</p><h1>安装Redis</h1><p><a href="https://github.com/tporadowski/redis/releases">下载点此处</a><br>点击上面跳转到下载界面（github链接，中国大陆可能难以访问），下载<code>zip</code>压缩包形式的文件，然后将其解压到某一处。在该目录下运行终端（<code>cmd</code>），并执行命令：<code>redis-server.exe redis.windows.conf</code>。</p><blockquote><p>ok那么安装这里我卡了半天，之前是用过的，但是现在一启动就：提供无效参数balabala<br>每个人的解决方法可能都不一样，我建议多搜不同方法试<br>我自己是这一句<code>Warning: no config file specified, using the default config.</code>，也就是不能直接使用<code>redis-server</code>启动，而是得打全（也就是指定使用哪个配置文件）：<code>redis-server.exe redis.windows.conf</code>，挺无语的<br>如果成功开启<code>Redis</code>的话，会看到<code>Redis</code>的图标，以及最后一句<code>Ready to accept connections</code>，不要关闭这个窗口，在<code>Redis</code>目录下另外打开一个终端并执行<code>redis-cli.exe -h 127.0.0.1 -p 6379</code>（如果没修改过配置文件直接<code>redis-cli.exe</code>也行，后面的<code>host</code>和<code>port</code>参数都是默认的）。成功连接后显示<code>127.0.0.1:6379&gt;</code>。<br>这里如果遇到目标计算机积极拒绝，那我建议和上面一样上网搜，当然跟上述步骤用<code>cmd</code>成功启动<code>Redis</code>的话我觉得是不会出现这个问题的。</p></blockquote><h1>Redis数据类型</h1><p><code>Redis</code>一共支持五种数据类型：<code>string（字符串）</code>，<code>hash（哈希）</code>，<code>list（列表）</code>，<code>set（集合）</code>，<code>zset(有序集合)</code>。</p><blockquote><p>使用<code>del &lt;key_1&gt; [key_2]...</code>来删除键，使用<code>select &lt;num&gt;</code>来选择数据库。<br>要查看更多命令，可以前往：<a href="https://redis.io/commands/">Redis官网</a></p></blockquote><h2 id="string">string</h2><p>最基本的数据类型，一个<code>key</code>对应一个<code>value</code>。<br>只需要注意一下：“<code>string</code>类型是二进制安全的。意思是<code>Redis</code>的<code>string</code>可以包含任何数据。比如<code>jpg</code>图片或者序列化的对象。<br>相关指令：<code>set &lt;key&gt; &lt;value&gt;</code>，<code>get &lt;key&gt;</code>。</p><h2 id="hash">hash</h2><p><code>Redis hash</code>是一个键值对<strong>集合</strong>。<br>相关指令：<code>hmset &lt;key&gt; &lt;field_1&gt; &lt;value_1&gt; [field_2] [value_2]...</code>，<code>hget &lt;key&gt; &lt;field&gt;</code>。</p><h2 id="list">list</h2><p><code>Redis list</code>是简单的字符串<strong>列表</strong>，依照插入顺序排序。<br>相关指令：<code>lpush &lt;key&gt; &lt;value_1&gt; [value_2]...</code>，<code>rpush &lt;key&gt; &lt;value_1&gt; [value_2]...</code>，<code>lrange &lt;key&gt; &lt;start&gt; &lt;stop&gt;</code>。</p><h2 id="set">set</h2><p><code>Redis set</code>是字符串的无序<strong>集合</strong>。<br>相关指令：<code>sadd &lt;key&gt; &lt;member_1&gt; [member_2]...</code>，<code>smembers &lt;key&gt;</code>。</p><h2 id="zset">zset</h2><blockquote><p>“每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。”<br>“zset的成员是唯一的,但分数(score)却可以重复。”<br>相关指令：<code>zadd &lt;key&gt; &lt;score_1&gt; &lt;member_1&gt; [score_2] [member_2]...</code>，<code>zrangebyscore &lt;key&gt; &lt;min&gt; &lt;max&gt;</code>。</p></blockquote><h2 id="HyperLogLog">HyperLogLog</h2><p>后面添加的新东西，用来做基数统计的算法，基数就是数据集中不重复元素的数量，而这个东西因为是用来计算基数的，所以不会存储输入元素本身。</p><h2 id="Stream">Stream</h2><p>后后面添加的新东西，主要用于消息队列MQ（什么物联网应用）。<br>至于“不是已经有发布订阅模式了吗怎么还有加入个Stream啊？”这个问题，参考网站上说：“但它有个缺点就是消息无法持久化，如果出现网络断开、Redis宕机等，消息就会被丢弃。简单来说发布订阅可以分发消息，但无法记录历史消息。”<br>那么<code>Stream</code>呢？“而 Redis Stream 提供了消息的持久化和主备复制功能，可以让任何客户端访问任何时刻的数据，并且能记住每一个客户端的访问位置，还能保证消息不丢失。”<br>每个<code>Stream</code>都有唯一个名称，这个名称就是<code>Redis</code>的<code>Key</code>。<br>不过菜鸟教程上的<code>Stream</code>这部分也只是讲了些基础命令就没了，消费者组没怎么讲，之后我会找点其他文档看看，再进行补充。总之先把有的讲了吧！<br>下面以一个消息中两个字段来创建一个<code>Stream</code>，并对其进行一些操作。假设我们现在需要记录学生的姓名和他们对应的学号，并放入这个<code>Stream</code>中。</p><div class="note note-warning">            <p>由于<code>Redis</code>自带命令提示，所以下面命令不会给出完整格式。</p>          </div><h3 id="xadd">xadd</h3><p>我们可以用<code>xadd</code>来创建队列和向队列中添加消息。</p><blockquote><p><code>xadd</code>命令格式：<code>xadd key ID field string [field string ...]</code>，<code>ID</code>既可以自己设置，也能够让<code>Redis</code>来设置。自己设置需要保持递增性，如果需要<code>Redis</code>设置，<code>ID</code>处就改为<code>*</code>。</p></blockquote><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; xadd StudentsInf * StudentID <span class="hljs-number">0</span> Name Tom<br><span class="hljs-string">&quot;1682212841653-0&quot;</span><br><span class="hljs-number">127.0.0.1:6379</span>&gt; xadd StudentsInf * StudentID <span class="hljs-number">1</span> Name Amy<br><span class="hljs-string">&quot;1682212847920-0&quot;</span><br><span class="hljs-number">127.0.0.1:6379</span>&gt; xadd StudentsInf * StudentID <span class="hljs-number">2</span> Name Jack<br><span class="hljs-string">&quot;1682212857405-0&quot;</span><br><span class="hljs-number">127.0.0.1:6379</span>&gt; xadd StudentsInf * StudentID <span class="hljs-number">3</span> Name Kevin<br><span class="hljs-string">&quot;1682212867763-0&quot;</span><br><span class="hljs-number">127.0.0.1:6379</span>&gt; xadd StudentsInf * StudentID <span class="hljs-number">4</span> Name Chen<br><span class="hljs-string">&quot;1682213031310-0&quot;</span><br><span class="hljs-number">127.0.0.1:6379</span>&gt; xadd StudentsInf * StudentID <span class="hljs-number">5</span> Name Kanade<br><span class="hljs-string">&quot;1682213051016-0&quot;</span><br></code></pre></td></tr></table></figure><h3 id="xlen">xlen</h3><p>我们可以用<code>xlen</code>来查看指定队列的长度。</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; xlen StudentsInf<br>(integer) <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><h3 id="xrange">xrange</h3><p>要查看指定队列，则使用<code>xrange</code>命令。其中，<code>-</code>代表最小值，<code>+</code>代表最大值</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>&gt; xrange StudentsInf - +<br><span class="hljs-attribute">1</span>) <span class="hljs-number">1</span>) <span class="hljs-string">&quot;1682212841653-0&quot;</span><br>   <span class="hljs-attribute">2</span>) <span class="hljs-number">1</span>) <span class="hljs-string">&quot;StudentID&quot;</span><br>      <span class="hljs-attribute">2</span>) <span class="hljs-string">&quot;0&quot;</span><br>      <span class="hljs-attribute">3</span>) <span class="hljs-string">&quot;Name&quot;</span><br>      <span class="hljs-attribute">4</span>) <span class="hljs-string">&quot;Tom&quot;</span><br><span class="hljs-attribute">2</span>) <span class="hljs-number">1</span>) <span class="hljs-string">&quot;1682212847920-0&quot;</span><br>   <span class="hljs-attribute">2</span>) <span class="hljs-number">1</span>) <span class="hljs-string">&quot;StudentID&quot;</span><br>      <span class="hljs-attribute">2</span>) <span class="hljs-string">&quot;1&quot;</span><br>      <span class="hljs-attribute">3</span>) <span class="hljs-string">&quot;Name&quot;</span><br>      <span class="hljs-attribute">4</span>) <span class="hljs-string">&quot;Amy&quot;</span><br><span class="hljs-attribute">3</span>) <span class="hljs-number">1</span>) <span class="hljs-string">&quot;1682212857405-0&quot;</span><br>   <span class="hljs-attribute">2</span>) <span class="hljs-number">1</span>) <span class="hljs-string">&quot;StudentID&quot;</span><br>      <span class="hljs-attribute">2</span>) <span class="hljs-string">&quot;2&quot;</span><br>      <span class="hljs-attribute">3</span>) <span class="hljs-string">&quot;Name&quot;</span><br>      <span class="hljs-attribute">4</span>) <span class="hljs-string">&quot;Jack&quot;</span><br><span class="hljs-attribute">4</span>) <span class="hljs-number">1</span>) <span class="hljs-string">&quot;1682212867763-0&quot;</span><br>   <span class="hljs-attribute">2</span>) <span class="hljs-number">1</span>) <span class="hljs-string">&quot;StudentID&quot;</span><br>      <span class="hljs-attribute">2</span>) <span class="hljs-string">&quot;3&quot;</span><br>      <span class="hljs-attribute">3</span>) <span class="hljs-string">&quot;Name&quot;</span><br>      <span class="hljs-attribute">4</span>) <span class="hljs-string">&quot;Kevin&quot;</span><br><span class="hljs-attribute">5</span>) <span class="hljs-number">1</span>) <span class="hljs-string">&quot;1682213031310-0&quot;</span><br>   <span class="hljs-attribute">2</span>) <span class="hljs-number">1</span>) <span class="hljs-string">&quot;StudentID&quot;</span><br>      <span class="hljs-attribute">2</span>) <span class="hljs-string">&quot;4&quot;</span><br>      <span class="hljs-attribute">3</span>) <span class="hljs-string">&quot;Name&quot;</span><br>      <span class="hljs-attribute">4</span>) <span class="hljs-string">&quot;Chen&quot;</span><br><span class="hljs-attribute">6</span>) <span class="hljs-number">1</span>) <span class="hljs-string">&quot;1682213051016-0&quot;</span><br>   <span class="hljs-attribute">2</span>) <span class="hljs-number">1</span>) <span class="hljs-string">&quot;StudentID&quot;</span><br>      <span class="hljs-attribute">2</span>) <span class="hljs-string">&quot;5&quot;</span><br>      <span class="hljs-attribute">3</span>) <span class="hljs-string">&quot;Name&quot;</span><br>      <span class="hljs-attribute">4</span>) <span class="hljs-string">&quot;Kanade&quot;</span><br></code></pre></td></tr></table></figure><p>另外，<code>Redis</code>也提供了一个倒序获取消息列表的命令：<code>xrevrange</code>，用法和<code>xrange</code>一致。</p><h3 id="xdel">xdel</h3><p>要删除某一消息，可以使用<code>xdel</code>命令。</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; del StudentsInf <span class="hljs-number">1682212867763</span>-<span class="hljs-number">0</span><br>(integer) <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h1>Redis的发布订阅</h1><p><code>Redis</code>也有发布订阅通信模式，发布者发布信息到频道，频道转发消息给订阅者，示例如下：<br>我们需要打开两个<code>redis-cli</code>，先在第一个里面进行频道订阅</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Redis">127.0.0.1:6379&gt; subscribe MyTestChannel<br>Reading messages... (press Ctrl-C to quit)<br>1) &quot;subscribe&quot;<br>2) &quot;MyTestChannel&quot;<br>3) (integer) 1<br></code></pre></td></tr></table></figure><p>然后来到第二个<code>redis-cli</code>进行信息的发布</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Redis">127.0.0.1:6379&gt; publish MyTestChannel &quot;Test Message 1&quot;<br>(integer) 1<br></code></pre></td></tr></table></figure><p>接着就能看到另外一边显示出信息了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Redis">1) &quot;message&quot;<br>2) &quot;MyTestChannel&quot;<br>3) &quot;Test Message 1&quot;<br></code></pre></td></tr></table></figure><h1>Redis中的事务</h1><p>既然它是个数据库，那很明显它也有事务！（<br><code>Redis</code>的事务处理步骤如下：</p><blockquote><p>开始事务——<code>multi</code><br>命令入队——<code>set</code> or other commands<br>执行事务——<code>exec</code> / 取消事务——<code>discard</code><br>但是要注意的是，如果在执行事务的过程中，有命令执行失败并<strong>不会打断事务执行</strong>，所以也<strong>不会回滚之前的操作</strong>。<br><code>Redis</code>的事务还有一个<code>watch</code>命令可以监视<code>key</code>，如果在事务执行之前这个（或这些）<code>key</code>被其他命令所改动，那么事务将被打断。<br>比如现在有两个<code>redis-cli</code>都在使用同一个数据库，第一个在执行事务，第二个改变了第一个事务中监视的<code>key</code>，那么第一个中的事务将被打断。<br>同样的我们打开两个<code>redis-cli</code>来使用一下<code>watch</code>。在第一个窗口中，我们先使用<code>set</code>命令设置一个键值对：<code>127.0.0.1:6379&gt; set WatchKey &quot;A value&quot;</code>。然后来到第二个窗口，输入如下：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Redis">127.0.0.1:6379&gt; watch WatchKey<br>OK<br>127.0.0.1:6379&gt; multi<br>OK<br>127.0.0.1:6379&gt; get WatchKey<br>QUEUED<br>127.0.0.1:6379&gt; exists WatchKey<br>QUEUED<br>127.0.0.1:6379&gt; set WatchKey &quot;No execute&quot;<br>QUEUED<br></code></pre></td></tr></table></figure><p>上面监视了在第一个窗口设置的<code>WatchKey</code>键，然后设置了一个三条命令的事务。这时候先别执行，回到第一个窗口对<code>WatchKey</code>进行修改，比如删除：<code>127.0.0.1:6379&gt; del WatchKey</code>，执行成功后再在第二个窗口执行事务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Redis">127.0.0.1:6379&gt; exec<br>(nil)<br></code></pre></td></tr></table></figure><p>可以看到<code>exec</code>命令直接返回了<code>null</code>，说明事务没有被执行。</p><h1>Redis数据备份与恢复</h1><p>要备份数据库，可以使用<code>save</code>或<code>bgsave</code>命令，直接在<code>redis-cli</code>中输入即可，该命令执行后会生成<code>dump.rdb</code>文件。要恢复数据也十分容易，直接将<code>dump.rdb</code>文件置于<code>Redis</code>安装目录并启动服务即可。</p><h1>Redis密码验证</h1><p>为<code>Redis</code>设置密码访问，使用<code>config set requirepass &lt;password&gt;</code>命令即可。如果需要查看密码，使用<code>config get requirepass</code>命令即可。</p><h1>可能遇到的问题</h1><h2 id="redis-cli乱码"><code>redis-cli</code>乱码</h2><p>Solution: <code>redis-cli --raw</code></p><h1>乱七八糟的话</h1><p>也许以后又学到什么<code>Redis</code>相关再放到这里。</p><h1>参考</h1><p><a href="https://www.runoob.com/redis">菜鸟教程Redis</a></p><hr>]]></content>
    
    
    <categories>
      
      <category>Learning Log</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树莓派4B与DHT11、TTP223和BF1750(FVI)</title>
    <link href="/2023/04/09/raspberrypi-essay-1/"/>
    <url>/2023/04/09/raspberrypi-essay-1/</url>
    
    <content type="html"><![CDATA[<h1>DHT11</h1><h2 id="硬件及接线等说明">硬件及接线等说明</h2><p>在开始之前，先放出一个DHT11的数据手册，需要参考的可以点击跳转：<a href="https://cdn-shop.adafruit.com/datasheets/DHT11-chinese.pdf">DHT11数据手册</a><br>这里我自己买的是三脚的DHT11，不过三脚和四脚的接线都是一样的，要接的是<code>VCC</code>、<code>DATA</code>和<code>GND</code>。<br><img src="http://imagehost.map1e-g.cn/RaspberryPi/DHT11_Pin.jpg" alt="DHT11引脚说明"><br>再看到我们的树莓派4B的引脚：<br><img src="http://imagehost.map1e-g.cn/RaspberryPi/RaspberryPi_Pin.png" alt="树莓派4B引脚说明"><br>然后把我们的<code>VCC</code>连接到任意<code>3.3V</code>或<code>5V</code>引脚上，<code>GND</code>连接至任意<code>Ground</code>引脚上，<code>DATA</code>连接到任意GPIO引脚上，我这里以连接到7号引脚上做示例。</p><h2 id="编程环境准备">编程环境准备</h2><p>这里自己用的IDE就是树莓派官方烧录自带的<code>Thonny</code>，编程语言用的<code>Python</code>，然后还需要安装一个第三方库<code>Adafruit_DHT</code>，安装该库使用以下命令：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/adafruit/</span>Adafruit_Python_DHT.git<br>cd Adafruit_Python_DHT<br></code></pre></td></tr></table></figure><p>OK，现在先停一下，因为这个库最后更新是19年，会导致树莓派4B无法使用，因为驱动未支持树莓派4B的处理器<code>BCM2711</code>，我们需要手动为其添加支持。打开当前目录下的<code>Adafruit_DHT</code>，编辑<code>platform_detect.py</code>，并添加以下内容（如果你没动过代码，那么下列语句应该添加在第111行之后，如果博文内容过期了也没关系，因为你应该能很好地看出来下面这句应该放在哪里）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">elif</span> match.group(<span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;BCM2711&#x27;</span>:<br>   <span class="hljs-comment"># Pi 4b</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><blockquote><p>这里插入一点题外话，树莓派4B虽然用的是BCM2711但是某些命令显示出来会是BCM2835（貌似），查了下原因没懂（逃<br>如果你觉得需要权限编辑很麻烦，建议多使用控制台，遇事不决命令前加<code>sudo</code>。<br>编辑完成后就是安装库了，执行该命令：<code>sudo python setup.py install</code>，当然我不知道你的树莓派上<code>python</code>和<code>python3</code>是不是一个版本（有人的树莓派装了<code>python2</code>和<code>python3</code>），不是的话就再执行下<code>sudo python3 setup.py install</code>。<br>在网上看到的其他博文都说要更新软件包，反正我没更新，如果硬要更新的话，记得注意<code>sudo apt-get install build-essential python-dev</code>输出的说明，可能是把<code>python3</code>的卸了装<code>python2</code>的（？）</p></blockquote><h2 id="编写程序">编写程序</h2><p>当然你也可以不写，因为<code>Adafruit</code>提供了示例程序，可以直接运行程序测试，示例程序就在<code>Adafruit_Python_DHT</code>目录下的<code>examples</code>文件夹里，在当前目录的终端下执行：<code>python AdafruitDHT.py 11 4</code>即可。</p><blockquote><p>如果你不知道怎么进入目录，我还是那句话，建议多使用控制台，记住最基本的命令是好的。现在就先参考下面的命令吧：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~<br><span class="hljs-built_in">cd</span> Adafruit_Python_DHT/examples<br></code></pre></td></tr></table></figure></blockquote><p>那么<code>python AdafruitDHT.py 11 4</code>后面的<code>11</code>和<code>4</code>是什么意思呢？看到源码里面写的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># Parse command line parameters.</span><br>sensor_args = &#123; <span class="hljs-string">&#x27;11&#x27;</span>: Adafruit_DHT.DHT11,<br>                <span class="hljs-string">&#x27;22&#x27;</span>: Adafruit_DHT.DHT22,<br>                <span class="hljs-string">&#x27;2302&#x27;</span>: Adafruit_DHT.AM2302 &#125;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(sys.argv) == <span class="hljs-number">3</span> <span class="hljs-keyword">and</span> sys.argv[<span class="hljs-number">1</span>] <span class="hljs-keyword">in</span> sensor_args:<br>    sensor = sensor_args[sys.argv[<span class="hljs-number">1</span>]]<br>    pin = sys.argv[<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><p>所以在这里，第一个参数<code>11</code>代表传感器的型号，这里支持三种传感器的数据读取；而第二个参数<code>4</code>代表的是GPIO的编号，注意不是板编号，虽然我用的<code>GPIO 4</code>是7号引脚，但是GPIO编号是<code>4</code>，所以这里传入的参数是<code>4</code>。<br>下面就由我们自己来编写程序。在这里，我编写的是一个每秒读一次数据并打印到终端的程序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> Adafruit_DHT<br><br>sensor=Adafruit_DHT.DHT11<br>gpio=<span class="hljs-number">4</span><br><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>):<br>    humidity, temperature = Adafruit_DHT.read_retry(sensor, gpio)<br>    <span class="hljs-keyword">if</span> humidity <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> temperature <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>      <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Temp=&#123;0:0.1f&#125;*C  Humidity=&#123;1:0.1f&#125;%&#x27;</span>.<span class="hljs-built_in">format</span>(temperature, humidity))<br>    <span class="hljs-keyword">else</span>:<br>      <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Failed to get reading. Try again!&#x27;</span>)<br>      time.sleep(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>可以看到代码简洁易懂，直接调库就行，省略了复杂的读取数据、计算数据和校验数据的步骤（坏处是没学到什么东西.jpg）。</p><h1>TTP223</h1><p>我买的是这样的：<img src="http://imagehost.map1e-g.cn/RaspberryPi/TTP223.jpg" alt="TTP223"><br>这个就好懂了，<code>VCC</code>和<code>GND</code>和上面的<code>DHT11</code>的一样，剩下的<code>SIG</code>也是接任意一个<code>GPIO</code>引脚即可，下面的程序我接的是<code>GPIO_17</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> RPi.GPIO <span class="hljs-keyword">as</span> GPIO<br><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> sleep<br>GPIO.setmode(GPIO.BCM)<br>GPIO.setup(<span class="hljs-number">17</span>, GPIO.IN)<br>GPIO.setup(<span class="hljs-number">17</span>, GPIO.IN, pull_up_down=GPIO.PUD_UP)<br><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        sleep(<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">if</span> GPIO.<span class="hljs-built_in">input</span>(<span class="hljs-number">17</span>) == GPIO.HIGH:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;touch!&#x27;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;nothing happen.&#x27;</span>)<br><span class="hljs-keyword">except</span> KeyboardInterrupt:<br>    GPIO.cleanup()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;GPIO cleanup()&#x27;</span>)<br></code></pre></td></tr></table></figure><p>现在来解释一下，引入<code>RPi.GPIO</code>这个库，<code>GPIO</code>引脚编码设置为<code>BCM</code>编码，然后把<code>BCM</code>编码下的<code>17</code>号引脚设置为输入模式，因为我们需要从中读取引脚电平状态来知道传感器是否被触摸；<code>GPIO.setup(17, GPIO.IN, pull_up_down=GPIO.PUD_UP)</code>这一句的话，翻译一下就是设置上拉电阻，关于上下拉电阻有什么作用，可以百度一下（<br>当我们触摸板检测到触摸时，引脚就会输出高电平，所以我们只需要通过检测引脚此刻电平状态，就能知道是否存在触摸，然后进行我们需要进行的操作即可。</p><h1>BH1750(FVI)</h1><h2 id="硬件及接线说明">硬件及接线说明</h2><p>前排提示：这个东西是要自己焊的，如果你不会焊或者从来没接触过焊接引脚的，我的建议是找找焊接好的，不要折磨自己（<br><img src="http://imagehost.map1e-g.cn/RaspberryPi/BH1750_Pin.jpg" alt="BH1750引脚说明"><br>BH1750是通过<code>I2C</code>协议进行数据传输的，所以在这里我们需要用到树莓派的3号引脚（<code>GPIO 2</code>）和5号引脚（<code>GPIO 3</code>），分别是<code>SDA</code>和<code>SCL</code>。<br>BH1750的接线也十分简单明了，<code>VCC</code>和<code>GND</code>与前面接线说明一样，另外两个<code>SDA</code>和<code>SCL</code>引脚也是刚好对应树莓派4B上的两个GPIO引脚。<br>不过需要注意的是，如果在终端使用<code>gpio readall</code>命令的话，我们会发现树莓派4B提供了<code>SDA 1</code>、<code>SCL 1</code>和<code>SDA 0</code>、<code>SCL 0</code>两对<code>I2C</code>接口，但是我们需要用到的是<code>1</code>，并且这个<code>0</code>在默认情况下应该是无法使用的（看别人说的，自己貌似没试过），也有说把摄像头关了就能使用，如果有兴趣可以自己试试。<br><img src="http://imagehost.map1e-g.cn/RaspberryPi/BH1750_Function.jpg" alt="BH1750功能说明"><br>上面这些图的功能说明，就是告诉我们，向BH1750送入这些数据，BH1750会执行什么操作，可以理解为命令。</p><h2 id="树莓派4B开启I2C和下载i2c-tools">树莓派4B开启I2C和下载i2c-tools</h2><p>接完线后，我们仍需要配置一些东西。现在先来打开树莓派4B的<code>I2C</code>功能。<br>首先，打开终端，然后在终端输入命令<code>sudo raspi-config</code>，进入设置界面。<br>使用方向键移动，使用回车确认，进入<code>3 Interface Options</code>，选择第五项<code>I5 I2C</code>，然后选择<code>Yes</code>，退出并重启系统（重启可使用<code>sudo reboot</code>）。至此，就启用了树莓派的<code>I2C</code>功能了。<br>接下来是安装<code>i2c-tools</code>，打开终端输入命令：<code>sudo apt-get install i2c-tools</code>等待安装完成即可。<br>安装成功后，输入<code>sudo i2cdetect -l</code>来检查一下我们使用的接口：<br><img src="http://imagehost.map1e-g.cn/RaspberryPi/i2cdetect-l.jpg" alt=""><br>出现<code>i2c-1</code>说明使用的是<code>I2C1</code>的接口，也就是<code>SDA 1</code>和<code>SCL 1</code>。<br>然后再检查一下我们接入的传感器BH1750，在终端输入命令：<code>sudo i2cdetect -y 1</code>进行查看：<br><img src="http://imagehost.map1e-g.cn/RaspberryPi/i2cdetect-l.jpg" alt=""><br>截图上的<code>23</code>就是我们的BH1750的默认地址。<br>至此，配置完成。</p><h2 id="编写程序-2">编写程序</h2><p>终于到编写程序环节了，可喜可贺捏~</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> RPi.GPIO <span class="hljs-keyword">as</span> GPIO<br><span class="hljs-keyword">import</span> smbus<br><span class="hljs-keyword">from</span> paho.mqtt <span class="hljs-keyword">import</span> client <span class="hljs-keyword">as</span> mqtt_client<br><br>GPIO.setmode(GPIO.BCM)<br>GPIO.setup(<span class="hljs-number">17</span>, GPIO.OUT)<br><br><span class="hljs-comment"># BH1750FVI config</span><br>DEVICE = <span class="hljs-number">0x23</span>  <span class="hljs-comment"># Default device I2C address</span><br>POWER_DOWN = <span class="hljs-number">0x00</span><br>POWER_ON = <span class="hljs-number">0x01</span><br>RESET = <span class="hljs-number">0x07</span><br>CONTINUOUS_LOW_RES_MODE = <span class="hljs-number">0x13</span><br>CONTINUOUS_HIGH_RES_MODE_1 = <span class="hljs-number">0x10</span><br>CONTINUOUS_HIGH_RES_MODE_2 = <span class="hljs-number">0x11</span><br>ONE_TIME_HIGH_RES_MODE_1 = <span class="hljs-number">0x20</span><br>ONE_TIME_HIGH_RES_MODE_2 = <span class="hljs-number">0x21</span><br>ONE_TIME_LOW_RES_MODE = <span class="hljs-number">0x23</span><br>bus = smbus.SMBus(<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># MQTT broker config</span><br>broker = <span class="hljs-string">&#x27;******&#x27;</span><br>port = ******<br>topic = <span class="hljs-string">&#x27;***&#x27;</span><br>client_id = <span class="hljs-string">&#x27;******&#x27;</span><br>username = <span class="hljs-string">&#x27;***&#x27;</span><br>password = <span class="hljs-string">&#x27;***&#x27;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">read_light</span>():<br>    data = bus.read_i2c_block_data(DEVICE, ONE_TIME_HIGH_RES_MODE_1)<br>    light_level = <span class="hljs-built_in">round</span>((data[<span class="hljs-number">1</span>] + (<span class="hljs-number">256</span> * data[<span class="hljs-number">0</span>])) / <span class="hljs-number">1.2</span>, <span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">return</span> light_level<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">connect_mqtt</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">on_connect</span>(<span class="hljs-params">client, userdata, flags, rc</span>):<br>        <span class="hljs-keyword">if</span> rc == <span class="hljs-number">0</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Connected to MQTT Broker!&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Failed to connect, return code %d\n&quot;</span>, rc)<br>    client = mqtt_client.Client(client_id)<br>    client.username_pw_set(username, password)<br>    client.on_connect = on_connect<br>    client.connect(host=broker, port=port)<br>    <span class="hljs-keyword">return</span> client<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">publish</span>(<span class="hljs-params">client</span>):<br>    msg_count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            time.sleep(<span class="hljs-number">1</span>)<br>            light_level = read_light()<br>            <span class="hljs-keyword">if</span> light_level &gt; <span class="hljs-number">55</span>:<br>                GPIO.output(<span class="hljs-number">17</span>, GPIO.LOW)<br>            <span class="hljs-keyword">else</span>:<br>                GPIO.output(<span class="hljs-number">17</span>, GPIO.HIGH)<br>            publish_msg = &#123;<span class="hljs-string">&#x27;lightLevel&#x27;</span>: light_level&#125;<br>            result = client.publish(<br>                topic,<br>                payload=json.dumps(publish_msg)<br>            )<br>            <span class="hljs-comment"># result: [0, 1]</span><br>            status = result[<span class="hljs-number">0</span>]<br>            <span class="hljs-keyword">if</span> status == <span class="hljs-number">0</span>:<br>                <span class="hljs-built_in">print</span>(publish_msg)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Failed to send message to topic <span class="hljs-subst">&#123;topic&#125;</span>&quot;</span>)<br>    <span class="hljs-keyword">except</span> KeyboardInterrupt:<br>        GPIO.cleanup()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;GPIO.cleanup()&#x27;</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>():<br>    client = connect_mqtt()<br>    client.loop_start()<br>    publish(client)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    run()<br></code></pre></td></tr></table></figure><p>这边解释一些比较重要的语句。<code>bus = smbus.SMBus(1)</code>这里就是实例化，<code>1</code>代表的是<code>/dev/i2c-1</code>。<br><code>read_i2c_block_data(i2c_addr, register, length)</code>，就是从给定的寄存器中读取字节数据块，其中三个参数分别表示：i2c设备的地址、给定的寄存器、读取的长度（最多32位），返回一个字节组成的列表。<br><code>(data[1] + (256 * data[0])) / 1.2</code>就是单纯的计算公式，不用管太多。其他代码的话都是MQTT的模板代码，可以通过官网的文档了解到这些代码的用途：<a href="https://docs.emqx.com/zh/cloud/latest/connect_to_deployments/python_sdk.html">使用Python SDK接入</a>。</p><hr>]]></content>
    
    
    <categories>
      
      <category>Essay</category>
      
      <category>RaspberryPi</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>nano</tag>
      
      <tag>RaspberryPi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Pygame来制作游戏吧！——Pygame学习</title>
    <link href="/2023/03/30/pygame-learning-1/"/>
    <url>/2023/03/30/pygame-learning-1/</url>
    
    <content type="html"><![CDATA[<h1>叠甲</h1><p>所有内容均从<a href="https://www.youtube.com/watch?v=AY9MnQ4x3zk">The ultimate introduction to Pygame</a>获得</p><h1>Pygame基础</h1><h2 id="如何初始化Pygame？">如何初始化Pygame？</h2><p><code>pygame.init()</code>即可</p><h2 id="但是没有弹出窗口">但是没有弹出窗口</h2><p>使用<code>screen = pygame.display.set_mode((x, y))</code>来创建一个大小（解析度）为<code>x * y</code>的窗口，<br>使用<code>pygame.display.set_caption(title)</code>来设置窗口标题<br>但是现在的窗口并不完善，因为只出现<strong>1s</strong>就消失了。要解决这个问题，只需要加个<code>while True</code>保持程序一直运行就好了。<br>但是还需要在循环里添加一句<code>pygame.display.update()</code>，它能够更新我们的窗口里的画面，而不会让我们的窗口一直保持一个帧（画面）不变。</p><div class="note note-warning">            <p>Oops!你可能又发现了一个问题，在点击关闭窗口之后报错了！因为关闭窗口之后程序仍将运行，并且继续执行<code>pygame.display.update()</code>。<br>要解决这个问题，我们会<strong>捕捉关闭窗口事件</strong>，并在捕捉到之后调用Python的<code>exit()</code>方法（此方法在<code>sys</code>库中，需<code>import</code>），退出程序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> pygame.event.get():<br><span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span> == pygame.QUIT:<br>pygame.quit()<br>exit()<br></code></pre></td></tr></table></figure>          </div><h2 id="十分重要的定时器">十分重要的定时器</h2><p>在不同机器上运行同一个游戏，帧数会根据机器的好坏而变得不一致，如果我们不对<code>1s</code>内更新的帧数进行某些限制，那么帧数低的时候所有的事物将变慢，帧数高的时候所有的事物将变快，这是我们不希望看到的，所以我们需要使用定时器。<br>在pygame中，我们使用<code>clock = pygame.time.Clock()</code>来初始化一个定时器，随后，在<code>while True</code>里加入一句<code>clock.time(60)</code>设置每秒最大帧速率进行限制。</p><h2 id="绘制我们想要展示在窗口上的-GameObject-！">绘制我们想要展示在窗口上的&quot;GameObject&quot;！</h2><p>在窗口中加载（绘制）一个图像，我们可以使用以下命令：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Python">image_01 = pygame.image.load(path).convert()<br>screen.blit(image_01, (x, y))<br></code></pre></td></tr></table></figure><p>当然如果是透明图像或图像不是你想象的那个样子，就请使用<code>image_01 = pygame.image.load(path).convert_aplha()</code>方法试试吧。<br>我们还可以绘制文本，具体方法为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Python">test_font = pygame.font.Font(path, size)<br>text_surf = test_font.render(text, AA, color)  <span class="hljs-comment"># AA is Anti-aliasing.The value is True or False.</span><br>screen.blit(text_surf, (x, y))<br></code></pre></td></tr></table></figure><h2 id="使用碰撞箱！">使用碰撞箱！</h2><p>游戏（都）需要有碰撞箱并进行碰撞检测，那么在pygame中，得益于pygame，我们很容易就能获取一个物体的碰撞箱，并使用它们进行各种各样方便开发的操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Python">object_rect = object_surf.get_rect(midbottom=(x, y))<br>screen.blit(object_surf, object_rect)<br></code></pre></td></tr></table></figure><p>关于<code>get_rect()</code>方法的更多参数请自行查阅说明文档，在此仅作简单说明：以该物体碰撞箱的底部的中点作为基准点，将物体绘制到<code>(x, y)</code>位置上。<br>有了这个碰撞箱，我们也能更好地更新物体在画面中的表现了！比如移动一个物体，我们只需要：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Python">object_rect.x -= x<br><span class="hljs-keyword">if</span> object_rect.right &lt;= y:<br>object_rect.left = z<br>screen.blit(object_surf, object_rect)<br></code></pre></td></tr></table></figure><p>上面这段代码写在<code>while True</code>循环中，大致意思为：更新<code>object_rect</code>的在<code>x</code>坐标轴上的位置，如果碰撞箱右边坐标小于某个值，就设置碰撞箱左边的坐标为某个值，然后在画面上绘制出来。<br>接下来终于进入碰撞检测环节了！<br>在Pygame中，如果我们需要检测两个碰撞箱是否相撞，直接使用<code>rect_01.colliderect(rect_02)</code>即可，该方法返回<code>0</code>或<code>1</code>；也可以检测某个点（位置）是否和该物体相撞，用<code>rect.collidepoint((x, y))</code>方法。</p><h2 id="对鼠标进行检测">对鼠标进行检测</h2><p>有两种方法，一种是利用<code>pygame.mouse</code>，一种是利用<code>pygame.event</code>。下面举例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> pygame.event.get():<br><span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span> == pygame.MOUSEMOTION:<br><span class="hljs-built_in">print</span>(event.pos)<br>mouse_pos = pygame.mouse.get_pos()<br></code></pre></td></tr></table></figure><h2 id="检测键盘输入！">检测键盘输入！</h2><p>跟检测鼠标一样，检测键盘输入也有两种方法，<code>pygame.key</code>和<code>pygame.event</code>。<br>如果我们想要使用<code>pygame.key</code>来检测空格是否被摁下，可以这么写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Python">keys = pygame.key.get_pressed()<br>    <span class="hljs-keyword">if</span> keys[pygame.K_SPACE]:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;jump&#x27;</span>)<br></code></pre></td></tr></table></figure><p>也可以结合<code>pygame.event</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span> == pygame.KEYDOWN:<br><span class="hljs-keyword">if</span> event.key == pygame.K_SPACE:<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;jump&#x27;</span>)<br><span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span> == pygame.KEYUP:<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;key up&#x27;</span>)<br></code></pre></td></tr></table></figure><p>当然要记住一点，这些相关操作检测我们应该放在相关的类里面而不是主程序的<code>event loop</code>里，在<code>event loop</code>中我们更注重一些通常操作，比如关闭游戏。</p><h2 id="转换一个GameObject">转换一个GameObject</h2><p><code>pygame</code>的<code>transform</code>提供了许多的转换图像的方法，下面举几个例子：<br><code>object_01 = pygame.transform.scale(object_01, (weight, height))</code>，最基本的方法，按照所传入的长宽比例进行放大，比较难用。<br><code>object_01 = pygame.transform.scale2x(object_01)</code>，十分方便的一个方法，直接将原本的图像放大一倍。<br><code>object_01 = pygame.transform.rotozoom(object_01, angle, scale)</code>，非常全面的方法，可以将图像进行旋转和按比例缩放。</p><h2 id="使用Sprite-class精灵类吧！">使用<code>Sprite class</code>精灵类吧！</h2><blockquote><p><code>Sprite class</code>, a class that contains a surface and a rectangle; and it can be drawn and updated very easily.<br>我们可以为玩家和怪物创建他们的精灵类，用于存放他们的<code>surface</code>和<code>rectangle</code>，这符合<code>OOP</code>的编程思想，也能够使代码更整洁，更具有可读性。<br>有了精灵类后，并不是直接创建他们的实例（对象），而是将他们放进<code>Group</code>中，然后对在<code>Group</code>中对他们进行更新和绘制。在<code>pygame</code>中，有两种<code>Group</code>，一种是通常用的<code>Group</code>，适合存放多个精灵（sprites）实例（对象），一种是<code>GroupSingle</code>，专门为一个<code>sprite</code>服务。<br>那么很明显我们应该把玩家丢入<code>GroupSingle</code>中，而把怪物等丢入<code>Group</code>中。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Player</span>(pygame.sprite.Sprite):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">update</span>(<span class="hljs-params">self</span>):<br>...<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Monster</span>(pygame.sprite.Sprite):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">update</span>(<span class="hljs-params">self</span>):<br>...<br><br>player = pygame.sprite.GroupSingle()<br>player.add(Player())<br><br>monster_group = pygame.sprite.Group()<br></code></pre></td></tr></table></figure><p>精灵类和组都创建完成后，就可以在屏幕上绘制出来了，使用<code>draw()</code>和<code>update()</code>方法就能自动完成绘制和更新。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Python">player.draw(screen)<br>player.update()<br><br>monster_group.draw(screen)<br>monster_group.update()<br></code></pre></td></tr></table></figure><h2 id="过于单调？那就加点音乐">过于单调？那就加点音乐</h2><p>想要为我们的游戏添加背景音乐的话也十分简单，使用<code>pygame.mixer.Sound('path')</code>类即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Python">background_music = pygame.mixer.Sound(<span class="hljs-string">&#x27;audio/background.mp3&#x27;</span>)<br>background_music.set_volume(<span class="hljs-number">0.5</span>)  <span class="hljs-comment"># set volume</span><br>background_music.play(loops=-<span class="hljs-number">1</span>)  <span class="hljs-comment"># loop forever</span><br>background_music.stop()<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>Learning Log</category>
      
      <category>Pygame</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Pygame</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣-1638. 统计只差一个字符的子串数目</title>
    <link href="/2023/03/27/leetcode-1638/"/>
    <url>/2023/03/27/leetcode-1638/</url>
    
    <content type="html"><![CDATA[<h1>题目描述</h1><p><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_1638_1.jpg" alt="1638"></p><h1>思路及实现</h1><h2 id="暴力枚举">暴力枚举</h2><p>最开始想到的，就是先确定子串的长度，然后确定在<code>s</code>和<code>t</code>中的拥有这个长度的子串，把它们放入两个列表中，然后对这两个列表进行遍历并将取出的两个子串进行比较，循环结束后得到结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">countSubstrings</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, t: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        ans = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(s) + <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> i &gt; <span class="hljs-built_in">len</span>(t):<br>                <span class="hljs-keyword">return</span> ans<br>            tmp_index = <span class="hljs-number">0</span><br>            tmp_s = []<br>            tmp_t = []<br>            <span class="hljs-keyword">while</span> tmp_index + i &lt;= <span class="hljs-built_in">len</span>(s):<br>                tmp_s.append(s[tmp_index: tmp_index + i])<br>                tmp_index += <span class="hljs-number">1</span><br>            tmp_index = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">while</span> tmp_index + i &lt;= <span class="hljs-built_in">len</span>(t):<br>                tmp_t.append(t[tmp_index: tmp_index + i])<br>                tmp_index += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">for</span> sub_s <span class="hljs-keyword">in</span> tmp_s:<br>                <span class="hljs-keyword">for</span> sub_t <span class="hljs-keyword">in</span> tmp_t:<br>                    dif = <span class="hljs-number">0</span><br>                    <span class="hljs-keyword">for</span> cnt <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, i):<br>                        <span class="hljs-keyword">if</span> dif &gt; <span class="hljs-number">1</span>:<br>                            <span class="hljs-keyword">break</span><br>                        <span class="hljs-keyword">if</span> sub_s[cnt] != sub_t[cnt]:<br>                            dif += <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">if</span> dif == <span class="hljs-number">1</span>:<br>                        ans += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><p>当然上面代码过于复杂，仔细思考，可以找<code>s</code>和<code>t</code>中不同字符的位置（即<code>s[i] != t[j]</code>），这就满足要找的子串中有一个不同字符的要求了，<br>然后以这两个位置为中心，向左右扩展，找到左右能延伸的最大距离<code>left</code>和<code>right</code>（即找到<code>s[i - left] != t[j - left]</code>和<code>s[i + right] != t[j + right]</code>为止），<br>那么对于当前不同字符位置<code>s[i] != t[j]</code>，最多能够构造<code>(left + 1) * (right + 1)</code>个符合要求的子串对。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">countSubstrings</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, t: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        ans = <span class="hljs-number">0</span><br>        s_len, t_len = <span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">len</span>(t)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(t)):<br>                <span class="hljs-keyword">if</span> s[i] != t[j]:<br>                    left = right = <span class="hljs-number">0</span><br>                    <span class="hljs-keyword">while</span> i &gt; left <span class="hljs-keyword">and</span> j &gt; left <span class="hljs-keyword">and</span> s[i - left - <span class="hljs-number">1</span>] == t[j - left - <span class="hljs-number">1</span>]:<br>                        left += <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">while</span> i + right + <span class="hljs-number">1</span> &lt; s_len <span class="hljs-keyword">and</span> j + right + <span class="hljs-number">1</span> &lt; t_len <span class="hljs-keyword">and</span> s[i + right + <span class="hljs-number">1</span>] == t[j + right + <span class="hljs-number">1</span>]:<br>                        right += <span class="hljs-number">1</span><br>                    ans += (left + <span class="hljs-number">1</span>) * (right + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h2 id="动态规划">动态规划</h2><p>考虑到上面的情况，我们在扩展左右距离时每次都要重复计算<code>left</code>和<code>right</code>，那能否预处理这些数据，需要用的时候直接取出来呢？当然可以。<br>对于左侧的<code>dpl[i][j]</code>，我们不考虑当前字符<code>s[i]</code>是否等于<code>t[j]</code>，因为我们本来就需要找一个不同字符所以对于<code>dpl[i][j]</code>，应看的是<code>s[i - 1] == t[j - 1] ?</code>。<br>写出转移方程：<br><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_1638_2.jpg" alt="转移方程"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">countSubstrings</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, t: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        s_len, t_len = <span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">len</span>(t)<br>        ans = <span class="hljs-number">0</span><br>        dpl = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(t_len + <span class="hljs-number">1</span>)] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(s_len + <span class="hljs-number">1</span>)]<br>        dpr = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(t_len + <span class="hljs-number">1</span>)] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(s_len + <span class="hljs-number">1</span>)]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(s_len):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(t_len):<br>                dpl[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] = (dpl[i][j] + <span class="hljs-number">1</span>) <span class="hljs-keyword">if</span> s[i] == t[j] <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(s_len - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(t_len - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>                dpr[i][j] = (dpr[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>) <span class="hljs-keyword">if</span> s[i] == t[j] <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(s_len):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(t_len):<br>                <span class="hljs-keyword">if</span> s[i] != t[j]:<br>                    ans += (dpl[i][j] + <span class="hljs-number">1</span>) * (dpr[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>Solution</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Leetcode</tag>
      
      <tag>动态规划</tag>
      
      <tag>字符串</tag>
      
      <tag>枚举</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux学习笔记-2</title>
    <link href="/2023/03/24/linux-learning-2/"/>
    <url>/2023/03/24/linux-learning-2/</url>
    
    <content type="html"><![CDATA[<h1>终端会话提示符</h1><p><code>pi@raspberrypi:~$</code><br><code>pi</code>表示当前用户名<br><code>raspberry</code>表示计算机名称<br><code>~</code>表示当前的主目录<br><code>$</code>表示需要输入命令的开始位置</p><h1>切换用户</h1><p><code>sudo su</code>切换为<code>root</code>用户<br><code>su pi</code>切回普通用户</p><h1>常用命令</h1><h2 id="目录切换">目录切换</h2><table><thead><tr><th>命令</th><th>用途</th></tr></thead><tbody><tr><td><code>pwd</code></td><td>显示当前所在目录</td></tr><tr><td><code>cd ~</code></td><td>切换到主目录（<code>/home/pi</code>），~也可省略不写</td></tr><tr><td><code>cd dir</code></td><td>切换到指定目录，<code>dir</code>表示文件路径</td></tr><tr><td><code>cd ..</code></td><td>切换到上一级目录</td></tr></tbody></table><h2 id="文件展示命令">文件展示命令</h2><table><thead><tr><th>命令</th><th>用途</th></tr></thead><tbody><tr><td><code>ls</code></td><td>展示当前目录下所有的文件和文件夹（不包括隐藏文件）</td></tr><tr><td><code>ls -1</code></td><td>展示当前目录下所有的文件和文件夹（包括隐藏文件）</td></tr></tbody></table><h2 id="创建、查看、删除、重命名">创建、查看、删除、重命名</h2><table><thead><tr><th>命令</th><th>用途</th></tr></thead><tbody><tr><td><code>touch file</code></td><td>创建文件file</td></tr><tr><td><code>mkdir dir</code></td><td>创建目录dir</td></tr><tr><td><code>cat file</code></td><td>查看文件file内容</td></tr><tr><td><code>more file</code></td><td>查看文件file内容</td></tr><tr><td><code>head file</code></td><td>查看文件file前10行</td></tr><tr><td><code>cat file</code></td><td>查看文件file后10行</td></tr><tr><td><code>rm file</code></td><td>删除文件file</td></tr><tr><td><code>rm -r dir</code></td><td>删除目录dir</td></tr><tr><td><code>mv file1 file2</code></td><td>将file1更名为file2（注意会覆盖原文件）</td></tr><tr><td><code>mv file dir</code></td><td>将文件file移动到目录dir里</td></tr></tbody></table><h1>nano编辑器</h1><table><thead><tr><th>命令</th><th>用途</th></tr></thead><tbody><tr><td><code>nano file</code></td><td>使用nano编辑文件file（会自动创建）</td></tr></tbody></table><table><thead><tr><th>快捷键</th><th>用途</th></tr></thead><tbody><tr><td><code>ctrl + o</code>/<code>ctrl + s</code></td><td>保存当前文档</td></tr><tr><td><code>esc + u</code></td><td>插销上次操作</td></tr><tr><td><code>ctrl + u</code></td><td>粘贴</td></tr><tr><td><code>ctrl + g</code></td><td>打开帮助文档</td></tr></tbody></table><hr>]]></content>
    
    
    <categories>
      
      <category>Learning Log</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>nano</tag>
      
      <tag>vi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity随笔-1</title>
    <link href="/2023/03/10/unity-essay-1/"/>
    <url>/2023/03/10/unity-essay-1/</url>
    
    <content type="html"><![CDATA[<h1>随便写写</h1><h2 id="使用C-脚本">使用C#脚本</h2><h3 id="创建C-脚本的三种方法：">创建C#脚本的三种方法：</h3><ol><li><strong>资源(Assets)</strong> -&gt; <strong>创建(Create)</strong> -&gt; <strong>C#脚本(C# Script)</strong></li><li>在<strong>项目(Project)<strong>选项卡中，选择</strong>创建(Create)</strong> -&gt; <strong>C#脚本(C# Script)</strong></li><li>在<strong>层级(Hierarchy)<strong>窗口中选择一个GameObject，在</strong>检查器(Inspector)<strong>中，单击</strong>添加组件(Add Component)</strong> -&gt; <strong>New Script</strong></li></ol><h3 id="给GameObject添加脚本">给GameObject添加脚本</h3><p>如果不是方法三创建的脚本，要添加到我们想添加到的GameObject中运行的话，直接从<strong>项目(Project)<strong>选项卡中选中脚本并拖放至GameObject上即可（如：将<code>Move.cs</code>脚本拖放到</strong>层级(Hierarchy)<strong>窗口中的</strong>Main Camera</strong>）。</p><h2 id="将信息和反馈打印到Unity编辑器的Console窗口">将信息和反馈打印到Unity编辑器的Console窗口</h2><p>可以使用<code>Debug.Log()</code>或者<code>Debug.LogFormat()</code>方法。下面是例子：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C#">Debug.Log(<span class="hljs-string">&quot;Text goes here.&quot;</span>);<br>Debug.Log(yourVariable);<br>Debug.Format(<span class="hljs-string">&quot;Text goes here, add &#123;0&#125; and &#123;1&#125; as variable placeholders&quot;</span>, variable1, bariable2);<br></code></pre></td></tr></table></figure><p>当然，<code>Debug.Log()</code>方法也支持字符串插值：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">Debug.Log(<span class="hljs-string">$&quot;A string can have variables like <span class="hljs-subst">&#123;firstName&#125;</span> inserted directly!&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="Start-和Update-方法">Start()和Update()方法</h2><h3 id="Start">Start()</h3><p>Unity在启用脚本的第一帧时便调用此方法。**只会执行一次。**主要用于设置变量或执行首次运行Update()之前需要发生的逻辑。也可用于在Console面板上显示一次性信息。</p><h3 id="Update">Update()</h3><p>每帧显示后，<code>Update()</code>方法便由Unity调用（即每帧调用一次<code>Update()</code>）。非常适合用来<strong>监测鼠标和键盘输入</strong>或<strong>运行游戏逻辑</strong>。</p><h2 id="C-中的数组、字典和列表">C#中的数组、字典和列表</h2><h3 id="数组">数组</h3><p><strong>数组的特点</strong>：</p><ul><li>数组可以存储任何类型的值，但所有元素都必须是同一类型。</li><li>数组的长度或可容纳元素的数量在创建数组时就已设置，之后无法修改。</li><li>如果在创建时没有分配初始值，则每个元素将被赋予一个默认值。存储数字类型的数组默认为0，而任何其他类型都默认设置为null。<br><strong>如何创建数组</strong><br>通用模板：<code>elementType[] name = new elementType[numberOfElements];</code></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">// example</span><br><span class="hljs-built_in">int</span>[] newArray = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">3</span>];<br><br><span class="hljs-comment">// Longhand initializer</span><br><span class="hljs-built_in">int</span>[] newArray = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[] &#123;<span class="hljs-number">713</span>, <span class="hljs-number">549</span>, <span class="hljs-number">984</span>&#125;;<br><br><span class="hljs-comment">// Shortcut initializer</span><br><span class="hljs-built_in">int</span>[] newArray = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[] &#123;<span class="hljs-number">713</span>, <span class="hljs-number">549</span>, <span class="hljs-number">984</span>&#125;;<br></code></pre></td></tr></table></figure><h3 id="列表">列表</h3><p><strong>如何创建列表</strong><br>通用模板：<code>List&lt;elementType&gt; name = new List&lt;elementType&gt;() &#123;value1, value2&#125;;</code><br><strong>列表中的操作</strong><br>查找元素：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">name[index];<br></code></pre></td></tr></table></figure><p>统计元素：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">name.Count();<br></code></pre></td></tr></table></figure><p>增加元素：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">name.Add(newElement);<br></code></pre></td></tr></table></figure><p>插入元素：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">name.Insert(index, newElement);<br></code></pre></td></tr></table></figure><p>删除元素：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C#">name.RemoveAt(index);<br>name.Remove(<span class="hljs-keyword">value</span>);<br></code></pre></td></tr></table></figure><h3 id="字典">字典</h3><p><strong>如何创建字典</strong><br>通用模板：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C#">Dictionary&lt;keyType, valueType&gt; name = <span class="hljs-keyword">new</span> Dictionary&lt;keyType, valueType&gt;()<br>&#123;<br>&#123;key1, value1&#125;,<br>&#123;key2, value2&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>操作字典</strong><br>统计键值对数量：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">name.Count();<br></code></pre></td></tr></table></figure><p>添加键值对：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C#">name.Add(newKey, newValue);<br>name[newKey] = newValue;<br></code></pre></td></tr></table></figure><p>修改键值对：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">name[key] = newValue;<br></code></pre></td></tr></table></figure><p>删除键值对：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">name.Remove(key);<br></code></pre></td></tr></table></figure><p>字典中是否包含指定键：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">name.ContainKey(key);<br></code></pre></td></tr></table></figure><p>在循环中捕获键值对：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">foreach</span>(KeyValuePair&lt;keyType, valueType&gt; kvp <span class="hljs-keyword">in</span> name)<br>&#123;<br>kvp.Key;<br>kvp.Value;<br>code block;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="C-中的类、结构体与OOP">C#中的类、结构体与OOP</h2><p>类的关键是它们是<strong>引用类型</strong>，也就是说，当类被赋值或传递给另一个变量时，系统引用的是原始对象，而不是创建一个新的脚本。<br>而结构体则是<strong>值类型</strong>，其特点有：变量不能在结构体声明的内部进行初始化，除非用static或是const修饰；不允许使用没有参数的构造函数。<br>结构体作为单独对象很容易被复制和修改（可直接<code>structObject1 = structObject2</code>），而类保留了对其原始对象的引用。</p><h3 id="C-中的继承">C#中的继承</h3><p>如何创建继承？</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#">accessModifier <span class="hljs-keyword">class</span> <span class="hljs-title">SubClass</span>: <span class="hljs-title">SuperClass</span><br>&#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>任何用<code>public</code>、<code>protected</code>或<code>internal</code>访问修饰符标记的基类成员都会自动成为派生类的一部分，但构造函数除外。类的构造函数总是属于包含它们的类，但仍可以从派生类中使用父类的构造函数：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ChildClass</span>: <span class="hljs-title">ParentClass</span><br>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ChildClass</span>(): <span class="hljs-title">base</span>()</span><br>&#123;<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="C-中的多态">C#中的多态</h3><p>一个方法可以通过调用类产生不同的行为，此即为<strong>多态</strong>。<br>派生类对象的处理方式与父类对象相同。例如，一个由<code>ParentClass</code>类对象构成的数组也可以存储<code>ChildClass</code>对象，因为它们派生自<code>ParentClass</code>。<br>父类可以将方法标记为虚拟方法（<code>virtual</code>，在访问修饰符和返回类型之间加入，如：<code>public virtual void</code>），这意味着派生类可以使用<code>override</code>（也是在访问修饰符和返回类型之间加入）关键字修改其命令（重载方法）。</p><h2 id="访问组件">访问组件</h2><p>组件是什么呢？比如，对于一个<code>GameObject</code>，这里以<code>MainCamera</code>为例，单击它，在右边检查器（Inspector）中的就是它的组件了：Transform、Camera、Audio Listener和我们自己加上去的Learning Curve。<br>那要如何在自己编写的Learning Curve脚本中获取到Transform组件呢？可以用<code>GameObject</code>的类方法：<code>GetComponent()</code>或<code>Find()</code>。</p><ol><li>访问当前的Transform组件 -&gt; 使用<code>GetComponent()</code></li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C#">GameObject.GetComponent&lt;ComponentType&gt;()<br>camTransform = <span class="hljs-keyword">this</span>.GetComponent&lt;Transform&gt;();<br></code></pre></td></tr></table></figure><p>这里能用<code>this</code>关键字，是因为两者都附加到相同的<code>GameObject</code>组件上。<br>2. 访问另外一个<code>GameObject</code>上的组件 -&gt; 使用<code>Find()</code> + <code>GetComponent()</code></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C#">directionLight = GameObject.Find(<span class="hljs-string">&quot;Directional light&quot;</span>);<br>lightTransform = directionLight.GetComponent&lt;Transform&gt;();<br></code></pre></td></tr></table></figure><h2 id="游戏设计入门">游戏设计入门</h2><p>对于我们想要构建的内容，我们需要规划好以下几点：</p><ul><li>概念：对游戏的全局理念和设计，包括游戏类型和玩法风格。</li><li>核心机制：角色可以在游戏中使用的可玩功能或互动方式。常见的游戏机制包括跳跃、射击、解谜、驾驶等。</li><li>控制方案：玩家用来控制游戏角色、环境交互和其他可执行动作的键位映射。</li><li>故事：推动游戏发展的背景叙事，用于在玩家与游戏世界之间建立共情与关联。</li><li>艺术风格：游戏的总体观感，并体现在从角色、界面美术到关卡和环境设计的各方面。</li><li>胜负条件：决定游戏输赢的规则，通常由一些可能会遭遇失败的目标构成。</li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>Essay</category>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双指针专题</title>
    <link href="/2023/03/05/algorithm-two-pointers/"/>
    <url>/2023/03/05/algorithm-two-pointers/</url>
    
    <content type="html"><![CDATA[<h1>简单介绍下双指针</h1><p>双指针正如其名，如果一个指针不够用，那就用两个指针来解决问题！当然指针只是个叫法，并不是一定要用指针，普通的变量作索引，能够辅助解决问题的都可以。<br>双指针和滑动窗口其实也能扯上关系，毕竟滑窗要用到<code>left</code>和<code>right</code>来确定窗口的左右边界嘛，那么这里的<code>left</code>和<code>right</code>就能看成是双指针啦~</p><h1>双指针相关题目</h1><h2 id="977-有序数组的平方">977. 有序数组的平方</h2><p>题目链接：<a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977</a><br>自己最开始想到的思路就是，由于<code>nums</code>已经按照<strong>非递减顺序</strong>顺序排序了，那么在平方后，我们可以以负数和非负数为分界线，分出两个数组，左边的负数数组从右往左看是递增的，右边的非负数数组从左往右看是递增的，也就是说我们的两个指针可以设置在分界点这里，一个往左走一个往右走，每次比较两数大小，小的就放进去结果<code>ans</code>中，然后更新指针，直至把数全部塞进<code>ans</code>中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sortedSquares</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        positive = negative = <span class="hljs-number">0</span><br>        nums_pow = [nums[<span class="hljs-number">0</span>] * nums[<span class="hljs-number">0</span>]]<br>        ans = []<br>        <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)):  <span class="hljs-comment"># 求出平方数组</span><br>            <span class="hljs-keyword">if</span> nums[n - <span class="hljs-number">1</span>] &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nums[n] &gt;= <span class="hljs-number">0</span>:  <span class="hljs-comment"># 找到左右两个递增数组的开头</span><br>                negative = n - <span class="hljs-number">1</span><br>                positive = n<br>            nums_pow.append(nums[n] * nums[n])<br>        <span class="hljs-keyword">if</span> positive == negative:  <span class="hljs-comment"># 两者都是0，说明nums数组只含有一个单调数组</span><br>            <span class="hljs-keyword">if</span> nums[<span class="hljs-number">0</span>] &gt;= <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">return</span> nums_pow<br>            <span class="hljs-keyword">else</span>:<br>                nums_pow.reverse()<br>                <span class="hljs-keyword">return</span> nums_pow<br>        <span class="hljs-keyword">while</span> positive &lt; <span class="hljs-built_in">len</span>(nums) <span class="hljs-keyword">and</span> negative &gt;= <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">if</span> nums_pow[positive] &gt; nums_pow[negative]:<br>                ans.append(nums_pow[negative])<br>                negative -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># nums_pow[positive] &lt;= nums_pow[negative]</span><br>                ans.append(nums_pow[positive])<br>                positive += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> negative &gt;= <span class="hljs-number">0</span>:<br>            ans.append(nums_pow[negative])<br>            negative -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> positive &lt; <span class="hljs-built_in">len</span>(nums):<br>            ans.append(nums_pow[positive])<br>            positive += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><p>上面是初版代码，看完别人的代码后再看自己的，就发现肉眼可见的看上去就很复杂，“复杂”主要体现在对特殊情况进行了处理，循环完后还要多写两个判断来处理剩下的数，以及为什么要先求一个挺没有意义的平方数组(逃)。<br>当然，更优的思路是从将双指针设置在<code>nums</code>数组的左右边界，即<code>0</code>和<code>nums.Length - 1</code>，将<code>ans</code>初始化为跟<code>nums</code>长度一致，每次比较数，把大数放到<code>ans</code>末尾即可（即逆序放入数组中）。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span>[] <span class="hljs-title">SortedSquares</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] nums</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> n = nums.Length;<br>        <span class="hljs-built_in">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[n];<br>        <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>, j = n - <span class="hljs-number">1</span>, pos = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i &lt;= j)<br>&#123;<br>            <span class="hljs-keyword">if</span> (nums[i] * nums[i] &gt; nums[j] * nums[j])<br>&#123;<br>                ans[pos] = nums[i] * nums[i];<br>                i += <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>&#123;<br>                ans[pos] = nums[j] * nums[j];<br>                j -= <span class="hljs-number">1</span>;<br>            &#125;<br>            pos -= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="283-移动零">283. 移动零</h2><p>题目链接：<a href="https://leetcode.cn/problems/move-zeroes/">283</a><br>看完题目，简单总结一下就是：要把所有<strong>非0</strong>数放在数组的左边（也就是所有<strong>0</strong>的左边），所有<strong>0</strong>放在数组的右边（也就是所有<strong>非0</strong>数的右边），且要保持<strong>非0</strong>元素的相对顺序。<br>利用双指针，从头扫到尾，保证<code>left</code>的左边是排序好的<strong>非0</strong>元素，<code>right</code>则用于寻找剩下的<strong>非0</strong>元素，并将它们放到左边。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">moveZeroes</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Do not return anything, modify nums in-place instead.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        n = <span class="hljs-built_in">len</span>(nums)<br>        left = right = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> right &lt; n:<br>            <span class="hljs-keyword">if</span> nums[right] != <span class="hljs-number">0</span>:<br>                nums[left], nums[right] = nums[right], nums[left]<br>                left += <span class="hljs-number">1</span><br>            right += <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="167-两数之和-II-输入有序数组">167. 两数之和 II - 输入有序数组</h2><p>题目链接：<a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">167</a><br>这题的双指针思路算是很容易就能想到的了，而且题目也说了数组已按<strong>非递减顺序排列</strong>且一定存在解，那么就直接设置<code>left</code>和<code>right</code>为<code>numbers</code>数组的左右边界，如果左右相加大了，就让右指针向左移动，反之如果小了，就让左指针向右移动。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params">self, numbers: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        n = <span class="hljs-built_in">len</span>(numbers)<br>        left = <span class="hljs-number">0</span><br>        right = n - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> left &lt; right:<br>            <span class="hljs-keyword">if</span> numbers[left] + numbers[right] == target:<br>                <span class="hljs-keyword">return</span> [left + <span class="hljs-number">1</span>, right + <span class="hljs-number">1</span>]<br>            <span class="hljs-keyword">elif</span> numbers[left] + numbers[right] &lt; target:<br>                left += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># numbers[left] + numbers[right] &gt; target</span><br>                right -= <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="557-反转字符串中的单词-III">557. 反转字符串中的单词 III</h2><p>题目链接：<a href="https://leetcode.cn/problems/reverse-words-in-a-string-iii/description/">557</a><br>其实这题我并没有用双指针来写，因为Python的方法真是太好用了(逃)。<br>不过既然都是双指针专题了，那就大概讲讲思路，不敲代码了(因为真的很简单)。首先利用<code>for</code>循环遍历字符串，<code>for</code>循环中的索引同时也担当指针，每次循环记录当前索引位置，并将索引定位到当前单词后面空格的位置，双指针的位置就确定完毕了。</p><h2 id="876-链表的中间结点">876. 链表的中间结点</h2><p>题目链接：<a href="https://leetcode.cn/problems/middle-of-the-linked-list/description/">876</a><br>这道题就触及到我的知识盲区了，后面看了看，搜嘎，原来还有个**“快慢指针”**的分支啊~<br>如同它的名字一般，我们设置两个指针，一个走得快，走在前面，一个走得慢，走在后面。对于这道题，我们需要找到在链表中间的结点，那么我们是否可以让快指针走完链表的时候，慢指针刚好到中间结点呢？<br>那肯定可以啦，中间结点不是除以2嘛，那就让快指针的速度是慢指针的两倍，也就是慢指针每次走一步，快指针每次走两步即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">middleNode</span>(<span class="hljs-params">self, head: ListNode</span>) -&gt; ListNode:<br>        slow = fast = head<br>        <span class="hljs-keyword">while</span> fast <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> fast.<span class="hljs-built_in">next</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            slow = slow.<span class="hljs-built_in">next</span><br>            fast = fast.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> slow<br></code></pre></td></tr></table></figure><h2 id="19-删除链表的倒数第-N-个结点">19. 删除链表的倒数第 N 个结点</h2><p>题目链接：<a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/">19</a><br>那么这题就和上面那道链表题一样了，其思想都是快慢指针，我们所需要思考的就是快指针与慢指针的相对距离。<br>题目说要删除的是倒数第<code>n</code>个结点，那么我们就想要快指针遍历完的时候，慢指针要在那个应该删除的结点的前面那个结点上面（为什么呢？这就涉及到链表删除结点这个操作的知识了，可以看链表相关知识）。<br>那么我们就先让快指针先走<code>n</code>个结点，然后快慢指针同时走，就能够保持两个指针的距离相对不变了。<br>诶，停一下，细心的朋友已经发现了这么走的话最后慢指针应该是在应该删除的结点上面，而不是它前面那个结点，那怎么办呢？那就设置一个哨兵结点<code>ListNode(0, head)</code>，这也是链表常用技巧。<br>到这里思路就完整了，接下来写出代码即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">removeNthFromEnd</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode], n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        fast = head<br>        slow = ListNode(<span class="hljs-number">0</span>, head)<br>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            fast = fast.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">while</span> fast <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            fast = fast.<span class="hljs-built_in">next</span><br>            slow = slow.<span class="hljs-built_in">next</span><br>        slow.<span class="hljs-built_in">next</span> = slow.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> head<br></code></pre></td></tr></table></figure><h1>题外话</h1><p>我趣，一天写完是真累啊，就应该写一题马上更新，堆在一起简直要命(倒)<br>以后也会保持更新的吧(心虚</p><hr>]]></content>
    
    
    <categories>
      
      <category>Solution</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
      <tag>Python</tag>
      
      <tag>Leetcode</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分搜索专题</title>
    <link href="/2023/03/04/algorithm-binary-search/"/>
    <url>/2023/03/04/algorithm-binary-search/</url>
    
    <content type="html"><![CDATA[<h1>什么事二分搜索？</h1><p>这里有一道十分标准的例题：<a href="https://leetcode.cn/problems/binary-search/description/">704</a><br>对于一个有序（升序）的整型数组，如果我们要从中找出目标值，最直接的方法是从头开始遍历，但效率肯定十分低下，而且没有好好利用到所给的条件（数组已排好序）。<br>这时候就可以用二分搜索来找到目标值，试想一下猜数游戏，只要我们每次都取一个中间值，是不是很快就能够定位目标值呢？</p><blockquote><p>如：目标是78，我们先猜1，第二次猜100，第三次猜50，第四次猜75，以此类推<br>这就是二分搜索最基本的思想。<br>然后看到上面给出的例题，根据描述，可以很快写出下面的代码：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">search</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        left = <span class="hljs-number">0</span><br>        right = <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> right &gt;= left:<br>            mid = (right + left) // <span class="hljs-number">2</span><br>            <span class="hljs-keyword">if</span> nums[mid] == target:<br>                <span class="hljs-keyword">return</span> mid<br>            <span class="hljs-keyword">elif</span> nums[mid] &lt; target:<br>                left = mid + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># nums[mid] &gt; target</span><br>                right = mid - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Search</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] nums, <span class="hljs-built_in">int</span> target</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> right = nums.Length - <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">int</span> mid;<br>        <span class="hljs-keyword">while</span> (left &lt;= right)<br>        &#123;<br>            mid = (left + right) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] == target)<br>            &#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target)<br>            &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>  <span class="hljs-comment">// nums[mid] &lt; target</span><br>            &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么这代码之中其实也有要点，那就是<code>mid = (right + left) / 2</code>、<code>while (left &lt;= right)</code>、<code>left = mid + 1</code>和<code>right = mid - 1</code>，之后在对比其他题目的时候会详细说明。</p><div class="note note-warning">            <p>在做二分搜索的时候，如果弄不明白该怎么定位目标值的话，一定一定记得画图辅助，不要用脑子硬想，容易出错效率还不高。</p>          </div><h1>其他的二分搜索题目</h1><h2 id="35-搜索插入位置">35. 搜索插入位置</h2><p>题目链接：<a href="https://leetcode.cn/problems/search-insert-position/description/">35</a><br>先放一个最初版本的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">searchInsert</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        left = <span class="hljs-number">0</span><br>        right = <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>;<br>        mid = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> right &gt;= left:<br>            mid = (right + left) // <span class="hljs-number">2</span><br>            <span class="hljs-keyword">if</span> nums[mid] == target:<br>                <span class="hljs-keyword">return</span> mid<br>            <span class="hljs-keyword">elif</span> nums[mid] &lt; target:<br>                left = mid + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># nums[mid] &gt; target</span><br>                right = mid - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> right == -<span class="hljs-number">1</span>:  <span class="hljs-comment"># 特殊情况</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">return</span> mid + <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> nums[mid] &lt; target <span class="hljs-keyword">else</span> mid<br></code></pre></td></tr></table></figure><p>这就很好的体现了画图的重要性。但凡画一下图都不会写出最后几句那么复杂的代码。<br>将最后三行代码删除，换成<code>return left</code>即可。这也说明了要多关注下<code>left</code>、<code>right</code>和<code>mid</code>三个变量，这样才利于我们找目标值。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">SearchInsert</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] nums, <span class="hljs-built_in">int</span> target</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> left = <span class="hljs-number">0</span>, right = nums.Length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right)<br>        &#123;<br>            <span class="hljs-built_in">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] == target)<br>            &#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target)<br>            &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>  <span class="hljs-comment">// nums[mid] &gt; target</span><br>            &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="278-第一个错误的版本">278. 第一个错误的版本</h2><p>题目链接：<a href="https://leetcode.cn/problems/first-bad-version/description/">278</a><br>这题也是建立在二分搜索基础之上的，但是我们需要找到第一个错误的版本，可以这样理解：<strong>找到第一个跟在False后面的True</strong>。<br>首先介绍最简单的思想，对于每次的<code>mid</code>，我们可以判断此版本是<code>False</code>还是<code>True</code>，如果是<code>False</code>，就找它后面的一个版本并判断，如果是<code>True</code>，就找它前面的一个版本判断。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">firstBadVersion</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        left = <span class="hljs-number">1</span><br>        right = n<br>        mid = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> left &lt;= right:<br>            mid = (left + right) // <span class="hljs-number">2</span><br>            <span class="hljs-keyword">if</span> isBadVersion(mid):<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> isBadVersion(mid - <span class="hljs-number">1</span>):<br>                    <span class="hljs-keyword">return</span> mid<br>                <span class="hljs-keyword">else</span>:<br>                    right = mid - <span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> <span class="hljs-keyword">not</span> isBadVersion(mid):<br>                <span class="hljs-keyword">if</span> isBadVersion(mid + <span class="hljs-number">1</span>):<br>                    <span class="hljs-keyword">return</span> mid + <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    left = mid + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>不过很明显的是代码存在一定漏洞而且调用API的次数多了。比如示例2，如果只存在一个版本的话，那个版本就是错误的，那其实不能调用<code>isBadVersion(mid - 1)</code>，这应该是没有意义的，但是确实有漏洞让我过了（目移）。<br>那么如何优化呢？仔细想想，在判断完<code>mid</code>是<code>True</code>还是<code>False</code>以外，我们就能够知道：</p><ol><li>如果<code>mid == False</code>，那么<code>&lt;= mid</code>的版本都应该是<code>False</code></li><li>如果<code>mid == True</code>，那么<code>&gt;= mid</code>的版本都应该是<code>True</code><br>所以，我们把循环条件改成：<code>while left &lt; right</code>，缩小的区间改为<code>left = mid + 1</code>，<code>right = mid</code>，最后<code>left == right</code>的时候，就是我们要找的第一个错误的版本。<br>上面的改动保证<code>right</code>不会指到<code>False</code>的位置，且<code>left</code>能够指到<code>True</code>和<code>False</code>的位置，如果还是不是很清楚的话，可以画图辅助。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">firstBadVersion</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        left = <span class="hljs-number">1</span><br>        right = n<br>        mid = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> left &lt; right:<br>            mid = (left + right) // <span class="hljs-number">2</span><br>            <span class="hljs-keyword">if</span> isBadVersion(mid):<br>                right = mid<br>            <span class="hljs-keyword">else</span>:<br>                left = mid + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> left<br></code></pre></td></tr></table></figure><p>其实这代码其中还有一个问题，但是由于上面使用的是<code>Python</code>语言，某些特性导致代码能过。看到题目给的提示<code>1 &lt;= bad &lt;= n &lt;= 2^31 - 1</code>，所以如果是需要对变量进行类型定义的语言就会出错，因为在这行代码<code>mid = (left + right) // 2</code>中存在大数导致的溢出。<br>改成这样就好了：<code>mid = left + (left + right) \ 2</code>。不知道怎么来的就画数轴（画图真的很重要好吗）。<br>下面是C#代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> : <span class="hljs-title">VersionControl</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">FirstBadVersion</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> n</span>)</span><br>    &#123;<br>        <span class="hljs-built_in">int</span> left = <span class="hljs-number">1</span>, right = n, mid = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right)<br>        &#123;<br>            mid = left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (!IsBadVersion(mid))<br>            &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-comment">// IsBadVersion(mid)</span><br>            &#123;<br>                right = mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="167-两数之和-II-输入有序数组">167. 两数之和 II - 输入有序数组</h2><p>题目链接：<a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/description/">167</a><br>这题能用双指针，也能用二分搜索写，由于本文章是二分搜索专题，所以这里只写二分搜索解法。<br>抓住题目所说该数组已按<strong>非递减顺序排列</strong>，那么很快可以想到二分搜索，然后看到我们需要找到两个数，这两个数之和等于<code>target</code>，且数组中一定存在解，那我们就能够在二分搜索循环里面写判断找出答案。<br>那么对于第一个数，我们可以先固定，也就是外层循环遍历数组的每一个数，在除去固定的第一个数后的在其后面的剩余数组使用二分搜索来找到第二个数，找到后返回即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params">self, numbers: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        n = <span class="hljs-built_in">len</span>(numbers)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            left = i + <span class="hljs-number">1</span><br>            right = n - <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> left &lt;= right:<br>                mid = (left + right) // <span class="hljs-number">2</span><br>                <span class="hljs-keyword">if</span> numbers[i] + numbers[mid] == target:<br>                    <span class="hljs-keyword">return</span> [i + <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>]<br>                <span class="hljs-keyword">elif</span> numbers[i] + numbers[mid] &lt; target:<br>                    left = mid + <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># numbers[i] + numbers[mid] &gt; target</span><br>                    right = mid - <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h1>其他想说的话</h1><p>之后如果有<strong>有价值的</strong>二分搜索的题目应该也会放在这里的。</p><hr>]]></content>
    
    
    <categories>
      
      <category>Solution</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
      <tag>Python</tag>
      
      <tag>Leetcode</tag>
      
      <tag>二分搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-1247</title>
    <link href="/2023/02/25/leetcode-1247/"/>
    <url>/2023/02/25/leetcode-1247/</url>
    
    <content type="html"><![CDATA[<h1>题目描述</h1><p><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_1247_1.jpg" alt="1247"></p><h1>思路及实现</h1><p>看完题目及示例，能够很快想到要使两个字符串相等，那么两个字符串中的<code>'x'</code>和<code>'y'</code>的数量应该相等，所以可以先统计一下两者的数量，如果不同可以直接返回<code>-1</code>。<br>接下来从示例中寻找其他的情况，这边有两种思路：</p><ol><li>从示例4着手，这是我一开始的思路。用暴力方法来解决示例4，会发现需要6次才能够解决；那么4次怎么来的呢？那肯定是有选择性的交换，即优先选择更优方案；仔细观察交换，就能够发现其实有两种交换方案：第一种，<code>s1 = 'x...x'</code>和<code>'s2 = 'y...y'</code>交换，这种情况下仅需一次交换；第二种，<code>s1 = 'x...y'</code>和<code>s2 = 'y...x'</code>交换，这种情况下需两次交换。那我们就更多地进行第一种交换就行了。</li><li>总结数学规律，统计<code>s1[i] = 'x', s2[i] = 'y'</code>和<code>s1[i] = 'y', s2[i] = 'x'</code>的数量，计算结果。<br>这其中的思路2涉及到的详细数学规律，可以跳转至<a href="https://leetcode.cn/problems/minimum-swaps-to-make-strings-equal/solutions/2130292/jiao-huan-zi-fu-shi-de-zi-fu-chuan-xiang-6b1u/">官解</a>观看。<br>下面是思路1的代码：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minimumSwap</span>(<span class="hljs-params">self, s1: <span class="hljs-built_in">str</span>, s2: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">if</span> (s1.count(<span class="hljs-string">&#x27;x&#x27;</span>) + s2.count(<span class="hljs-string">&#x27;x&#x27;</span>)) % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>:  <span class="hljs-comment"># 两字符串能够相同的前提是x或y的个数为偶数个</span><br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>        ans = <span class="hljs-number">0</span><br>        n = <span class="hljs-built_in">len</span>(s1)<br>        <span class="hljs-keyword">for</span> index_1 <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">if</span> s1[index_1] != s2[index_1]:  <span class="hljs-comment"># 两个字符串中当前字符不相同</span><br>                flag = <span class="hljs-literal">False</span><br>                <span class="hljs-keyword">for</span> index_tmp <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(index_1 + <span class="hljs-number">1</span>, n):  <span class="hljs-comment"># 贪心往后找和当前字符一样的情况</span><br>                    <span class="hljs-keyword">if</span> s1[index_1] == s1[index_tmp] <span class="hljs-keyword">and</span> s2[index_1] == s2[index_tmp]:  <span class="hljs-comment"># 找到了的话交换次数+1，修改字符串</span><br>                        ans += <span class="hljs-number">1</span><br>                        flag = <span class="hljs-literal">True</span><br>                        s1 = s1[:index_tmp] + s2[index_1] + s1[index_tmp + <span class="hljs-number">1</span>:n]  <span class="hljs-comment"># s1[index_tmp] = s2[index_1]</span><br>                        s2 = s2[:index_1] + s1[index_1] + s2[index_1 + <span class="hljs-number">1</span>:n]  <span class="hljs-comment"># s2[index_1] = ch_1</span><br>                        <span class="hljs-keyword">break</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> flag:  <span class="hljs-comment"># 没找到，就是需要交换两次的情况：&#x27;x...y&#x27;, &#x27;y...x&#x27;</span><br>                    <span class="hljs-keyword">for</span> index_tmp <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(index_1 + <span class="hljs-number">1</span>, n):<br>                        <span class="hljs-keyword">if</span> s1[index_1] == s2[index_tmp] <span class="hljs-keyword">and</span> s2[index_1] == s1[index_tmp]:  <span class="hljs-comment"># 交换次数+2，修改字符串</span><br>                            ans += <span class="hljs-number">2</span><br>                            <span class="hljs-comment"># s2[index_1] = ch_1, s2[index_tmp] = s1[index_tmp]</span><br>                            s2 = s2[:index_1] + s1[index_1] + s2[index_1 + <span class="hljs-number">1</span>:index_tmp] + s1[index_tmp] + s2[index_tmp + <span class="hljs-number">1</span>:n]<br>                            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><p>写得非常复杂，但是不涉及复杂数学规律，简单易懂（自己认为的），可以在此之上总结出数学规律。</p><hr>]]></content>
    
    
    <categories>
      
      <category>Solution</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
      <tag>Python</tag>
      
      <tag>Leetcode</tag>
      
      <tag>字符串</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣每日一题五天大礼包之：1739、1764、1785、1945和2027</title>
    <link href="/2022/12/27/leetcode-1739-1764-1785-1945-2027/"/>
    <url>/2022/12/27/leetcode-1739-1764-1785-1945-2027/</url>
    
    <content type="html"><![CDATA[<h1>题目描述</h1><p><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_1739_1.jpg" alt="1739_1"><br><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_1739_2.jpg" alt="1739_2"><br><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_1764_1.jpg" alt="1764"><br><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_1785_1.jpg" alt="1785"><br><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_1945_1.jpg" alt="1945"><br><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_2027_1.jpg" alt="2027"></p><h1>思路及实现</h1><h2 id="1739-放置盒子">1739. 放置盒子</h2><p>读完题目之后，就很自然而然地想到找规律了，毕竟这种看上去像数学题的很大程度上都能找规律做。<br>但是貌似是有点阳性后遗症，光在脱离数学找规律了，就想到先找到最接近<code>n</code>的完全叠满的情况，然后再一个一个方块加，但是就是不知道怎么写出来。低效率地想了40分钟以后就去看题解了。。。<br>然后看的是灵神的题解，因为灵神的题解一目了然，好懂。起码确定了我的思路是没什么问题的，先找到一个最逼近<code>n</code>的情况<code>i</code>，然后找到一个最小的<code>j</code>使得此时能够最大叠放的盒子不小于<code>n</code>个。<br>补充一下什么是完整堆叠/完全叠满：就是<code>1、4、10、20...</code>这些情况。<br>在这里有几个公式：<br>当接触地面的盒子为：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>3</mn><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><mi>i</mi><mo>=</mo><mfrac><mrow><mi>i</mi><mo stretchy="false">(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">1 + 2 + 3 + ... + i = \frac {i(i+1)} 2 </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">...</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.113em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>此时完全叠满的盒子数就为：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>1</mn><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>3</mn><mo stretchy="false">)</mo><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>3</mn><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi>i</mi><mo stretchy="false">(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>i</mi><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><mn>6</mn></mfrac></mrow><annotation encoding="application/x-tex">1 + (1+2) + (1+2+3) + ... + (1+2+3+...+i) = \frac {i(i+1)(i+2)} 6 </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">...</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">...</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.113em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">6</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>所以需要找到一个完全叠满盒子后盒子数量最接近且小于<code>n</code>的时候的接触地面的盒子数<code>ans</code>，然后再找到一个最小的能够满足此时最大叠放盒子数量不小于<code>n</code>的情况。<br>在一个完整盒子堆上继续往地面加<code>j</code>个盒子，盒子上限增加：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>3</mn><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><mi>j</mi><mo>=</mo><mfrac><mrow><mi>j</mi><mo stretchy="false">(</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">1 + 2 + 3 + ... + j = \frac {j(j+1)} 2 </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">...</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.113em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>那么根据上面的公式就能够写出程序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minimumBoxes</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        ans = max_n = <span class="hljs-number">0</span><br>        i = j = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> max_n + ans + i &lt;= n:<br>            ans += i<br>            max_n += ans<br>            i += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> max_n &lt; n:<br>            ans += <span class="hljs-number">1</span><br>            max_n += j<br>            j += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><p>在上边，<code>ans</code>就是最接近且小于<code>n</code>的时候的接触地面的盒子数，<code>max_n</code>是当前能够堆放的最大盒子数，<code>i</code>是下次添加到地面上的盒子数，<code>j</code>则是在完整盒子堆上每往地面添加一个盒子后盒子上限会增加的数量。<br>而上面的<code>max_n + ans + i &lt;= n</code>则是判断下次的完整堆叠的盒子数量会不会超过<code>n</code>，如果会那么当前情况就是最接近且小于<code>n</code>的情况。<br>既然有了公式，那么肯定是能够通过公式直接计算出答案的，这里就不细述了，跳转：<a href="https://leetcode.cn/problems/building-boxes/solutions/2031813/mei-xiang-ming-bai-yi-ge-dong-hua-miao-d-8vbe/">灵茶山艾府</a></p><h2 id="1764-通过连接另一个数组的子数组得到一个数组">1764. 通过连接另一个数组的子数组得到一个数组</h2><p>简单地概括一下题目，就是我们要在数组<code>nums</code>里按顺序找到<code>groups</code>里边给出的子数组，并且<code>nums</code>里用过的元素就不能够重复使用了，如果<code>nums</code>里边能找全，那就返回<code>true</code>，否则返回<code>false</code>。<br>那对于python而言其实很好做啊，直接取<code>groups</code>里边的子数组<code>groups[i]</code>，然后在<code>nums</code>里边取切片<code>nums[j: j + len(groups[i])]</code>，进行比较，根据结果再更新两个下标<code>i</code>和<code>j</code>即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">canChoose</span>(<span class="hljs-params">self, groups: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        i = j = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(groups) <span class="hljs-keyword">and</span> j &lt; <span class="hljs-built_in">len</span>(nums):<br>            <span class="hljs-keyword">if</span> groups[i] == nums[j: j + <span class="hljs-built_in">len</span>(groups[i])]:<br>                j += <span class="hljs-built_in">len</span>(groups[i])<br>                i += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                j += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> i == <span class="hljs-built_in">len</span>(groups)<br></code></pre></td></tr></table></figure><h2 id="1785-构成特定和需要添加的最少元素">1785.构成特定和需要添加的最少元素</h2><p>表面上看上去是一道中等题，实际上是简单题(<br>看完题目很容易就能想到要向数组添加最小元素，那可以用到贪心思想，每次塞一个最大最满足的数即可，进一步分析，分三种情况讨论：</p><ol><li><code>nums</code>中的总和刚好等于<code>goal</code>，不需要向里面添加元素</li><li><code>nums</code>中的总和不等于<code>goal</code>，计算差距<code>dif = abs(goal - nums)</code><ul><li><code>dif</code>小于<code>limit</code>，说明直接取一个<code>limit</code>中等于<code>dif</code>的那个数即可。</li><li><code>dif</code>大于<code>limit</code>，说明要反复取<code>limit</code>并更新<code>dif = abs(dif - limit)</code>直到让<code>dif</code>等于<code>0</code>或者小于<code>limit</code>。<br>根据上面思路即可写出下面的代码：</li></ul></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minElements</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], limit: <span class="hljs-built_in">int</span>, goal: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        nums_sum = <span class="hljs-built_in">sum</span>(nums)<br>        <span class="hljs-keyword">if</span> nums_sum == goal:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> limit &gt;= <span class="hljs-built_in">abs</span>(goal - nums_sum):<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        ans = <span class="hljs-number">0</span><br>        dif = <span class="hljs-built_in">abs</span>(goal - nums_sum)<br>        ans = dif // limit<br>        <span class="hljs-keyword">return</span> ans + <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> dif % limit != <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> ans<br></code></pre></td></tr></table></figure><h2 id="1945-字符串转化后的各位数字之和">1945.字符串转化后的各位数字之和</h2><p>两种思路，一种是利用ASCII进行转换，一种是利用哈希表进行转换。前者比后者简单（写起来）。<br>将字母替换成整数之后，再根据<code>k</code>的值再循环<code>k</code>次就行了，当然和只剩个位数的时候也能省去后面多余的循环。</p><ol><li>利用ASCII转换：</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">GetLucky</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> s, <span class="hljs-built_in">int</span> k</span>)</span> &#123;<br>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">char</span> ch <span class="hljs-keyword">in</span> s)<br>        &#123;<br>            sb.Append(ch - <span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-number">1</span>);<br>        &#125;<br>        String digits = sb.ToString();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= k &amp;&amp; digits.Length &gt; <span class="hljs-number">1</span>; ++i)<br>        &#123;<br>            <span class="hljs-built_in">int</span> sum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">char</span> ch <span class="hljs-keyword">in</span> digits)<br>            &#123;<br>                sum += ch - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<br>            digits = sum.ToString();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>.Parse(digits);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>利用哈希表转换：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getLucky</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        d = &#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>: <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>: <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>: <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;g&#x27;</span>: <span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27;h&#x27;</span>: <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>: <span class="hljs-string">&#x27;9&#x27;</span>, <span class="hljs-string">&#x27;j&#x27;</span>: <span class="hljs-string">&#x27;10&#x27;</span>,<br>             <span class="hljs-string">&#x27;k&#x27;</span>: <span class="hljs-string">&#x27;11&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>: <span class="hljs-string">&#x27;12&#x27;</span>, <span class="hljs-string">&#x27;m&#x27;</span>: <span class="hljs-string">&#x27;13&#x27;</span>, <span class="hljs-string">&#x27;n&#x27;</span>: <span class="hljs-string">&#x27;14&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>: <span class="hljs-string">&#x27;15&#x27;</span>, <span class="hljs-string">&#x27;p&#x27;</span>: <span class="hljs-string">&#x27;16&#x27;</span>, <span class="hljs-string">&#x27;q&#x27;</span>: <span class="hljs-string">&#x27;17&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>: <span class="hljs-string">&#x27;18&#x27;</span>, <span class="hljs-string">&#x27;s&#x27;</span>: <span class="hljs-string">&#x27;19&#x27;</span>, <span class="hljs-string">&#x27;t&#x27;</span>: <span class="hljs-string">&#x27;20&#x27;</span>,<br>             <span class="hljs-string">&#x27;u&#x27;</span>: <span class="hljs-string">&#x27;21&#x27;</span>, <span class="hljs-string">&#x27;v&#x27;</span>: <span class="hljs-string">&#x27;22&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>: <span class="hljs-string">&#x27;23&#x27;</span>, <span class="hljs-string">&#x27;x&#x27;</span>: <span class="hljs-string">&#x27;24&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>: <span class="hljs-string">&#x27;25&#x27;</span>, <span class="hljs-string">&#x27;z&#x27;</span>: <span class="hljs-string">&#x27;26&#x27;</span>, &#125;<br>        trantab = <span class="hljs-built_in">str</span>.maketrans(d)<br>        tmp = <span class="hljs-built_in">int</span>(s.translate(trantab))<br>        ans = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k):<br>            ans = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">while</span> tmp != <span class="hljs-number">0</span>:<br>                ans += tmp % <span class="hljs-number">10</span><br>                tmp = tmp // <span class="hljs-number">10</span><br>            tmp = ans<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h2 id="2027-转换字符串的最少操作次数">2027.转换字符串的最少操作次数</h2><p>由题目可得，我们每次操作都会改变三个连续字符，也就是说只要我们在字符串中碰到了一个<code>X</code>的话，当前字符与它后面两个字符我们都不需要进行判断了，因为我们必定要对此处进行操作，直接跳到<code>i + 3</code>的位置继续判断，直到遍历字符串完毕。<br>所以能够得到这样的思路：遍历字符串，遇到<code>X</code>则操作次数<code>ans += 1</code>，且遍历索引<code>index += 3</code>，否则<code>index += 1</code>，直至字符串遍历完毕（<code>index &gt;= s.Length</code>）。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">MinimumMoves</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> s</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> ans = <span class="hljs-number">0</span>, index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (index &lt; s.Length)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (s[index] == <span class="hljs-string">&#x27;X&#x27;</span>)<br>            &#123;<br>                ans += <span class="hljs-number">1</span>;<br>                index += <span class="hljs-number">3</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                index += <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minimumMoves</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-number">0</span><br>        ans = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> n &lt; <span class="hljs-built_in">len</span>(s):<br>            <span class="hljs-keyword">if</span> s[n] == <span class="hljs-string">&#x27;X&#x27;</span>:<br>                ans += <span class="hljs-number">1</span><br>                n += <span class="hljs-number">3</span><br>                <span class="hljs-keyword">continue</span><br>            n += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h1>垃圾话</h1><p>放假，就该在床上躺着，学什么习写什么题啊(<br>事，这就是我一个寒假没更新的理由(逃<br>顺便之后可能会挑着题目更了，感觉有一些简单题实在是，，，没必要啊，，，</p><hr>]]></content>
    
    
    <categories>
      
      <category>Solution</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>贪心</tag>
      
      <tag>数学</tag>
      
      <tag>数组</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣-1774. 最接近目标价格的甜点成本</title>
    <link href="/2022/12/04/leetcode-1774/"/>
    <url>/2022/12/04/leetcode-1774/</url>
    
    <content type="html"><![CDATA[<h1>题目描述</h1><p><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_1774_1.jpg" alt="1774_1"><br><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_1774_2.jpg" alt="1774_2"></p><h1>思路及实现</h1><h2 id="深度优先搜索">深度优先搜索</h2><p>对于深度优先搜索做法的话，就没什么好说的了，就是枚举所有情况然后找个最符合题意的结果返回就是了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">closestCost</span>(<span class="hljs-params">self, baseCosts: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], toppingCosts: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        ans_list = <span class="hljs-built_in">set</span>()  <span class="hljs-comment"># 记录所有成本</span><br>        ans = math.inf<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">depth: <span class="hljs-built_in">int</span>, cur_cost: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">nonlocal</span> ans_list<br>            ans_list.add(cur_cost)<br>            <span class="hljs-keyword">if</span> depth == <span class="hljs-built_in">len</span>(toppingCosts):  <span class="hljs-comment"># 深度搜索完毕</span><br>                <span class="hljs-keyword">return</span><br>            dfs(depth + <span class="hljs-number">1</span>, cur_cost + <span class="hljs-number">2</span> * toppingCosts[depth])  <span class="hljs-comment"># 添加两份当前配料</span><br>            dfs(depth + <span class="hljs-number">1</span>, cur_cost + toppingCosts[depth])  <span class="hljs-comment"># 添加一份当前配料</span><br>            dfs(depth + <span class="hljs-number">1</span>, cur_cost)  <span class="hljs-comment"># 不添加当前配料</span><br>        <span class="hljs-keyword">for</span> base_cost <span class="hljs-keyword">in</span> baseCosts:  <span class="hljs-comment"># 进行深度优先搜索</span><br>            dfs(<span class="hljs-number">0</span>, base_cost)<br>        <span class="hljs-keyword">for</span> cost <span class="hljs-keyword">in</span> ans_list:  <span class="hljs-comment"># 找到最小成本</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">abs</span>(cost - target) &lt; <span class="hljs-built_in">abs</span>(ans - target):  <span class="hljs-comment"># 当前成本差距小于记录的成本差距，直接更新</span><br>                ans = cost<br>            <span class="hljs-keyword">elif</span> <span class="hljs-built_in">abs</span>(cost - target) == <span class="hljs-built_in">abs</span>(ans - target):  <span class="hljs-comment"># 当前成本差距等于记录的成本差距，取更小成本</span><br>                <span class="hljs-keyword">if</span> cost &lt; ans:<br>                    ans = cost<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><p>当然，为了避免没有必要的搜索，可以进行剪枝。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">closestCost</span>(<span class="hljs-params">self, baseCosts: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], toppingCosts: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        ans = <span class="hljs-built_in">min</span>(baseCosts)<br>        <span class="hljs-comment"># 注意“成本差距”和“成本”两个概念</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">depth: <span class="hljs-built_in">int</span>, cur_cost: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">nonlocal</span> ans<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">abs</span>(ans - target) &lt; cur_cost - target:  <span class="hljs-comment"># 如果当前成本差距已经大于记录的成本差距，直接返回，因为继续搜索只会增加成本(注意，当前成本差值不取绝对值才能保证)</span><br>                <span class="hljs-keyword">return</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">abs</span>(ans - target) &gt;= <span class="hljs-built_in">abs</span>(cur_cost - target):<br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">abs</span>(ans - target) &gt; <span class="hljs-built_in">abs</span>(cur_cost - target):  <span class="hljs-comment"># 如果当前成本差距小于记录的成本差距</span><br>                    ans = cur_cost  <span class="hljs-comment"># 就更新最小成本差距</span><br>                <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 如果当前成本差距等于记录的成本差距</span><br>                    ans = <span class="hljs-built_in">min</span>(ans, cur_cost)  <span class="hljs-comment"># 记录更小的成本</span><br>            <span class="hljs-keyword">if</span> depth == <span class="hljs-built_in">len</span>(toppingCosts):  <span class="hljs-comment"># 深度搜索完毕</span><br>                <span class="hljs-keyword">return</span><br>            dfs(depth + <span class="hljs-number">1</span>, cur_cost + <span class="hljs-number">2</span> * toppingCosts[depth])  <span class="hljs-comment"># 添加两份当前配料</span><br>            dfs(depth + <span class="hljs-number">1</span>, cur_cost + toppingCosts[depth])  <span class="hljs-comment"># 添加一份当前配料</span><br>            dfs(depth + <span class="hljs-number">1</span>, cur_cost)  <span class="hljs-comment"># 不添加当前配料</span><br>        <span class="hljs-keyword">for</span> base_cost <span class="hljs-keyword">in</span> baseCosts:<br>            dfs(<span class="hljs-number">0</span>, base_cost)<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h2 id="动态规划">动态规划</h2><p>本题属于是01背包问题的变种，在这题里边，存在一定要放入且只能放入一个的基料，还有可放入可不放入的辅料，所以可以把辅料看作是背包问题中的物品，而这个物品（辅料）是可以放两次的，在背包问题中只能放一次，而且，对于这题，需要考虑如何处理大于<code>target</code>的部分，因为在01背包问题中，总物品重量是不能超过背包可承载重量的，但是这里制作成本可以超过目标制造成本，因为我们考虑的是更小的成本差距。<br>那就需要对于这些不同的部分进行处理了，我们来一步一步处理：</p><ol><li>在这里，我们是通过01背包问题的方式来求对于一个成本<code>cost</code>，我们是否能够找到一个构造方案。最后再找到距离<code>target</code>最近的可构造的成本方案。</li><li>题目有一个隐藏上限：即成本差距最大就是<code>(target - min(baseCosts))</code>，大于此成本差距的制作方法一定不是最优解。</li><li>首先对于放入的基料而言，如果处理？对于小于<code>target</code>的基料，我们就尝试往上面添加辅料，即把它们作为动态规划数组的初始状态；对于大于<code>target</code>的基料，根据第1点提到过的上限，我们可以知道如果基料成本大于<code>2 * target - min(baseCosts)</code>的话一定不是最优解，小于的话，就用它更新最小成本。</li><li>对于一种辅料最多放两份，那就每种辅料都处理两次，即进行两次循环。</li><li>如何添加辅料？对于一种方案<code>cost</code>，我们设<code>i</code>为第<code>i</code>种辅料，那么有<code>dp[cost] = dp[cost - toppingCosts[i]] | dp[cost]</code>。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">closestCost</span>(<span class="hljs-params">self, baseCosts: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], toppingCosts: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        cost = <span class="hljs-built_in">min</span>(baseCosts)<br>        <span class="hljs-keyword">if</span> cost &gt;= target:<br>            <span class="hljs-keyword">return</span> cost<br>        ans = <span class="hljs-number">2</span> * target - cost<br>        dp = [<span class="hljs-literal">False</span>] * (target + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> baseCosts:<br>            <span class="hljs-keyword">if</span> c == target:<br>                <span class="hljs-keyword">return</span> c<br>            <span class="hljs-keyword">if</span> c &gt; target:<br>                ans = <span class="hljs-built_in">min</span>(ans, c)<br>            <span class="hljs-keyword">else</span>:<br>                dp[c] = <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> toppingCosts:<br>            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>):<br>                <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(target, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>):<br>                    <span class="hljs-keyword">if</span> dp[c] <span class="hljs-keyword">and</span> c + i &gt; target:  <span class="hljs-comment"># 在这题中要额外处理一种成本方案加入辅料后大于target的情况</span><br>                        ans = <span class="hljs-built_in">min</span>(ans, c + i)<br>                    <span class="hljs-keyword">if</span> c &gt; i:  <span class="hljs-comment"># 01背包构造成本方案</span><br>                        dp[c] |= dp[c - i]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(ans - target + <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> dp[target - i]:<br>                <span class="hljs-keyword">return</span> target - i<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h1>其他话（关于背包DP）</h1><p>没想到吧，这么经典的题我也是第一次了解，之前只听过没写过。<br>首先是放一下学习的地方嗷：<a href="https://oi-wiki.org/dp/knapsack/">背包DP</a><br>这里主要是写一些我在看这个问题时候的疑惑以及解释。</p><h2 id="第一个疑惑：错误的核心代码里边写的什么？l从0到W-w-i-是啥意思啊？">第一个疑惑：错误的核心代码里边写的什么？<code>l</code>从<code>0</code>到<code>W - w[i]</code>是啥意思啊？</h2><blockquote><p>还有一点需要注意的是，很容易写出这样的错误核心代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># Python Version</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>    l = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> l &lt;= W - w[i]:<br>        f[l + w[i]] = <span class="hljs-built_in">max</span>(f[l] + v[i], f[l + w[i]])<br>        l += <span class="hljs-number">1</span><br><span class="hljs-comment"># 由 f[i][l + w[i]] = max(max(f[i - 1][l + w[i]],f[i - 1][l] + w[i]),f[i][l + w[i]]) 简化而来</span><br></code></pre></td></tr></table></figure></blockquote><p>OK，那么要明白对于背包问题中<code>f[i][j]</code>是什么，<code>f[i][j]</code>就是只放前<code>i</code>（包括第<code>i</code>个）个物品时，背包重量为<code>j</code>的时候，背包中物品的最大价值。<br>那么现在能够看出，这里在求从<code>f[i][0 + w[i]]</code>开始，一直到<code>f[i][l + w[i]]</code>（为什么是这个数呢？因为不能超过背包可承载的重量<code>W</code>），计算<code>f[0 + w[i]]</code>至<code>f[l + w[i]]</code>每一个重量下所能达到的最大总价值。<br>为什么这里错了呢？因为<code>f[i][j]</code>会受到<code>f[i][j - w[i]]</code>的影响，这又是什么意思呢？意思是我们并不知道<code>f[i][j - w[i]]</code>这种情况下是否是在<code>i</code>被塞入的时候计算得出的，如果是，而且<code>f[i][j]</code>还更新为<code>f[i][j - w[i]]</code>的值的话，那就相当于把这个物品塞入多次，不符合题意了。</p><blockquote><p>举个例子，现在有<code>l = 2， w[i] = 4</code>，那么会有：<code>f[2 + 4] = max(f[2] + v[i], f[2 + 4])</code>，而对于在这之后可能出现的情况<code>l = 6， w[i] = 4</code>，又有：<code>f[6 + 4] = max(f[6] + v[i], f[6 + 4])</code>，而这其中出现的<code>f[6]</code>，怎么保证不是我们之前在求<code>f[2 + 4]</code>的时候取的<code>f[2] + v[i]</code>的值呢？如果是的话，那物品<code>i</code>不就相当于放入多次了吗？<br>所以，为了避免出现这种情况，我们选择了从<code>l = W</code>开始枚举而不是从<code>l = 0</code>开始。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br><span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(W, w[i], -<span class="hljs-number">1</span>):<br>f[l] = <span class="hljs-built_in">max</span>(f[l], f[l - w[i]] + v[i])<br></code></pre></td></tr></table></figure><p>这样，我们就能保证<code>f[i][j]</code>总是在<code>f[i][j - w[i]]</code>之前更新了。<br>至此，01背包问题就解决完毕了。</p><hr>]]></content>
    
    
    <categories>
      
      <category>Solution</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Leetcode</tag>
      
      <tag>动态规划</tag>
      
      <tag>深度优先搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣-1779. 找到最近的有相同 X 或 Y 坐标的点</title>
    <link href="/2022/12/01/leetcode-1779/"/>
    <url>/2022/12/01/leetcode-1779/</url>
    
    <content type="html"><![CDATA[<h1>题目描述</h1><p><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_1779_1.jpg" alt="1779"></p><h1>思路及实现</h1><p>呃，rating 1200的题目，就不用多讲了吧，遍历<code>points</code>列表，如果<code>x</code>或者<code>y</code>坐标相同的话，就计算曼哈顿距离，然后维护最小曼哈顿距离<code>mht_dis</code>和计算得出这个距离的索引<code>index</code>就ok了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">nearestValidPoint</span>(<span class="hljs-params">self, x: <span class="hljs-built_in">int</span>, y: <span class="hljs-built_in">int</span>, points: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        mht_dis = math.inf<br>        index = -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i, p <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(points):<br>            <span class="hljs-keyword">if</span> x == p[<span class="hljs-number">0</span>] <span class="hljs-keyword">or</span> y == p[<span class="hljs-number">1</span>]:<br>                tmp_mht_dis = <span class="hljs-built_in">abs</span>(x - p[<span class="hljs-number">0</span>]) + <span class="hljs-built_in">abs</span>(y - p[<span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">if</span> tmp_mht_dis &lt; mht_dis:<br>                    index = i<br>                    mht_dis = tmp_mht_dis<br>        <span class="hljs-keyword">return</span> index<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>Solution</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Leetcode</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣-895. 最大频率栈</title>
    <link href="/2022/11/30/leetcode-895/"/>
    <url>/2022/11/30/leetcode-895/</url>
    
    <content type="html"><![CDATA[<h1>题目描述</h1><p><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_895_1.png" alt="895"></p><h1>思路及实现</h1><h2 id="借助Counter类及其方法">借助Counter类及其方法</h2><p>这是我一开始想到的思路，毕竟是python，能借就借嘛。<code>Counter</code>就能够统计每个元素出现的次数，而<code>most_common</code>方法又能够把频率最高的找出来，这不就显而易见出答案了嘛~</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FreqStack</span>:<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.stack = <span class="hljs-built_in">list</span>()  <span class="hljs-comment"># 栈</span><br>        self.cnt = Counter()  <span class="hljs-comment"># 保存出现频率</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">push</span>(<span class="hljs-params">self, val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        self.stack.append(val)<br>        self.cnt[val] += <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pop</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        tmp_list = self.cnt.most_common()<br>        num_list = []<br>        frequecy = tmp_list[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> tmp_list:  <span class="hljs-comment"># 找出所有频率相同的数</span><br>            <span class="hljs-keyword">if</span> t[<span class="hljs-number">1</span>] == frequecy:<br>                num_list.append(t[<span class="hljs-number">0</span>])<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(self.stack) - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> self.stack[i] <span class="hljs-keyword">in</span> num_list:<br>                self.cnt[self.stack[i]] -= <span class="hljs-number">1</span><br>                <span class="hljs-keyword">return</span> self.stack.pop(i)<br></code></pre></td></tr></table></figure><p>OK，超时了，很符合我对偷懒下场的想象。那就只好另起炉灶了。</p><h2 id="依旧借助Counter类，但是利用频率栈">依旧借助Counter类，但是利用频率栈</h2><p>思路来源：<a href="https://leetcode.cn/problems/maximum-frequency-stack/solutions/1998430/mei-xiang-ming-bai-yi-ge-dong-hua-miao-d-oich/">灵神</a><br><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_895_2.jpg" alt="895"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FreqStack</span>:<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.stacks: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]] = <span class="hljs-built_in">list</span>()  <span class="hljs-comment"># 频率栈的列表</span><br>        self.cnt: Counter = Counter()  <span class="hljs-comment"># 保存出现频率</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">push</span>(<span class="hljs-params">self, val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">if</span> self.cnt[val] == <span class="hljs-built_in">len</span>(self.stacks):  <span class="hljs-comment"># 出现新的最大频率，新建频率栈</span><br>            self.stacks.append([val])<br>        <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 已有这种频率的频率栈，直接加入</span><br>            self.stacks[self.cnt[val]].append(val)<br>        self.cnt[val] += <span class="hljs-number">1</span>  <span class="hljs-comment"># 最后更新频率，就能避免1对上0的情况</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pop</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        val = self.stacks[-<span class="hljs-number">1</span>].pop()  <span class="hljs-comment"># 取最高频率栈栈顶的数</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.stacks[-<span class="hljs-number">1</span>]:  <span class="hljs-comment"># 最高频率栈空了，先删掉，下次有数再创建回来，防止空操作</span><br>            self.stacks.pop()<br>        self.cnt[val] -= <span class="hljs-number">1</span>  <span class="hljs-comment"># 更新频率</span><br>        <span class="hljs-keyword">return</span> val<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Solution</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Leetcode</tag>
      
      <tag>栈</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣-813. 最大平均值和的分组</title>
    <link href="/2022/11/29/leetcode-813/"/>
    <url>/2022/11/29/leetcode-813/</url>
    
    <content type="html"><![CDATA[<h1>题目描述</h1><p><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_813_1.png" alt="813"></p><h1>思路及实现</h1><p>dp问题，啊，一定要好好从入门做起，啊，不要上来就看这种看半天都没点想法，啊，对水平提升很没帮助，啊，就是我，啊(悲<br>不过好在起码是能看懂别人的思路的(<br>这边学到了两种思路，一种是前缀和+深度优先搜索，另一种是前缀和+动态规划。</p><h2 id="前缀和-动态规划">前缀和+动态规划</h2><p>思路参考：<a href="https://leetcode.cn/problems/largest-sum-of-averages/solutions/1993132/zui-da-ping-jun-zhi-he-de-fen-zu-by-leet-09xt/">官解</a><br>因为本题需要用到平均值，为了方便计算，可以用一个数组<code>prefix</code>先把前缀和保存起来。<br>然后思考动态规划用到的数组<code>dp[i][j]</code>如何设计，以及写出转移方程。要找出给定数组的最大分数，我们可以先找更小数组中的最大分数，那就让<code>i</code>表示前<code>nums</code>中的前<code>i</code>个（不包括<code>i</code>）元素，<code>j</code>表示切分的子数组数，那么<code>dp[i][j]</code>的意思就是<code>nums</code>使用前<code>i</code>个（不包括第<code>i</code>个）元素并切分成<code>j</code>个子数组的最大平均值和。<br>接着找出一般情况和特殊情况，根据这些情况就能够写出转移方程了：</p><ul><li>特殊情况：当<code>j = 1</code>时，<code>dp[i][j]</code>的值就是前<code>i</code>个元素的平均值。</li><li>一般情况：当<code>j &gt; 1</code>时，就利用枚举，从第<code>x = j - 1</code>个元素开始（因为最小分组不能为空，至少需要一个元素）到<code>i - 1</code>，将<code>dp[i][j]</code>分为两个部分，<code>[0, x - 1]</code>和<code>[x, i - 1]</code>，比较当前<code>dp[i][j]</code>和<code>dp[x][j - 1] + (prefix[i] - prefix[x]) / (i- x)</code>的值哪个更大，用大的值更新<code>dp[i][j]</code>。<br>最后写出状态转移方程：<br><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_813_dp.jpg" alt="813_dp"></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">largestSumOfAverages</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">float</span>:<br>        prefix = [<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> index, num <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):<br>            prefix.append(prefix[index] + num)  <span class="hljs-comment"># 计算前缀和</span><br>        dp = [[<span class="hljs-number">0.0</span>] * (k + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums) + <span class="hljs-number">1</span>)]  <span class="hljs-comment"># 初始化dp数组</span><br>        <span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums) + <span class="hljs-number">1</span>):  <span class="hljs-comment"># 处理j = 1的情况</span><br>            dp[index][<span class="hljs-number">1</span>] = prefix[index] / index<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, k + <span class="hljs-number">1</span>):  <span class="hljs-comment"># 处理j &gt; 1的情况</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(j, <span class="hljs-built_in">len</span>(nums) + <span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(j - <span class="hljs-number">1</span>, i):<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], dp[x][j - <span class="hljs-number">1</span>] + (prefix[i] - prefix[x]) / (i - x))<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">len</span>(nums)][k]<br></code></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> <span class="hljs-title">LargestSumOfAverages</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] nums, <span class="hljs-built_in">int</span> k</span>)</span><br>        &#123;<br>            <span class="hljs-built_in">int</span> n = nums.Length;<br>            <span class="hljs-built_in">double</span>[] prefix = <span class="hljs-keyword">new</span> <span class="hljs-built_in">double</span>[n + <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>            &#123;<br>                prefix[i + <span class="hljs-number">1</span>] = prefix[i] + nums[i];<br>            &#125;<br>            <span class="hljs-built_in">double</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">double</span>[n + <span class="hljs-number">1</span>][];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)<br>            &#123;<br>                dp[i] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">double</span>[k + <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>            &#123;<br>                dp[i][<span class="hljs-number">1</span>] = prefix[i] / i;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">2</span>; j &lt;= k; j++)<br>            &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = j; i &lt;= n; i++)<br>                &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> x = j - <span class="hljs-number">1</span>; x &lt; i; x++)<br>                    &#123;<br>                        dp[i][j] = Math.Max(dp[i][j], dp[x][j - <span class="hljs-number">1</span>] + (prefix[i] - prefix[x]) / (i - x));<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> dp[n][k];<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="前缀和-深度优先搜索">前缀和+深度优先搜索</h2><p>思路参考：<a href="https://leetcode.cn/problems/largest-sum-of-averages/solutions/1995066/by-lcbin-5efy/">ylb</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">largestSumOfAverages</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">float</span>:<br><span class="hljs-meta">        @cache</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">i, k</span>):<br>            <span class="hljs-keyword">if</span> i == n:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> k == <span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">return</span> (s[-<span class="hljs-number">1</span>] - s[i]) / (n - i)<br>            ans = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i, n):<br>                t = (s[j + <span class="hljs-number">1</span>] - s[i]) / (j - i + <span class="hljs-number">1</span>) + dfs(j + <span class="hljs-number">1</span>, k + <span class="hljs-number">1</span>)<br>                ans = <span class="hljs-built_in">max</span>(ans, t)<br>            <span class="hljs-keyword">return</span> ans<br><br>        n = <span class="hljs-built_in">len</span>(nums)<br>        s = <span class="hljs-built_in">list</span>(accumulate(nums, initial = <span class="hljs-number">0</span>))<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, k)<br></code></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">double</span>[,] f;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span>[] s;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> n;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> <span class="hljs-title">LargestSumOfAverages</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] nums, <span class="hljs-built_in">int</span> k</span>)</span><br>        &#123;<br>            n = nums.Length;<br>            s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[n + <span class="hljs-number">1</span>];<br>            f = <span class="hljs-keyword">new</span> <span class="hljs-built_in">double</span>[n + <span class="hljs-number">1</span>, k + <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>            &#123;<br>                s[i + <span class="hljs-number">1</span>] = s[i] + nums[i];<br>            &#125;<br>            <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, k);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-built_in">double</span> <span class="hljs-title">dfs</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> i, <span class="hljs-built_in">int</span> k</span>)</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (i == n)<br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>)<br>            &#123;<br>                <span class="hljs-keyword">return</span> (s[n] - s[i]) * <span class="hljs-number">1.0</span> / (n - i);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (f[i, k] != <span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-keyword">return</span> f[i, k];<br>            &#125;<br>            <span class="hljs-built_in">double</span> ans = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = i; j &lt; n; ++j)<br>            &#123;<br>                <span class="hljs-built_in">double</span> t = (s[j + <span class="hljs-number">1</span>] - s[i]) * <span class="hljs-number">1.0</span> / (j - i + <span class="hljs-number">1</span>) + dfs(j + <span class="hljs-number">1</span>, k - <span class="hljs-number">1</span>);<br>                ans = Math.Max(ans, t);<br>            &#125;<br>            <span class="hljs-keyword">return</span> f[i, k] = ans;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1>垃圾话</h1><p>怎么有人欠题目欠了三个月的啊？就en⬆摆是吧？<br>私密马赛红豆泥私密马赛(90°鞠躬*n</p><hr>]]></content>
    
    
    <categories>
      
      <category>Solution</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Leetcode</tag>
      
      <tag>动态规划</tag>
      
      <tag>前缀和</tag>
      
      <tag>深度优先搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣-1758. 生成交替二进制字符串的最少操作数</title>
    <link href="/2022/11/29/leetcode-1758/"/>
    <url>/2022/11/29/leetcode-1758/</url>
    
    <content type="html"><![CDATA[<h1>题目描述</h1><p><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_1758_1.png" alt="1758"></p><h1>思路及实现</h1><h2 id="土方法遍历">土方法遍历</h2><p>不想思考？那就遍历吧。设置两个bool变量和两个计数变量，遇到需要修改的地方计数加一，最后返回小的那个就好了。<br>这里两个bool变量分别对应<code>01</code>和<code>10</code>的情况，每循环一次都修改一次就能达到目的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minOperations</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        flag_a = <span class="hljs-literal">False</span><br>        flag_b = <span class="hljs-literal">True</span><br>        cnt_a = <span class="hljs-number">0</span><br>        cnt_b = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> s:<br>            <span class="hljs-keyword">if</span> flag_a == <span class="hljs-built_in">int</span>(c):<br>                cnt_a += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> flag_b == <span class="hljs-built_in">int</span>(c):<br>                cnt_b += <span class="hljs-number">1</span><br>            flag_a = <span class="hljs-keyword">not</span> flag_a<br>            flag_b = <span class="hljs-keyword">not</span> flag_b<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(cnt_a, cnt_b)<br></code></pre></td></tr></table></figure><h2 id="找规律">找规律</h2><p>这不都知道字符串最后无非都会变成<code>0101...</code>和<code>1010...</code>的情况了嘛，可以根据这个知道，如果其中一种情况需要改变的次数为<code>cnt_a</code>，那么另外一种情况需要改变的次数就是<code>cnt_b = len(s) - cnt_a</code>，这样就能降低点复杂度。<br>我们又能知道，<code>0</code>和<code>1</code>无非就是奇数和偶数，根据遍历时候的每一位索引余<code>2</code>的结果来产生<code>0</code>和<code>1</code>又可以降低一点复杂度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minOperations</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        cnt = <span class="hljs-number">0</span><br>        n = <span class="hljs-built_in">len</span>(s)<br>        <span class="hljs-keyword">for</span> i, c <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(s):<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">int</span>(c) != i % <span class="hljs-number">2</span>:<br>                cnt += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(cnt, n - cnt)<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>Solution</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Leetcode</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣-878. 第 N 个神奇数字</title>
    <link href="/2022/11/27/leetcode-878/"/>
    <url>/2022/11/27/leetcode-878/</url>
    
    <content type="html"><![CDATA[<h1>题目描述</h1><p><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_878_1.png" alt="878"></p><h1>思路及实现</h1><h2 id="找规律">找规律</h2><p>看到这种和数学沾点关系的我就喜欢嗯找规律，多举几个例子再进行数学归纳，直接拿下！<br><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_878_2.png" alt="规律"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">nthMagicalNumber</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, a: <span class="hljs-built_in">int</span>, b: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        MOD = <span class="hljs-number">10</span> ** <span class="hljs-number">9</span> + <span class="hljs-number">7</span><br>        c = lcm(a, b)<br>        m = c // a + c // b - <span class="hljs-number">1</span><br>        r = n % m<br>        res = c * (n // m) % MOD<br>        <span class="hljs-keyword">if</span> r == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> res<br>        addA = a<br>        addB = b<br>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(r - <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> addA &lt; addB:<br>                addA += a<br>            <span class="hljs-keyword">else</span>:<br>                addB += b<br>        <span class="hljs-keyword">return</span> (res + <span class="hljs-built_in">min</span>(addA, addB) % MOD) % MOD<br></code></pre></td></tr></table></figure><h2 id="二分查找">二分查找</h2><p>这个二分确实不看题解没想过，榆木脑袋是这样的呜呜<br><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_878_3.png" alt="二分查找"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">nthMagicalNumber</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, a: <span class="hljs-built_in">int</span>, b: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        MOD = <span class="hljs-number">10</span> ** <span class="hljs-number">9</span> + <span class="hljs-number">7</span><br>        l = <span class="hljs-built_in">min</span>(a, b)<br>        r = n * <span class="hljs-built_in">min</span>(a, b)<br>        c = lcm(a, b)<br>        <span class="hljs-keyword">while</span> l &lt;= r:<br>            mid = (l + r) // <span class="hljs-number">2</span><br>            cnt = mid // a + mid // b - mid // c<br>            <span class="hljs-keyword">if</span> cnt &gt;= n:<br>                r = mid - <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                l = mid + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> (r + <span class="hljs-number">1</span>) % MOD<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>Solution</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Leetcode</tag>
      
      <tag>数学</tag>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣-1752. 检查数组是否经排序和轮转得到</title>
    <link href="/2022/11/27/leetcode-1752/"/>
    <url>/2022/11/27/leetcode-1752/</url>
    
    <content type="html"><![CDATA[<h1>题目描述</h1><p><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_1752_1.png" alt="1752"></p><h1>思路及实现</h1><p>题目的意思其实就是给你一个数组，然后如果这个数组不是完全单调递增的话，找到不能够单调递增的地方，然后从这个地方开始一直到最后的部分搬到最前边去，判断这样新产生的数组是否是单调递增的。<br>所以思路也十分简单：</p><ol><li>找到需要进行分割的位置</li><li>对数组进行重组</li><li>将重组数组与排序后的数组进行比较<br>根据这个思路可以写出如下代码：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">check</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        pre_num = <span class="hljs-number">0</span><br>        div_pos = -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i, num <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):<br>            <span class="hljs-keyword">if</span> num &lt; pre_num:<br>                div_pos = i<br>                <span class="hljs-keyword">break</span><br>            pre_num = num<br>        <span class="hljs-keyword">if</span> div_pos == -<span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> nums[div_pos:] + nums[:div_pos] == <span class="hljs-built_in">sorted</span>(nums)<br></code></pre></td></tr></table></figure><p>我们还可以利用<code>flag</code>判断产生多少次递减来做：</p><ol><li>如果产生两次递减，返回False</li><li>如果没有产生递减，返回True</li><li>如果产生一次递减，若数组最后一位数大于数组第一位数则返回False，否则True</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">check</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        pre_num = <span class="hljs-number">0</span><br>        flag = <span class="hljs-literal">False</span>  <span class="hljs-comment"># 检查是否出现递减</span><br>        <span class="hljs-keyword">for</span> i, num <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):<br>            <span class="hljs-keyword">if</span> num &lt; pre_num:<br>                <span class="hljs-keyword">if</span> flag:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>                <span class="hljs-keyword">else</span>:<br>                    flag = <span class="hljs-literal">True</span><br>            pre_num = num<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">not</span> flag <span class="hljs-keyword">or</span> flag <span class="hljs-keyword">and</span> nums[<span class="hljs-number">0</span>] &gt;= nums[-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Leetcode</tag>
      
      <tag>[object Object]</tag>
      
      <tag>Solution</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣-1742. 盒子中小球的最大数量</title>
    <link href="/2022/11/27/leetcode-1742/"/>
    <url>/2022/11/27/leetcode-1742/</url>
    
    <content type="html"><![CDATA[<h1>题目描述</h1><p><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_1742_1.png" alt="1742"></p><h1>思路及实现</h1><p>既然盒子的编号等于小球编号上每位数字的和，而且我们需要记住每个盒子里边的小球数量，那就用<code>dict</code>吧；<br>相信求一个数字每位上的和对每位程序员来说是再熟悉不过的了，那这题的代码自然一下就出来了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">countBalls</span>(<span class="hljs-params">self, lowLimit: <span class="hljs-built_in">int</span>, highLimit: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        ans = <span class="hljs-number">0</span><br>        boxes = <span class="hljs-built_in">dict</span>()<br>        num = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> ball <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(lowLimit, highLimit + <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">while</span> ball != <span class="hljs-number">0</span>:<br>                num += ball % <span class="hljs-number">10</span><br>                ball = ball // <span class="hljs-number">10</span><br>            <span class="hljs-keyword">if</span> num <span class="hljs-keyword">in</span> boxes:<br>                boxes[num] = boxes[num] + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                boxes[num] = <span class="hljs-number">1</span><br>            ans = <span class="hljs-built_in">max</span>(boxes[num], ans)<br>            num = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><p>PS：这题还能找规律，看了下“爪哇缪斯”的题解，牛蛙！<strong>B球所在箱子编号 = A球所在箱子编号 - （9 * [末尾9的个数]）+ 1</strong>，B球就是跟在A球后面的第一个球，比如<code>2</code>是B球那<code>1</code>就是A球。</p><hr>]]></content>
    
    
    <categories>
      
      <category>Solution</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Leetcode</tag>
      
      <tag>哈希表</tag>
      
      <tag>数学</tag>
      
      <tag>计数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习Vue时候随手写的东西-2</title>
    <link href="/2022/11/23/vue-learning-2/"/>
    <url>/2022/11/23/vue-learning-2/</url>
    
    <content type="html"><![CDATA[<h1>事件绑定</h1><h2 id="事件修饰符">事件修饰符</h2><p>为了使用方便，Vue 为<code>v-on</code>提供了事件修饰符。修饰符是用<code>.</code>表示的指令后缀，包含以下这些：</p><ul><li><code>.stop</code>  // <code>event.stopPropagation()</code></li><li><code>.prevent</code>  // <code>event.preventDefault()</code></li><li><code>.self</code></li><li><code>.capture</code></li><li><code>.once</code></li><li><code>.passive</code></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 单击事件将停止传递 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> @<span class="hljs-attr">click.stop</span>=<span class="hljs-string">&quot;doThis&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 提交事件将不再重新加载页面 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> @<span class="hljs-attr">submit.prevent</span>=<span class="hljs-string">&quot;onSubmit&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 修饰语可以使用链式书写 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> @<span class="hljs-attr">click.stop.prevent</span>=<span class="hljs-string">&quot;doThat&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 也可以只有修饰符 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> @<span class="hljs-attr">submit.prevent</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 仅当 event.target 是元素本身时才会触发事件处理器 --&gt;</span><br><span class="hljs-comment">&lt;!-- 例如：事件处理器不来自子元素 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> @<span class="hljs-attr">click.self</span>=<span class="hljs-string">&quot;doThat&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>使用修饰符时需要注意调用顺序，因为相关代码是以相同的顺序生成的。<br>因此使用<code>@click.prevent.self</code>会阻止元素及其子元素的所有点击事件的默认行为而<code>@click.self.prevent</code>则只会阻止对元素本身的点击事件的默认行为。</p>          </div><p><code>.capture</code>、<code>.once</code>和<code>.passive</code>修饰符与原生<code>addEventListener</code>事件相对应：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 添加事件监听器时，使用 `capture` 捕获模式 --&gt;</span><br><span class="hljs-comment">&lt;!-- 例如：指向内部元素的事件，在被内部元素处理前，先被外部处理 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> @<span class="hljs-attr">click.capture</span>=<span class="hljs-string">&quot;doThis&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 点击事件最多被触发一次 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> @<span class="hljs-attr">click.once</span>=<span class="hljs-string">&quot;doThis&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 滚动事件的默认行为 (scrolling) 将立即发生而非等待 `onScroll` 完成 --&gt;</span><br><span class="hljs-comment">&lt;!-- 以防其中包含 `event.preventDefault()` --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> @<span class="hljs-attr">scroll.passive</span>=<span class="hljs-string">&quot;onScroll&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>.passive</code>修饰符一般用于触摸事件的监听器，可以用来改善移动端设备的滚屏性能。</p><div class="note note-warning">            <p>请勿同时使用<code>.passive</code>和<code>.prevent</code>，因为<code>.passive</code>已经向浏览器表明了你不想阻止事件的默认行为。<br>如果你这么做了，则<code>.prevent</code>会被忽略，并且浏览器会抛出警告。</p>          </div><h2 id="按键修饰符">按键修饰符</h2><p>在监听键盘事件时，我们经常需要检查特定的按键。Vue允许在<code>v-on</code>或<code>@</code>监听按键事件时添加按键修饰符。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 仅在 `key` 为 `Enter` 时调用 `submit` --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> @<span class="hljs-attr">keyup.enter</span>=<span class="hljs-string">&quot;submit&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> @<span class="hljs-attr">keyup.page-down</span>=<span class="hljs-string">&quot;onPageDown&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>Vue 为一些常用的按键提供了别名：</p><ul><li><code>.enter</code></li><li><code>.tab</code></li><li><code>.delete</code> (捕获“Delete”和“Backspace”两个按键)</li><li><code>.esc</code></li><li><code>.space</code></li><li><code>.up</code></li><li><code>.down</code></li><li><code>.left</code></li><li><code>.right</code><br>你可以使用以下系统按键修饰符来触发鼠标或键盘事件监听器，只有当按键被按下时才会触发。</li><li><code>.ctrl</code></li><li><code>.alt</code></li><li><code>.shift</code></li><li><code>.meta</code></li></ul><div class="note note-warning">            <p>请注意，系统按键修饰符和常规按键不同。与<code>keyup</code>事件一起使用时，该按键必须在事件发出时处于按下状态。<br>换句话说，<code>keyup.ctrl</code>只会在你仍然按住<code>ctrl</code>但松开了另一个键时被触发。若你单独松开<code>ctrl</code>键将不会触发。</p>          </div><p><code>.exact</code>修饰符允许控制触发一个事件所需的确定组合的系统按键修饰符。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 当按下 Ctrl 时，即使同时按下 Alt 或 Shift 也会触发 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.ctrl</span>=<span class="hljs-string">&quot;onClick&quot;</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 仅当按下 Ctrl 且未按任何其他键时才会触发 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.ctrl.exact</span>=<span class="hljs-string">&quot;onCtrlClick&quot;</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 仅当没有按下任何系统按键时触发 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.exact</span>=<span class="hljs-string">&quot;onClick&quot;</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><h1>侦听器</h1><h2 id="侦听数据源类型">侦听数据源类型</h2><p><code>watch</code>的第一个参数可以是不同形式的“数据源”：它可以是一个 ref (包括计算属性)、一个响应式对象、一个<code>getter</code>函数、或多个数据源组成的数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> x = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<br><span class="hljs-keyword">const</span> y = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<br><br><span class="hljs-comment">// 单个 ref</span><br><span class="hljs-title function_">watch</span>(x, <span class="hljs-function">(<span class="hljs-params">newX</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`x is <span class="hljs-subst">$&#123;newX&#125;</span>`</span>)<br>&#125;)<br><br><span class="hljs-comment">// getter 函数</span><br><span class="hljs-title function_">watch</span>(<br>  <span class="hljs-function">() =&gt;</span> x.<span class="hljs-property">value</span> + y.<span class="hljs-property">value</span>,<br>  <span class="hljs-function">(<span class="hljs-params">sum</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`sum of x + y is: <span class="hljs-subst">$&#123;sum&#125;</span>`</span>)<br>  &#125;<br>)<br><br><span class="hljs-comment">// 多个来源组成的数组</span><br><span class="hljs-title function_">watch</span>([x, <span class="hljs-function">() =&gt;</span> y.<span class="hljs-property">value</span>], <span class="hljs-function">(<span class="hljs-params">[newX, newY]</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`x is <span class="hljs-subst">$&#123;newX&#125;</span> and y is <span class="hljs-subst">$&#123;newY&#125;</span>`</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>Learning Log</category>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习Vue时候随手写的东西-1</title>
    <link href="/2022/11/23/vue-learning-1/"/>
    <url>/2022/11/23/vue-learning-1/</url>
    
    <content type="html"><![CDATA[<h1>响应式</h1><h2 id="使用reactive-创建响应式对象或数组">使用<code>reactive()</code>创建响应式对象或数组</h2><p>我们可以使用<code>reactive()</code>函数创建一个响应式对象或数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script setup&gt;<br><span class="hljs-keyword">import</span> &#123; reactive &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;)<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;<br>  state.<span class="hljs-property">count</span>++<br>&#125;<br>&lt;/script&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;increment&quot;</span>&gt;</span></span><br><span class="language-xml">    &#123;&#123; state.count &#125;&#125;</span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>可以看到如果要访问<code>state</code>的属性的话，直接使用<code>.</code>运算符即可。<br>值得注意的是，<code>reactive()</code>返回的是一个原始对象的 Proxy，它和原始对象是不相等的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> raw = &#123;&#125;<br><span class="hljs-keyword">const</span> proxy = <span class="hljs-title function_">reactive</span>(raw)<br><br><span class="hljs-comment">// 代理对象和原始对象不是全等的</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy === raw) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>由于JS会自动转型，所以在JS中，两个等号是会先将两边的值转为布尔型再进行比较，而三个等号就是严格判定，可以说JS中的三个等号等于其他语言中的两个等号。<br><code>reactive()</code>API有两条限制：</p><ol><li>仅对对象类型有效（对象、数组和<code>Map</code>、<code>Set</code>这样的集合类型），而对<code>string</code>、<code>number</code>和<code>boolean</code>这样的原始类型无效。</li><li>因为 Vue 的响应式系统是通过属性访问进行追踪的，因此我们必须始终保持对该响应式对象的相同引用。这意味着我们不可以随意地“替换”一个响应式对象，因为这将导致对初始引用的响应性连接丢失，同时这也意味着当我们将响应式对象的属性赋值或解构至本地变量时，或是将该属性传入一个函数时，我们会失去响应性。</li></ol><h2 id="使用ref-定义响应式变量">使用<code>ref()</code>定义响应式变量</h2><p><code>reactive()</code>的种种限制归根结底是因为<code>JavaScript</code>没有可以作用于所有值类型的 “引用” 机制。为此，Vue提供了一个<code>ref()</code>方法来允许我们创建可以使用任何值类型的响应式ref：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><code>ref()</code>将传入参数的值包装为一个带<code>.value</code>属性的ref对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count) <span class="hljs-comment">// &#123; value: 0 &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count.<span class="hljs-property">value</span>) <span class="hljs-comment">// 0</span><br><br>count.<span class="hljs-property">value</span>++<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count.<span class="hljs-property">value</span>) <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>当ref在模板中作为顶层属性被访问时，它们会被自动“解包”，所以不需要使用<code>.value</code>。下面是之前的计数器例子，用<code>ref()</code>代替：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script setup&gt;<br><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;<br>  count.<span class="hljs-property">value</span>++<br>&#125;<br>&lt;/script&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;increment&quot;</span>&gt;</span></span><br><span class="language-xml">    &#123;&#123; count &#125;&#125; <span class="hljs-comment">&lt;!-- 无需 .value --&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>跟响应式对象不同，当ref作为响应式数组或像<code>Map</code>这种原生集合类型的元素被访问时，不会进行解包。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> books = <span class="hljs-title function_">reactive</span>([<span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;Vue 3 Guide&#x27;</span>)])<br><span class="hljs-comment">// 这里需要 .value</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(books[<span class="hljs-number">0</span>].<span class="hljs-property">value</span>)<br><br><span class="hljs-keyword">const</span> map = <span class="hljs-title function_">reactive</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([[<span class="hljs-string">&#x27;count&#x27;</span>, <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)]]))<br><span class="hljs-comment">// 这里需要 .value</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;count&#x27;</span>).<span class="hljs-property">value</span>)<br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>一定要注意解包！看下面！</p>          </div><p>请注意，仅当ref是模板渲染上下文的顶层属性时才适用自动“解包”。例如，<code>foo</code>是顶层属性，但<code>object.foo</code>不是。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> object = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-title function_">ref</span>(<span class="hljs-number">1</span>) &#125;<br>&#123;&#123; object.<span class="hljs-property">foo</span> + <span class="hljs-number">1</span> &#125;&#125;  <span class="hljs-comment">// 行不通！</span><br>&#123;&#123; object.<span class="hljs-property">foo</span>.<span class="hljs-property">value</span> + <span class="hljs-number">1</span> &#125;&#125;  <span class="hljs-comment">// 但是可以手动解包</span><br>&#123;&#123; object.<span class="hljs-property">foo</span> &#125;&#125;  <span class="hljs-comment">// 语法糖</span><br><br><span class="hljs-keyword">const</span> &#123; foo &#125; = object<br>&#123;&#123; foo + <span class="hljs-number">1</span> &#125;&#125;  <span class="hljs-comment">// 正确的！</span><br></code></pre></td></tr></table></figure><h1>不同点</h1><p><code>reactive()</code>容易丢失响应式链接，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> state = <span class="hljs-title function_">reactive</span>(&#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;)<br><span class="hljs-keyword">let</span> n = state.<span class="hljs-property">count</span><br><span class="hljs-comment">// 不影响原始的state，n在怎么自增state.count都是0</span><br>n++<br></code></pre></td></tr></table></figure><p>但是<code>ref()</code>就不是了，把上边的换成ref的话<code>count</code>是会跟着<code>n</code>一起变的。<br>以及传入函数中，也会丢失<code>reactive()</code>响应性，但是<code>ref()</code>不会：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> state = <span class="hljs-title function_">reactive</span>(&#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;)<br><span class="hljs-comment">// 该函数接收一个普通数字，并且</span><br><span class="hljs-comment">// 将无法跟踪 state.count 的变化</span><br><span class="hljs-title function_">callSomeFunction</span>(state.<span class="hljs-property">count</span>)<br><br><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">foo</span>: <span class="hljs-title function_">ref</span>(<span class="hljs-number">1</span>),<br>  <span class="hljs-attr">bar</span>: <span class="hljs-title function_">ref</span>(<span class="hljs-number">2</span>)<br>&#125;<br><span class="hljs-comment">// 该函数接收一个 ref</span><br><span class="hljs-comment">// 需要通过 .value 取值</span><br><span class="hljs-comment">// 但它会保持响应性</span><br><span class="hljs-title function_">callSomeFunction</span>(obj.<span class="hljs-property">foo</span>)<br></code></pre></td></tr></table></figure><p>在上面的例子中，如果函数中用到传入的值的话，<code>state.count</code>一直是0，无论它之后是否变化。而<code>obj.foo</code>传进去的是响应式对象，利用<code>.value</code>就能跟踪状态取最新值。</p><hr>]]></content>
    
    
    <categories>
      
      <category>Learning Log</category>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣-808. 分汤</title>
    <link href="/2022/11/21/leetcode-808/"/>
    <url>/2022/11/21/leetcode-808/</url>
    
    <content type="html"><![CDATA[<h1>题目描述</h1><p><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_808_1.png" alt="808"></p><h1>思路及实现</h1><p>其实这题我一开始根本没想什么动态规划，就想着无脑递归不就行了吗？但是递归存在两个问题：一是超出时间限制，二是超出递归深度。<br>第一个我们可以利用缓存技术大大压缩时间，但是第二个就必须想其他办法解决了，因为题目给的是<code>0 &lt;= n &lt;= 10^9​​​​​​​</code>，但是仔细观察到题目说返回值在正确答案<code>10^-5</code>的范围内将被认为是正确的，<br>什么意思呢？就是如果结果<code>&gt; 0.99999</code>那么就是返回<code>1.0</code>。按照题目的分配方法，虽然每个分配方法都是<code>0.25</code>几率，但是肯定是 A 平均分得更多的，也就是说我们能够找到一个<code>θ</code>，使得当<code>n &gt;= θ</code>时，有<code>ans &gt; 0.99999</code>。</p><h2 id="动态规划">动态规划</h2><p>要找到这个整数，就要使用动态规划来求解了。首先先压缩一下题目给的数据，因为分配方法都是<code>25</code>的倍数，所以可以用<code>(n + 24) // 25</code>来压缩，相应的分配方法变成：(4, 0), (3, 1), (2, 2), (1, 3)。<br>然后就是找到思路：<br><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_808_2.png" alt="动态规划解法"><br>接着写出程序即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">soupServings</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">float</span>:<br>        n = (n + <span class="hljs-number">24</span>) // <span class="hljs-number">25</span><br>        <span class="hljs-keyword">if</span> n &gt;= <span class="hljs-number">179</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span><br>        dp = [[<span class="hljs-number">0.0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>)] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>)]<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0.5</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>            dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1.0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>                dp[i][j] = (dp[<span class="hljs-built_in">max</span>(i - <span class="hljs-number">4</span>, <span class="hljs-number">0</span>)][j] + dp[<span class="hljs-built_in">max</span>(i - <span class="hljs-number">3</span>, <span class="hljs-number">0</span>)][j - <span class="hljs-number">1</span>]<br>                            + dp[<span class="hljs-built_in">max</span>(i - <span class="hljs-number">2</span>, <span class="hljs-number">0</span>)][<span class="hljs-built_in">max</span>(j - <span class="hljs-number">2</span>, <span class="hljs-number">0</span>)] + dp[i - <span class="hljs-number">1</span>][<span class="hljs-built_in">max</span>(j - <span class="hljs-number">3</span>, <span class="hljs-number">0</span>)]) / <span class="hljs-number">4</span><br>        <span class="hljs-keyword">return</span> dp[n][n]<br></code></pre></td></tr></table></figure><h2 id="深度优先搜索-缓存技术（记忆化搜索）">深度优先搜索 + 缓存技术（记忆化搜索）</h2><p>只要我们写出了动态规划写法，就能通过它找到<code>θ</code>了，写一段代码让<code>n</code>从<code>0</code>开始遍历到<code>5000</code>或者差不多的数就好了，然后设置个条件，返回的结果<code>&gt; 0.99999</code>的时候就输出这个数就好了。然后就得到了<code>4451</code>这个答案。<br>那就好办了，那我直接进行递归并利用缓存技术顺便让<code>n &gt; 4450</code>的时候直接返回<code>1.0</code>即可！<br>OK，过了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">soupServings</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">float</span>:<br>        <span class="hljs-keyword">if</span> n &gt; <span class="hljs-number">4450</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span><br><span class="hljs-meta">        @cache</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">recursion</span>(<span class="hljs-params">a_soup: <span class="hljs-built_in">int</span>, b_soup: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">float</span>:<br>            <span class="hljs-keyword">if</span> a_soup &lt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> b_soup &lt;= <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0.5</span><br>            <span class="hljs-keyword">elif</span> a_soup &lt;= <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span><br>            <span class="hljs-keyword">elif</span> b_soup &lt;= <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0.0</span><br>            <span class="hljs-keyword">return</span> (recursion(a_soup - <span class="hljs-number">100</span>, b_soup) + recursion(a_soup - <span class="hljs-number">75</span>, b_soup - <span class="hljs-number">25</span>)<br>                    + recursion(a_soup - <span class="hljs-number">50</span>, b_soup - <span class="hljs-number">50</span>) + recursion(a_soup - <span class="hljs-number">25</span>, b_soup - <span class="hljs-number">75</span>)) / <span class="hljs-number">4</span><br>        <span class="hljs-keyword">return</span> recursion(n, n)<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>Solution</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Leetcode</tag>
      
      <tag>动态规划</tag>
      
      <tag>深度优先搜索</tag>
      
      <tag>递归</tag>
      
      <tag>记忆化搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣-1710. 卡车上的最大单元数 &amp; 1732. 找到最高海拔</title>
    <link href="/2022/11/20/leetcode-1710-1732/"/>
    <url>/2022/11/20/leetcode-1710-1732/</url>
    
    <content type="html"><![CDATA[<h1>题目描述</h1><p><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_1710_1.png" alt="1710"><br><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_1732_1.png" alt="1732"></p><h1>思路及实现</h1><h2 id="1710-卡车上的最大单元数">1710. 卡车上的最大单元数</h2><p>首先要分清<strong>装载单元</strong>和<strong>装载数量</strong>，前者是<strong>箱子的容量</strong>，代表箱子可装载的<strong>单元数量</strong>，后者是卡车的容量，代表卡车可装载的<strong>箱子数量</strong>。<br>又由题目可以知道，每个类型箱子都有一定的数量和可装载单元数，对于每个箱子，重量是一致的（也就是说装载单元多并不会额外占用箱子数量），所以如果要找到卡车可以装载单元的最大总数，肯定是优先把<strong>装载单元数最大</strong>的箱子装上卡车。<br>为了降低时间复杂度，先对<code>boxTypes</code>进行排序，排序的依据就是<code>boxTypes[i][1]</code>，也就是箱子的容量，当然为了方便应该按照降序排列（即从大到小），排完序后边遍历边向卡车装箱子即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maximumUnits</span>(<span class="hljs-params">self, boxTypes: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], truckSize: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        max_unit = <span class="hljs-number">0</span><br>        boxTypes.sort(key=<span class="hljs-keyword">lambda</span> i: i[<span class="hljs-number">1</span>], reverse=<span class="hljs-literal">True</span>)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> boxTypes:<br>            <span class="hljs-keyword">if</span> i[<span class="hljs-number">0</span>] &gt; truckSize:  <span class="hljs-comment"># 不能把当前这种类型的箱子全部装上去，那就把剩下的箱子容量装满开车走人</span><br>                max_unit += truckSize * i[<span class="hljs-number">1</span>]<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 能装下全部当前这种类型的箱子，装好后记得更新卡车剩余可装载箱子数</span><br>                max_unit += i[<span class="hljs-number">0</span>] * i[<span class="hljs-number">1</span>]<br>                truckSize -= i[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">return</span> max_unit<br></code></pre></td></tr></table></figure><h2 id="1732-找到最高海拔">1732. 找到最高海拔</h2><p>其实一开始不是很看得懂题目想表达什么，看了一下示例就懂了，就是我们有<code>altitude</code>（海拔）列表，和<code>gain</code>（海拔差）列表，对于每个点的海拔，有<code>altitude[i + 1] = altitude[i] + gain[i]</code>，就这样，照着写就行了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">largestAltitude</span>(<span class="hljs-params">self, gain: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        altitude = [<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> i, n <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(gain):<br>            altitude.append(altitude[i] + n)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(altitude)<br></code></pre></td></tr></table></figure><p>当然可以进行优化，毕竟我们只需要前一海拔就能算出当前海拔，所以一个维护<code>fore_altitude</code>和<code>max_altitude</code>两个变量就可以了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">largestAltitude</span>(<span class="hljs-params">self, gain: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        fore_altitude = <span class="hljs-number">0</span><br>        max_altitude = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(gain)):<br>            max_altitude = <span class="hljs-built_in">max</span>(max_altitude, fore_altitude + gain[i])<br>            fore_altitude = fore_altitude + gain[i]<br>        <span class="hljs-keyword">return</span> max_altitude<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>Solution</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Leetcode</tag>
      
      <tag>贪心</tag>
      
      <tag>数组</tag>
      
      <tag>排序</tag>
      
      <tag>前缀和</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣-799. 香槟塔</title>
    <link href="/2022/11/20/leetcode-799/"/>
    <url>/2022/11/20/leetcode-799/</url>
    
    <content type="html"><![CDATA[<h1>题目描述</h1><p><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_799_1.png" alt="799"></p><h1>思路及实现</h1><p>OK看到这种题目首先我的思路就是找规律，先把每层数字列一下先：<br><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_799_2.png" alt="找规律！"><br>以及在倒入香槟的时候千万别把自己套进去了，我就是把自己套进去想着香槟一瓶一瓶倒下去再分配，结果压根没想到怎么做，其实一次性倒在最上边的杯子上，溢出了就往下分，效果是一样的。<br>现在已经找到规律了，那么跟着规律走就容易出思路了。看到左边的图，可以发现我写出了两种下标，其实也可以说对应两种方法。</p><h2 id="直接计算法">直接计算法</h2><p><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_799_3.png" alt="直接计算法的思路"></p><div class="note note-warning">            <p>OK那么这里我想说的是，我在画这张图的时候还没发现他是从<code>0</code>开始计数的，所以在写代码的时候<code>row</code>变成了从<code>0</code>开始而不是<code>1</code>，所以后续手动补上<code>+1</code>，也因为这个原因代码看上去可能比较乱，比较难读，果咩那塞！</p>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">champagneTower</span>(<span class="hljs-params">self, poured: <span class="hljs-built_in">int</span>, query_row: <span class="hljs-built_in">int</span>, query_glass: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">float</span>:<br>        glass_num = (<span class="hljs-number">1</span> + query_row + <span class="hljs-number">1</span>) * (query_row + <span class="hljs-number">1</span>) // <span class="hljs-number">2</span><br>        v = [<span class="hljs-number">0</span>] * glass_num<br>        v[<span class="hljs-number">0</span>] = poured<br>        i = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(query_row):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(row + <span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> v[i] &gt; <span class="hljs-number">1</span>:<br>                    v[i + row + <span class="hljs-number">1</span>] += (v[i] - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span><br>                    v[i + row + <span class="hljs-number">2</span>] += (v[i] - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span><br>                i += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(v[-(query_row - query_glass + <span class="hljs-number">1</span>)], <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h2 id="计算每行法">计算每行法</h2><p><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_799_4.png" alt="计算每行法的思路"><br>可以看到啊，其实这就是官解的思路和代码，非常简洁明了且快速。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">champagneTower</span>(<span class="hljs-params">self, poured: <span class="hljs-built_in">int</span>, query_row: <span class="hljs-built_in">int</span>, query_glass: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">float</span>:<br>        v = [poured]<br>        <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, query_row + <span class="hljs-number">1</span>):<br>            next_v = [<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(v)):<br>                <span class="hljs-keyword">if</span> v[i] &gt; <span class="hljs-number">1</span>:<br>                    next_v[i] += (v[i] - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span><br>                    next_v[i + <span class="hljs-number">1</span>] += (v[i] - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span><br>            v = next_v<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(<span class="hljs-number">1</span>, v[query_glass])<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>Solution</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Leetcode</tag>
      
      <tag>动态规划</tag>
      
      <tag>模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安卓期末赶工CV作业的底部导航栏模板</title>
    <link href="/2022/11/16/android-homework/"/>
    <url>/2022/11/16/android-homework/</url>
    
    <content type="html"><![CDATA[<h1>想说的话</h1><p>不适合小白看，小白看可能会产生许多疑问。文章内容可能抽象，毕竟写给自己看的。</p><h1>正文</h1><h2 id="底部导航栏！">底部导航栏！</h2><p>先来看看界面设计。<br>首先是实现底部导航栏，非常简单，左上角<code>File -&gt; New -&gt; New Project -&gt; Bottom Navigation Activity</code>，然后就自动为你创建好了一个现成的底部导航栏，在上面稍微做点改动即可拿来吧你！<br>效果图：<br><img src="http://imagehost.map1e-g.cn/android-homework/Bottom_Nav_Result" alt="底部导航栏实现"><br>那具体怎么改动？先看到<code>res</code>里边的<code>layout</code>，<code>Fragment</code>布局文件全部右键<code>Refactor -&gt; Rename</code>，就是改名，以我的导航栏为例：<code>fragment_home -&gt; fragment_memo</code>。<br>然后看到工程文件里边的<code>ui</code>文件夹，里边分别存了三个界面的<code>Fragment</code>，只留下三个<code>Fragment</code>，<code>ViewModel</code>全删了，然后再把<code>Fragment</code>里边改成下边这样子。（图方便）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MemoFragment</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Fragment</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> View <span class="hljs-title function_">onCreateView</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> LayoutInflater inflater,</span><br><span class="hljs-params">                             ViewGroup container, Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-keyword">return</span> inflater.inflate(R.layout.fragment_memo, container, <span class="hljs-literal">false</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着去<code>res/navigation/mobile_navigation.xml</code>里进行改动，还是以下面代码为例。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">fragment</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/navigation_memo&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.example.bottonnavdemo.ui.memo.MemoFragment&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:label</span>=<span class="hljs-string">&quot;@string/title_memo&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">tools:layout</span>=<span class="hljs-string">&quot;@layout/fragment_memo&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>可以看到上面四项其实就是把全部<code>home</code>改为了<code>memo</code>，<code>Home</code>改为了<code>Memo</code>。<br>最后一步，改<code>res/menu/bottom_nav_menu.xml</code>，看代码。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">item</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/navigation_memo&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:icon</span>=<span class="hljs-string">&quot;@drawable/ic_memo_24&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:title</span>=<span class="hljs-string">&quot;@string/title_memo&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>同样是把全部<code>home</code>改为了<code>memo</code>。但是这里的图标文件要怎么获得呢？有两种方式：</p><ol><li>上网找一个合适的，然后copy进去<code>res/drawble</code>即可引用</li><li><code>drawble</code>文件夹右键，<code>New -&gt; Vector Asset</code>创建一个<br>我是用的方法二，挺方便的。</li></ol><div class="note note-warning">            <p>可能<code>MainActivity</code>要改一下，具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">AppBarConfiguration</span> <span class="hljs-variable">appBarConfiguration</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AppBarConfiguration</span>.Builder(<br>                R.id.navigation_memo, R.id.navigation_music, R.id.navigation_setting)<br>                .build();<br></code></pre></td></tr></table></figure><p>就是里面的资源<code>R.id.xxx</code>要改成自己修改过后的而不是一开始它提供的。</p>          </div><div class="note note-warning">            <p>梅开二度！如果你已经创建好了一个<code>Fragment</code>并满怀期待地展示出来，打开应用，切换到对于界面，你可能会发现最底部的内容被导航栏挡住了！<br>对此，去<code>activity_main</code>里面找到<code>&lt;fragment&gt;</code>元素里面的<code>android:layout_height</code>属性，修改为<code>0dp</code>即可！即：<code>android:layout_height=&quot;0dp&quot;</code></p>          </div><hr>]]></content>
    
    
    <categories>
      
      <category>Essay</category>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣-864. 获取所有钥匙的最短路径</title>
    <link href="/2022/11/12/leetcode-864/"/>
    <url>/2022/11/12/leetcode-864/</url>
    
    <content type="html"><![CDATA[<h1>题目描述</h1><p><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_864_1.png" alt="864_1"><br><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_864_2.png" alt="864_2"></p><h1>思路及实现</h1><p>好多课设好忙先欠着（目移</p><hr>]]></content>
    
    
    <categories>
      
      <category>Solution</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Leetcode</tag>
      
      <tag>广度优先搜索</tag>
      
      <tag>状态压缩</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣-790. 多米诺和托米诺平铺</title>
    <link href="/2022/11/12/leetcode-790/"/>
    <url>/2022/11/12/leetcode-790/</url>
    
    <content type="html"><![CDATA[<h1>题目描述</h1><p><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_790_1.png" alt="790"></p><h1>思路及实现</h1><h2 id="找规律">找规律</h2><p>这种题吧，实际上就是画图找规律，跟求斐波那契数列没什么区别，把规律找出来想递归就递归想迭代就迭代。<br>那么重点就在于找规律了。从<code>n=1</code>开始，一直到<code>n=5</code>就差不多了，然后就会发现下面的式子：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><mn>1</mn><mspace linebreak="newline"></mspace><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>2</mn><mo stretchy="false">]</mo><mo>=</mo><mn>2</mn><mspace linebreak="newline"></mspace><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>3</mn><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>2</mn><mo stretchy="false">]</mo><mo>+</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mn>2</mn><mspace linebreak="newline"></mspace><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>4</mn><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>3</mn><mo stretchy="false">]</mo><mo>+</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>2</mn><mo stretchy="false">]</mo><mo>+</mo><mn>2</mn><mo>∗</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mn>2</mn><mo>=</mo><mn>2</mn><mo>∗</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>3</mn><mo stretchy="false">]</mo><mo>+</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mspace linebreak="newline"></mspace><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>5</mn><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>4</mn><mo stretchy="false">]</mo><mo>+</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>3</mn><mo stretchy="false">]</mo><mo>+</mo><mn>2</mn><mo>∗</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>2</mn><mo stretchy="false">]</mo><mo>+</mo><mn>2</mn><mo>∗</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mn>2</mn><mo>=</mo><mn>2</mn><mo>∗</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>4</mn><mo stretchy="false">]</mo><mo>+</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>2</mn><mo stretchy="false">]</mo><mspace linebreak="newline"></mspace><mo>⋅</mo><mo>⋅</mo><mo>⋅</mo><mspace linebreak="newline"></mspace><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo>=</mo><mn>2</mn><mo>∗</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>3</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>n</mi><mo>≥</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">dp[1] = 1 \\dp[2] = 2 \\dp[3] = dp[2] + dp[1] + 2 \\dp[4] = dp[3] + dp[2] + 2 * dp[1] + 2 = 2 * dp[3] + dp[1] \\dp[5] = dp[4] + dp[3] + 2 * dp[2] + 2 * dp[1] + 2 = 2 * dp[4] + dp[2] \\\cdot\cdot\cdot \\dp[n] = 2 * dp[n - 1] + dp[n - 3],n \geq 4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord">3</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord">4</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord">3</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord">3</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord">5</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord">4</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord">3</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord">4</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord">⋅</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span></span></span></span></span></p><p>规律找到了直接编程即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">numTilings</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        mod = <span class="hljs-number">10</span> ** <span class="hljs-number">9</span> + <span class="hljs-number">7</span><br><br><span class="hljs-meta">        @lru_cache()</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">recursion</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>            <span class="hljs-keyword">if</span> n == <span class="hljs-number">3</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">5</span><br>            <span class="hljs-keyword">elif</span> n == <span class="hljs-number">2</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>            <span class="hljs-keyword">elif</span> n == <span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> (<span class="hljs-number">2</span> * recursion(n - <span class="hljs-number">1</span>) + recursion(n - <span class="hljs-number">3</span>)) % mod<br><br>        <span class="hljs-keyword">return</span> recursion(n)<br></code></pre></td></tr></table></figure><p>不要忘记这种递归加上<code>@lru_cache</code>装饰器，一是大量节省时间，二是防止超时（因为不加真的超了）。<br>下面是迭代法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">numTilings</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        mod = <span class="hljs-number">10</span> ** <span class="hljs-number">9</span> + <span class="hljs-number">7</span><br>        i = <span class="hljs-number">4</span><br>        dp = <span class="hljs-built_in">list</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>])<br>        <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">3</span>:<br>            <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">while</span> i &lt;= n:<br>            dp.append((<span class="hljs-number">2</span> * dp[i - <span class="hljs-number">1</span> - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">3</span> - <span class="hljs-number">1</span>]) % mod)<br>            i += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h2 id="动态规划">动态规划</h2><p>正经dp不会，看官解。(逃</p><hr>]]></content>
    
    
    <categories>
      
      <category>Solution</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Leetcode</tag>
      
      <tag>动态规划</tag>
      
      <tag>找规律</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣-1704. 判断字符串的两半是否相似</title>
    <link href="/2022/11/11/leetcode-1704/"/>
    <url>/2022/11/11/leetcode-1704/</url>
    
    <content type="html"><![CDATA[<h1>题目描述</h1><p><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_1704_1.png" alt="1704"></p><h1>思路及实现</h1><p>首先跟着题目走，把字符串分为长度相同的两部分<code>part1</code>和<code>part2</code>，然后再去找两部分这里边的元音数量。<br>为了匹配元音，可以用多种数据结构存储这个元音列表，这里我用到了集合<code>set</code>。<br>必要的东西都齐了，开始遍历就好了，如果当前字符在元音集合<code>vowels</code>中，那这部分的计数就加一，最后比较并返回结果即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">halvesAreAlike</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        vowels = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;a&#x27;</span><span class="hljs-string">&#x27;e&#x27;</span><span class="hljs-string">&#x27;i&#x27;</span><span class="hljs-string">&#x27;o&#x27;</span><span class="hljs-string">&#x27;u&#x27;</span><span class="hljs-string">&#x27;A&#x27;</span><span class="hljs-string">&#x27;E&#x27;</span><span class="hljs-string">&#x27;I&#x27;</span><span class="hljs-string">&#x27;O&#x27;</span><span class="hljs-string">&#x27;U&#x27;</span>)<br>        part1 = s[:<span class="hljs-built_in">len</span>(s) // <span class="hljs-number">2</span>]<br>        cnt1 = <span class="hljs-number">0</span><br>        part2 = s[<span class="hljs-built_in">len</span>(s) // <span class="hljs-number">2</span>:]<br>        cnt2 = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s) // <span class="hljs-number">2</span>):<br>            <span class="hljs-keyword">if</span> part1[i] <span class="hljs-keyword">in</span> vowels:<br>                cnt1 += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> part2[i] <span class="hljs-keyword">in</span> vowels:<br>                cnt2 += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span> <span class="hljs-keyword">if</span> cnt1 == cnt2 <span class="hljs-keyword">else</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>同样的，会用Java写一写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">halvesAreAlike</span><span class="hljs-params">(String s)</span> &#123;<br>        Set&lt;Character&gt; vowels = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;Character&gt;();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;aeiouAEIOU&quot;</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">half</span> <span class="hljs-operator">=</span> s.length() / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, cnt2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; str.length(); i++) &#123;<br>            vowels.add(str.charAt(i));<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length() / <span class="hljs-number">2</span>; i++)&#123;<br>            <span class="hljs-keyword">if</span> (vowels.contains(s.charAt(i)))&#123;<br>                cnt1++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (vowels.contains(s.charAt(half + i)))&#123;<br>                cnt2++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">return</span> <span class="hljs-variable">cnt1</span> <span class="hljs-operator">=</span>= cnt2;<br>    &#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Leetcode</tag>
      
      <tag>字符串</tag>
      
      <tag>[object Object]</tag>
      
      <tag>Solution</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣-764. 最大加号标志</title>
    <link href="/2022/11/09/leetcode-764/"/>
    <url>/2022/11/09/leetcode-764/</url>
    
    <content type="html"><![CDATA[<h1>题目描述</h1><p><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_764_1.png" alt="764_1"><br><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_764_1_2.png" alt="764_2"></p><h1>思路及实现</h1><p>好的我们来写今天的每日一题，这什么啊？哦，找上下左右是不是<code>1</code>啊，简单，暴力遍历，其他我也不会（开摆！）</p><h2 id="暴力遍历！">暴力遍历！</h2><div class="note note-warning">            <p>在写这题之前，有个小提醒，题目所说的加号标志，最小其实是<code>1</code>而不是<code>2</code>，就算只有一个格子是<code>1</code>，这个单独的格子也算加号。</p>          </div><p>首先通过题目给出的<code>n</code>构造一个<code>n * n</code>的矩阵，并将每个格子的初值赋为<code>1</code>，然后遍历题目给的<code>mines</code>数组，把矩阵中对应坐标的值改为<code>0</code>。<br>接下来就开始遍历矩阵了。对于每一个格子，从<code>0</code>阶开始向外扩大，每次扩大，都要判断两个条件：</p><ol><li>是否越界？</li><li>是否存在格子中的值为0？<br>如果通过了上边两个条件测试，说明找到一个符合题目所说的“轴对称”加号标志，重复此过程，直到不满足条件。<br>不满足条件说明这个格子的最大“轴对称”加号标志已经找到，取返回结果<code>ans</code>和当前格子结果<code>cnt</code>二者中的最大值，然后就可以看下一个格子了。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">orderOfLargestPlusSign</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, mines: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        matrix = [[<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]  <span class="hljs-comment"># 构造矩阵</span><br>        <span class="hljs-keyword">for</span> mine <span class="hljs-keyword">in</span> mines:<br>            matrix[mine[<span class="hljs-number">0</span>]][mine[<span class="hljs-number">1</span>]] = <span class="hljs-number">0</span>  <span class="hljs-comment"># 初始化0</span><br>        ans = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                cnt = <span class="hljs-number">0</span><br>                <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>                    <span class="hljs-keyword">if</span> i - cnt &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> j - cnt &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> i + cnt &gt; n - <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> j + cnt &gt; n - <span class="hljs-number">1</span>:  <span class="hljs-comment"># 越界</span><br>                        <span class="hljs-keyword">break</span><br>                    <span class="hljs-keyword">elif</span> matrix[i - cnt][j] == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> matrix[i][j + cnt] == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> matrix[i + cnt][j] == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> \<br>                            matrix[i][j - cnt] == <span class="hljs-number">0</span>:  <span class="hljs-comment"># 存在0</span><br>                        <span class="hljs-keyword">break</span><br>                    <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 满足“轴对称”加号标志</span><br>                        cnt += <span class="hljs-number">1</span><br>                ans = cnt <span class="hljs-keyword">if</span> cnt &gt; ans <span class="hljs-keyword">else</span> ans<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><p>笑死，python直接超时了，这怎么办，换个java试试呗。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">orderOfLargestPlusSign</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] mines)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[][] matrix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] mine : mines) &#123;<br>            matrix[mine[<span class="hljs-number">0</span>]][mine[<span class="hljs-number">1</span>]] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (i - cnt &lt; <span class="hljs-number">0</span> || j - cnt &lt; <span class="hljs-number">0</span> || i + cnt &gt; n - <span class="hljs-number">1</span> || j + cnt &gt; n - <span class="hljs-number">1</span>) &#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (matrix[i - cnt][j] == <span class="hljs-number">1</span> || matrix[i][j + cnt] == <span class="hljs-number">1</span> || matrix[i + cnt][j] == <span class="hljs-number">1</span> || matrix[i][j - cnt] == <span class="hljs-number">1</span>) &#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> &#123;<br>                        cnt += <span class="hljs-number">1</span>;<br>                    &#125;<br>                &#125;<br>                ans = Math.max(cnt, ans);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>java就不超时，什么力扣亲儿子，这就转型！</p><h2 id="动态规划">动态规划</h2><p>对一个坐标<code>(i, j)</code>，如何去找它的最大“轴对称”加号标志呢？<br>通过题目可以知道，找出<code>(i, j)</code>沿上下左右方向能走的距离，然后取它们当中的最小值，就是<code>(i ,j)</code>所拥有的<code>k</code>阶“轴对称”加号标志。<br>根据这个规则，构造出动态规划数组，即：<br><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_764_2.png" alt="764_dp_1"><br><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_764_3.png" alt="764_dp_2"><br>因为有四个方向，所以需要四个数组，分别代表对应坐标上下左右能到达的最大距离。<br>然后根据所写式子编写程序即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">orderOfLargestPlusSign</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, mines: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        matrix = [[<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]  <span class="hljs-comment"># 构造矩阵</span><br>        <span class="hljs-keyword">for</span> mine <span class="hljs-keyword">in</span> mines:<br>            matrix[mine[<span class="hljs-number">0</span>]][mine[<span class="hljs-number">1</span>]] = <span class="hljs-number">0</span><br>        left = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        right = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        up = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        down = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-comment"># 先把最外边一圈都初始化为1</span><br>            <span class="hljs-keyword">if</span> matrix[i][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>:  <span class="hljs-comment"># 第一列</span><br>                left[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> matrix[i][n - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span>:  <span class="hljs-comment"># 最后一列</span><br>                right[i][n - <span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> matrix[<span class="hljs-number">0</span>][i] == <span class="hljs-number">1</span>:  <span class="hljs-comment"># 第一行</span><br>                up[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> matrix[n - <span class="hljs-number">1</span>][i] == <span class="hljs-number">1</span>:  <span class="hljs-comment"># 最后一行</span><br>                down[n - <span class="hljs-number">1</span>][i] = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):  <span class="hljs-comment"># 开始计算每个坐标的“轴对称”加号标志，顺序为左右上下</span><br>                <span class="hljs-keyword">if</span> matrix[i][j] == <span class="hljs-number">1</span>:  <span class="hljs-comment"># 第i行从左往右计算每个坐标的left中的值</span><br>                    left[i][j] = left[i][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> matrix[i][n - <span class="hljs-number">1</span> - j] == <span class="hljs-number">1</span>:  <span class="hljs-comment"># 第i行从右往左计算每个坐标的right中的值</span><br>                    right[i][n - <span class="hljs-number">1</span> - j] = right[i][n - j] + <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> matrix[j][i] == <span class="hljs-number">1</span>:  <span class="hljs-comment"># 第i行从上往下计算每个坐标的up中的值</span><br>                    up[j][i] = up[j - <span class="hljs-number">1</span>][i] + <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> matrix[n - <span class="hljs-number">1</span> - j][i] == <span class="hljs-number">1</span>:  <span class="hljs-comment"># 第i行从下往上计算每个坐标的down中的值</span><br>                    down[n - <span class="hljs-number">1</span> - j][i] = down[n - j][i] + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">min</span>(left[i][j], right[i][j], up[i][j], down[i][j])<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n))<br></code></pre></td></tr></table></figure><p>再多写个Java熟悉熟悉（对了，java初始化数组中的int的数值默认就是0，所以索性直接把1和0反过来判断，省得麻烦）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span>[][] matrix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] mine : mines) &#123;<br>    matrix[mine[<span class="hljs-number">0</span>]][mine[<span class="hljs-number">1</span>]] = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-type">int</span>[][] left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br><span class="hljs-type">int</span>[][] right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br><span class="hljs-type">int</span>[][] up = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br><span class="hljs-type">int</span>[][] down = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-keyword">if</span>(matrix[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>)<br>        left[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(matrix[i][n - <span class="hljs-number">1</span>] == <span class="hljs-number">0</span>)<br>        right[i][n - <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(matrix[<span class="hljs-number">0</span>][i] == <span class="hljs-number">0</span>)<br>        up[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(matrix[n - <span class="hljs-number">1</span>][i] == <span class="hljs-number">0</span>)<br>        down[n - <span class="hljs-number">1</span>][i] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>        <span class="hljs-keyword">if</span>(matrix[i][j] == <span class="hljs-number">0</span>)<br>            left[i][j] = left[i][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(matrix[i][n - <span class="hljs-number">1</span> - j] == <span class="hljs-number">0</span>)<br>            right[i][n - <span class="hljs-number">1</span> - j] = right[i][n - j] + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(matrix[j][i] == <span class="hljs-number">0</span>)<br>            up[j][i] = up[j - <span class="hljs-number">1</span>][i] + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(matrix[n - <span class="hljs-number">1</span> - j][i] == <span class="hljs-number">0</span>)<br>            down[n - <span class="hljs-number">1</span> - j][i] = down[n - j][i] + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>        ans = Math.max(ans,Math.min(left[i][j], Math.min(right[i][j], Math.min(up[i][j], down[i][j]))));<br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Leetcode</tag>
      
      <tag>动态规划</tag>
      
      <tag>[object Object]</tag>
      
      <tag>Solution</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣-1684. 统计一致字符串的数目</title>
    <link href="/2022/11/08/leetcode-1684/"/>
    <url>/2022/11/08/leetcode-1684/</url>
    
    <content type="html"><![CDATA[<h1>题目描述</h1><p><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_1684_1.png" alt="1684"></p><h1>思路及实现</h1><p>既然是要让我们判断<code>words</code>中的每个<code>word</code>中的每个字母有没有在<code>allowed</code>中出现（存在），那就是要涉及到遍历<code>word</code>的同时遍历<code>allowed</code>，<br>那倒不如先用一个哈希表把<code>allowed</code>中的每个字母都存进去，因为<code>allowed</code>中的字母是不会重复的，而且这样可以把遍历变成检索，减小时间复杂度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">countConsistentStrings</span>(<span class="hljs-params">self, allowed: <span class="hljs-built_in">str</span>, words: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        alpha_dict = &#123;&#125;<br>        ans = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> alpha <span class="hljs-keyword">in</span> allowed:  <span class="hljs-comment"># 用个字典保存 allowed 中的字符，之后检索就能加快</span><br>            alpha_dict[alpha] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> words:<br>            <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> word:<br>                <span class="hljs-keyword">if</span> a <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> alpha_dict:<br>                    ans -= <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">break</span><br>            ans += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><p>上面是第一个版本，最猪的一个，用字典存，您完全把集合忘掉了是吗（<br>下面是换成集合的，其实没差啦（</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">countConsistentStrings</span>(<span class="hljs-params">self, allowed: <span class="hljs-built_in">str</span>, words: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        alpha_set = <span class="hljs-built_in">set</span>(allowed)<br>        ans = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> words:<br>            <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> word:<br>                <span class="hljs-keyword">if</span> a <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> alpha_set:<br>                    ans -= <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">break</span><br>            ans += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><p>再甚就直接利用特性了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">countConsistentStrings</span>(<span class="hljs-params">self, allowed: <span class="hljs-built_in">str</span>, words: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        ans = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> words:<br>            <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> word:<br>                <span class="hljs-keyword">if</span> a <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> allowed:<br>                    ans -= <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">break</span><br>            ans += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><p>（看到个内存使用0.几的，一看代码直接是用的<code>issubset()</code>，这是什么呢？“<code>issubset()</code>方法用于判断集合的所有元素是否都包含在指定集合中，如果是则返回 True，否则返回 False。”，有学到，谢谢这位大佬</p><hr>]]></content>
    
    
    <categories>
      
      <category>Solution</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Leetcode</tag>
      
      <tag>字符串</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣-816. 模糊坐标</title>
    <link href="/2022/11/08/leetcode-816/"/>
    <url>/2022/11/08/leetcode-816/</url>
    
    <content type="html"><![CDATA[<h1>题目描述</h1><p><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_816_1.png" alt="816"></p><h1>思路及实现</h1><p>这题一开始我想到的就是，先确定逗号的位置，然后再找小数点的位置，也就是先枚举逗号，再枚举确定逗号之后两部分能组成的不同组合。<br>但是后面一直卡在如何确定小数点的位置上了，可能是因为数学差生的缘故（悲<br>所以就去看思路了，大致写了一下思路，然后隔天再根据思路把代码写出来。<br>下面贴一下自己大概整理的思路和代码：<br><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_816_2.png" alt="816"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">ambiguousCoordinates</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:<br>        result = []<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">spilt</span>(<span class="hljs-params">part: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:<br>            p_list = []<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(part) == <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> part[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;0&#x27;</span>:  <span class="hljs-comment"># 拿整数</span><br>                p_list.append(part)<br>            <span class="hljs-keyword">for</span> p_index <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(part)):  <span class="hljs-comment"># 确定小数点的位置</span><br>                <span class="hljs-keyword">if</span> p_index != <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> part[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-keyword">or</span> part[-<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;0&#x27;</span>:<br>                    <span class="hljs-keyword">continue</span><br>                p_list.append(part[:p_index] + <span class="hljs-string">&quot;.&quot;</span> + part[p_index:])<br>            <span class="hljs-keyword">return</span> p_list<br><br>        <span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(s) - <span class="hljs-number">2</span>):  <span class="hljs-comment"># 枚举逗号的位置</span><br>            part1 = s[<span class="hljs-number">1</span>: index + <span class="hljs-number">1</span>]  <span class="hljs-comment"># 确定逗号的位置后，字符串分为两部分，用来确定两部分中的字串</span><br>            part2 = s[index + <span class="hljs-number">1</span>: <span class="hljs-built_in">len</span>(s) - <span class="hljs-number">1</span>]<br>            part1_list = spilt(part1)  <span class="hljs-comment"># 第一部分能构成的字串</span><br>            part2_list = spilt(part2)  <span class="hljs-comment"># 第二部分能构成的子串</span><br>            <span class="hljs-keyword">for</span> p1 <span class="hljs-keyword">in</span> part1_list:<br>                <span class="hljs-keyword">for</span> p2 <span class="hljs-keyword">in</span> part2_list:<br>                    result.append(<span class="hljs-string">&quot;(&quot;</span> + p1 + <span class="hljs-string">&quot;, &quot;</span> + p2 + <span class="hljs-string">&quot;)&quot;</span>)  <span class="hljs-comment"># 两部分能构成的二维坐标</span><br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>Solution</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Leetcode</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣-1678. 设计 Goal 解析器</title>
    <link href="/2022/11/06/leetcode-1678/"/>
    <url>/2022/11/06/leetcode-1678/</url>
    
    <content type="html"><![CDATA[<h1>题目描述</h1><p><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_1678_1.png" alt="1678"></p><h1>思路和实现</h1><h2 id="直接调用函数">直接调用函数</h2><p>这题不偷懒那还是人吗？直接上<code>replace()</code>好吧！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">interpret</span>(<span class="hljs-params">self, command: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>        <span class="hljs-keyword">return</span> command.replace(<span class="hljs-string">&quot;()&quot;</span>, <span class="hljs-string">&quot;o&quot;</span>).replace(<span class="hljs-string">&quot;(al)&quot;</span>, <span class="hljs-string">&quot;al&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="正经遍历">正经遍历</h2><p>OK，偷懒偷完了还是要回归本心的，可以直接遍历，然后通过一些<code>if</code>判断怎么转换。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">interpret</span>(<span class="hljs-params">self, command: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>        str_len = <span class="hljs-built_in">len</span>(command)<br>        i = <span class="hljs-number">0</span><br>        result = <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-keyword">while</span> i &lt; str_len:<br>            <span class="hljs-keyword">if</span> command[i] == <span class="hljs-string">&#x27;G&#x27;</span>:  <span class="hljs-comment"># 遇到G，直接写到结果里</span><br>                result += <span class="hljs-string">&quot;G&quot;</span><br>                i += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> command[i] == <span class="hljs-string">&#x27;(&#x27;</span>:  <span class="hljs-comment"># 遇到左括号，看跟在后面的字符分情况讨论</span><br>                <span class="hljs-keyword">if</span> command[i + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;a&#x27;</span>:  <span class="hljs-comment"># 后边跟的是 a</span><br>                    result += <span class="hljs-string">&quot;al&quot;</span><br>                    i += <span class="hljs-number">4</span><br>                <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 后边跟的是 (</span><br>                    result += <span class="hljs-string">&quot;o&quot;</span><br>                    i += <span class="hljs-number">2</span><br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>Solution</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Leetcode</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣-1106. 解析布尔表达式</title>
    <link href="/2022/11/06/leetcode-1106/"/>
    <url>/2022/11/06/leetcode-1106/</url>
    
    <content type="html"><![CDATA[<h1>题目描述</h1><p><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_1106_1.png" alt="第一张图"></p><h1>思路和实现</h1><p>一眼用的计算中缀表达式的思路，直接用两个栈存运算符和布尔值了，不知道的话可以去了解一下。代码中也写出了较为详细的注释。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">parseBoolExpr</span>(<span class="hljs-params">self, expression: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        op_stack = []<br>        num_stack = []<br>        <span class="hljs-keyword">for</span> i, char <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(expression):<br>            <span class="hljs-keyword">if</span> char == <span class="hljs-string">&quot;,&quot;</span>:<br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">elif</span> char == <span class="hljs-string">&quot;|&quot;</span> <span class="hljs-keyword">or</span> char == <span class="hljs-string">&quot;&amp;&quot;</span> <span class="hljs-keyword">or</span> char == <span class="hljs-string">&quot;!&quot;</span>:  <span class="hljs-comment"># 运算符入栈</span><br>                op_stack.append(char)<br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">elif</span> char == <span class="hljs-string">&quot;)&quot;</span>:  <span class="hljs-comment"># 拿一个运算符和直到遇到左括号一直拿布尔值，然后计算</span><br>                op = op_stack.pop()<br>                num_list = []<br>                <span class="hljs-keyword">while</span> num_stack[-<span class="hljs-number">1</span>] != <span class="hljs-string">&quot;(&quot;</span>:<br>                    num_list.append(num_stack.pop())<br>                num_stack.pop()<br>                <span class="hljs-keyword">if</span> op == <span class="hljs-string">&quot;!&quot;</span>:  <span class="hljs-comment"># 非运算，布尔值取反再塞入运算数栈中</span><br>                    <span class="hljs-keyword">if</span> num_list[<span class="hljs-number">0</span>] == <span class="hljs-string">&quot;f&quot;</span>:<br>                        num_stack.append(<span class="hljs-string">&quot;t&quot;</span>)<br>                    <span class="hljs-keyword">else</span>:<br>                        num_stack.append(<span class="hljs-string">&quot;f&quot;</span>)<br>                <span class="hljs-keyword">elif</span> op == <span class="hljs-string">&quot;|&quot;</span>:  <span class="hljs-comment"># 或运算，只要有一个真值即为真</span><br>                    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;t&quot;</span> <span class="hljs-keyword">in</span> num_list:<br>                        num_stack.append(<span class="hljs-string">&quot;t&quot;</span>)<br>                    <span class="hljs-keyword">else</span>:<br>                        num_stack.append(<span class="hljs-string">&quot;f&quot;</span>)<br>                <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 与运算，只要有一个值不为真，结果就不为真</span><br>                    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;f&quot;</span> <span class="hljs-keyword">in</span> num_list:<br>                        num_stack.append(<span class="hljs-string">&quot;f&quot;</span>)<br>                    <span class="hljs-keyword">else</span>:<br>                        num_stack.append(<span class="hljs-string">&quot;t&quot;</span>)<br>            <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 其他符号入运算符栈</span><br>                num_stack.append(char)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span> <span class="hljs-keyword">if</span> num_stack[<span class="hljs-number">0</span>] == <span class="hljs-string">&quot;t&quot;</span> <span class="hljs-keyword">else</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>（这也能上困难题啊，那我希望困难都是这种难度）</p><hr>]]></content>
    
    
    <categories>
      
      <category>Solution</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Leetcode</tag>
      
      <tag>字符串</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣-1668. 最大重复子字符串</title>
    <link href="/2022/11/03/leetcode-1668/"/>
    <url>/2022/11/03/leetcode-1668/</url>
    
    <content type="html"><![CDATA[<h1>题目描述</h1><p><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_1668_1.png" alt="1668"></p><h1>思路和实现</h1><p>看到这种题，熟悉的感觉，哎呦，这不KMP吗？计算每个字符的特征向量用以确定匹配失败时的回溯位置，思路清晰。<br>问题是我不会写KMP。（早就忘光了.jpg）<br>那行，那就最简单粗暴的遍历吧。<br>最喜欢的一集（一种做法）.jpg</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxRepeating</span>(<span class="hljs-params">self, sequence: <span class="hljs-built_in">str</span>, word: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        result = repeat_time = i = flag = <span class="hljs-number">0</span><br>        word_len = <span class="hljs-built_in">len</span>(word)<br>        s_len = <span class="hljs-built_in">len</span>(sequence)<br>        sequence += <span class="hljs-string">&quot; &quot;</span> * word_len  <span class="hljs-comment"># 防止下标越界罢了</span><br>        <span class="hljs-keyword">while</span> i &lt; s_len:<br>            <span class="hljs-keyword">if</span> sequence[i] == word[<span class="hljs-number">0</span>]:  <span class="hljs-comment"># 如果当前字母和word首字母相同</span><br>                <span class="hljs-keyword">while</span> sequence[i: i + word_len] == word:<br>                    flag = <span class="hljs-number">1</span><br>                    i = i + word_len<br>                    repeat_time += <span class="hljs-number">1</span>  <span class="hljs-comment"># 重复次数+1</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> flag:<br>                    i += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    i = i - word_len + <span class="hljs-number">1</span><br>                    flag = <span class="hljs-number">0</span><br>                result = <span class="hljs-built_in">max</span>(result, repeat_time)<br>                repeat_time = <span class="hljs-number">0</span><br>                <span class="hljs-keyword">continue</span><br>            i += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><p>上面代码中，因为懒所以我直接用切片进行比较，搞得我还得用了一个<code>flag</code>变量辅助回溯，属于是空间（内存）杀手了。<br>（其实是可以用动态规划+KMP的但是我不会这太高级了呜呜）<br>（简单题就应该用简单写法才对(x)）</p><hr>]]></content>
    
    
    <categories>
      
      <category>Solution</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Leetcode</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣-1620. 网络信号最好的坐标</title>
    <link href="/2022/11/02/leetcode-1620/"/>
    <url>/2022/11/02/leetcode-1620/</url>
    
    <content type="html"><![CDATA[<h1>题目描述</h1><p><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_1620_1.png" alt="1620"></p><h1>思路和实现</h1><p>能有什么思路啊？思路就是审题，别跟我一样一开始还以为求哪个塔的信号强度最高就好了，真的服了。<br>哦对了，注意一下“如果一个坐标跟塔的距离在 radius 以内”这句话，这个以内是小于等于，哈哈，翻译拖出去枪毙，不会翻译可以直接写 dis &lt;= radius 好吗？<br>我想到的就是遍历求出每个点的信号强度，我还以为能有什么高手思路，结果是纯纯遍历题，就这还给了个中等，纯题目难读，不想多说了，就这样吧。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bestCoordinate</span>(<span class="hljs-params">self, towers: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], radius: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        max_x = <span class="hljs-built_in">max</span>(t[<span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> towers)<br>        max_y = <span class="hljs-built_in">max</span>(t[<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> towers)<br>        max_signal = ([<span class="hljs-number">0</span>, <span class="hljs-number">0</span>], <span class="hljs-number">0</span>)  <span class="hljs-comment"># 用元组保存最大信号强度坐标</span><br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(max_x + <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(max_y + <span class="hljs-number">1</span>):<br>                tmp_signal = <span class="hljs-number">0</span>  <span class="hljs-comment"># 保存当前塔得信号强度</span><br>                <span class="hljs-keyword">for</span> i2, t2 <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(towers):<br>                    <span class="hljs-keyword">if</span> x == t2[<span class="hljs-number">0</span>] <span class="hljs-keyword">and</span> y == t2[<span class="hljs-number">1</span>]:<br>                        tmp_signal += t2[<span class="hljs-number">2</span>]<br>                        <span class="hljs-keyword">continue</span><br>                    dis = math.sqrt((x - t2[<span class="hljs-number">0</span>]) ** <span class="hljs-number">2</span> + (y - t2[<span class="hljs-number">1</span>]) ** <span class="hljs-number">2</span>)  <span class="hljs-comment"># 欧几里得距离怎么算？sqrt((x1 - x2)^2 + (y1 - y2)^2)</span><br>                    <span class="hljs-keyword">if</span> dis &lt;= radius:  <span class="hljs-comment"># 能到达</span><br>                        tmp_signal += <span class="hljs-built_in">int</span>(t2[<span class="hljs-number">2</span>] / (<span class="hljs-number">1</span> + dis))<br>                <span class="hljs-keyword">if</span> tmp_signal &gt; max_signal[<span class="hljs-number">1</span>]:<br>                    max_signal = ([x, y], tmp_signal)<br>        <span class="hljs-keyword">return</span> max_signal[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>Solution</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Leetcode</tag>
      
      <tag>暴力搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣-784. 字母大小写全排列 &amp; 全排列</title>
    <link href="/2022/11/02/leetcode-784/"/>
    <url>/2022/11/02/leetcode-784/</url>
    
    <content type="html"><![CDATA[<h1>题目描述</h1><p><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_784_1.png" alt="784"><br><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_46_1.png" alt="46"><br><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_47_1.png" alt="47"></p><h1>思路和实现</h1><h2 id="784-字母大小写全排列">784. 字母大小写全排列</h2><h3 id="广度优先搜索">广度优先搜索</h3><p>提到广度优先搜索，我们就要想到队列，所以我们会使用一个队列来保存每一字符串。怎么进行广度优先搜索呢？当然是一直搜下去直到队列为空啦，<br>在搜索的过程中，我们每次取队列头的字符串，首先看看当前字符串长度是否和给我们的字符串<code>s</code>的长度一致，是的话塞到结果列表里，<br>不是的话，就看在它后面的那个字符串是字母还是数字，如果是字母，就把它的大小写都加到当前字符串里，然后塞队尾里；如果是数字，那就直接加到当前字符串里，然后塞队尾。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">letterCasePermutation</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:<br>        q = deque()<br>        q.append(<span class="hljs-string">&quot;&quot;</span>)<br>        result = []<br>        s_len = <span class="hljs-built_in">len</span>(s)<br>        <span class="hljs-keyword">while</span> q:<br>            tmp_str = q.popleft()<br>            n = <span class="hljs-built_in">len</span>(tmp_str)<br>            <span class="hljs-keyword">if</span> n == s_len:<br>                result.append(tmp_str)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">if</span> s[n].isalpha():  <span class="hljs-comment"># 当前字符串后面一位是字母</span><br>                    q.append(tmp_str + s[n])<br>                    q.append(tmp_str + s[n].swapcase())<br>                <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 是数字</span><br>                    q.append(tmp_str + s[n])<br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><h3 id="深度优先搜索">深度优先搜索</h3><p>既然都有广度优先搜索，那自然也有深度优先搜索啦，那深度优先搜索自然也就是使用栈来保存每一字符串啦，剩下的思路其实是和上面广度所述差不多的，<br>不过深度优先搜索可以使用递归，也可以不使用，这里两种都写一下吧。<br>先给出不使用递归的版本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">letterCasePermutation</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:<br>        q = deque()<br>        q.append(<span class="hljs-string">&quot;&quot;</span>)<br>        result = []<br>        s_len = <span class="hljs-built_in">len</span>(s)<br>        <span class="hljs-keyword">while</span> q:<br>            tmp_str = q.pop()<br>            n = <span class="hljs-built_in">len</span>(tmp_str)<br>            <span class="hljs-keyword">if</span> n == s_len:<br>                result.append(tmp_str)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">if</span> s[n].isalpha():  <span class="hljs-comment"># 当前字符串后面一位是字母</span><br>                    q.append(tmp_str + s[n].swapcase())<br>                    q.append(tmp_str + s[n])<br>                <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 是数字</span><br>                    q.append(tmp_str + s[n])<br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><p>可以看到代码基本是没变的，只是把队列换成了栈（因为懒所以没有改变量名称，用的还是<code>q(queue)</code>而不是<code>s(stack)</code>），顺便为了保证输出顺序，先压入转换大小写后的字符串，再压当前字符串。<br>使用递归的话，我们可以不使用额外空间存放字符串，直接使用字符串转为列表，然后进行深度优先搜索。如果遇到数字，就跳过；如果长度够了，就把当前列表转回字符串并加入结果集中；如果是字母，就调用递归，然后转换大小写再次递归，两次递归结束后别忘记回溯，即再次把大小写转换回去。<br>下面是使用递归版本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">letterCasePermutation</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:<br>        result = []<br>        s_len = <span class="hljs-built_in">len</span>(s)<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">cur_s, cur_len</span>):<br>            <span class="hljs-keyword">while</span> cur_len &lt; s_len <span class="hljs-keyword">and</span> s[cur_len].isdigit():<br>                cur_len += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> cur_len == s_len:  <span class="hljs-comment"># 递归出口</span><br>                result.append(<span class="hljs-string">&#x27;&#x27;</span>.join(cur_s))<br>                <span class="hljs-keyword">return</span><br>            dfs(cur_s, cur_len + <span class="hljs-number">1</span>)<br>            cur_s[cur_len] = cur_s[cur_len].swapcase()  <span class="hljs-comment"># 改变大小写再次搜索</span><br>            dfs(cur_s, cur_len + <span class="hljs-number">1</span>)<br>            cur_s[cur_len] = cur_s[cur_len].swapcase()  <span class="hljs-comment"># 回溯</span><br><br>        dfs(<span class="hljs-built_in">list</span>(s), <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><h2 id="46-全排序">46. 全排序</h2><h3 id="深度优先搜索-2">深度优先搜索</h3><p>对于这种全排列，可以画一颗树来方便理解，然后再由此联想到<code>dfs</code>——深度优先搜索来做。<br><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_46_2.png" alt="全排列树"><br>既然有递归，那首先想到的就是递归出口，这个递归出口怎么设置呢？根据树图可以联想到利用深度和题目所给数组长度：<code>if depth == length: return</code>，同时也能知道此时找到了一个排列，可以将其加入结果中。<br>然后要想的就是怎么进行递归了。图很直观地告诉我们，每一深度都遍历一遍数组，那就照做。不过还存在一个问题，在下一层中，我们不能使用已经用过的数，也就是说，在深度搜索的时候，还需要记得用过哪些数了。<br>关于这点，可以使用一个辅助数组来帮助记忆，建立一个<code>flag</code>数组，下标对应<code>nums</code>数组每个数，使用<code>visited</code>和<code>unvisited</code>两个值表示使用过和未使用过。<br>但是还没有结束，因为在完成一次搜索（递归）后还需要进行回溯，才能保证能继续进行搜索并搜索完。也就是说，在一次递归完成后（<code>depth == length</code>），我们需要把使用过的值再次标记为未使用，这叫回溯。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">permute</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        result = []<br>        tmp = []<br>        length = <span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-keyword">if</span> length == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> result<br>        flag = [<span class="hljs-string">&quot;unvisited&quot;</span>] * length  <span class="hljs-comment"># 为方便理解，这里用字符串来代替布尔值，也可使用布尔值（会更快）</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">depth: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">if</span> depth == length:<br>                result.append(tmp[:])  <span class="hljs-comment"># 记住是拷贝一份tmp的列表，而不是加入tmp的引用指向的列表</span><br>                <span class="hljs-keyword">return</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(length):<br>                <span class="hljs-keyword">if</span> flag[i] == <span class="hljs-string">&quot;unvisited&quot;</span>:<br>                    flag[i] = <span class="hljs-string">&quot;visited&quot;</span><br>                    tmp.append(nums[i])<br>                    dfs(depth + <span class="hljs-number">1</span>)  <span class="hljs-comment"># 进行深度优先搜索</span><br>                    flag[i] = <span class="hljs-string">&quot;unvisited&quot;</span>  <span class="hljs-comment"># 搜索完后，需要回溯，即把当前节点标记成未未访问的</span><br>                    tmp.pop()  <span class="hljs-comment"># 回溯第二步，因为变成未访问了，所以也要把这个数弹出</span><br>        dfs(<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><h2 id="47-全排列-II（包含重复数字的排列）">47. 全排列 II（包含重复数字的排列）</h2><h3 id="深度优先搜索-3">深度优先搜索</h3><p>在这一题中，题目所给出的<code>nums</code>数组中会包含重复的数字，但是输出不能包含重复的排列，所以这一题的大体思路其实是和上一题一样的，<br>而重点就是：<strong>如何去重</strong><br>我们先来看这颗树，可以发现，只要把同一层的重复的数跳过就行了，很简单对吧！<br><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_47_2.png" alt="全排列II的树"><br>对个鬼啊，深度优先搜索你怎么保留同一层的状态啊，同一层找这不广度优先搜索吗？<br>好吧，我没思路了，所以我们先尝试暴力搜索。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">permuteUnique</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        result = []<br>        tmp = []<br>        length = <span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-keyword">if</span> length == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> result<br>        flag = [<span class="hljs-string">&quot;unvisited&quot;</span>] * length  <span class="hljs-comment"># 为方便理解，这里用字符串来代替布尔值，也可使用布尔值（会更快）</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">depth: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">if</span> depth == length <span class="hljs-keyword">and</span> tmp <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> result:<br>                result.append(tmp[:])  <span class="hljs-comment"># 记住是拷贝一份tmp的列表，而不是加入tmp的引用指向的列表</span><br>                <span class="hljs-keyword">return</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(length):<br>                <span class="hljs-keyword">if</span> flag[i] == <span class="hljs-string">&quot;unvisited&quot;</span>:<br>                    flag[i] = <span class="hljs-string">&quot;visited&quot;</span><br>                    tmp.append(nums[i])<br>                    dfs(depth + <span class="hljs-number">1</span>)  <span class="hljs-comment"># 进行深度优先搜索</span><br>                    flag[i] = <span class="hljs-string">&quot;unvisited&quot;</span>  <span class="hljs-comment"># 搜索完后，需要回溯，即把当前节点标记成未未访问的</span><br>                    tmp.pop()  <span class="hljs-comment"># 回溯第二步，因为变成未访问了，所以也要把这个数弹出</span><br>        dfs(<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><p>虽然但是AC了，那这就是可行的思路，所以什么题都要先尝试暴力嘛（<br>ok，接下来是看别人题解时间！整理了一下思路放下边这张图了。（原来是叫<strong>剪枝</strong>操作啊<br><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_47_3.png" alt="思路"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">permuteUnique</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        result = []<br>        tmp = []<br>        length = <span class="hljs-built_in">len</span>(nums)<br>        nums.sort()<br>        <span class="hljs-keyword">if</span> length == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> result<br>        flag = [<span class="hljs-string">&quot;unvisited&quot;</span>] * length  <span class="hljs-comment"># 为方便理解，这里用字符串来代替布尔值，也可使用布尔值（会更快）</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">depth: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">if</span> depth == length:<br>                result.append(tmp[:])  <span class="hljs-comment"># 记住是拷贝一份tmp的列表，而不是加入tmp的引用指向的列表</span><br>                <span class="hljs-keyword">return</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(length):<br>                <span class="hljs-keyword">if</span> flag[i] == <span class="hljs-string">&quot;unvisited&quot;</span>:<br>                    <span class="hljs-keyword">if</span> i &gt;= <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> nums[i - <span class="hljs-number">1</span>] == nums[i] <span class="hljs-keyword">and</span> flag[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&quot;unvisited&quot;</span>:<br>                        <span class="hljs-keyword">continue</span><br>                    flag[i] = <span class="hljs-string">&quot;visited&quot;</span><br>                    tmp.append(nums[i])<br>                    dfs(depth + <span class="hljs-number">1</span>)  <span class="hljs-comment"># 进行深度优先搜索</span><br>                    flag[i] = <span class="hljs-string">&quot;unvisited&quot;</span>  <span class="hljs-comment"># 搜索完后，需要回溯，即把当前节点标记成未未访问的</span><br>                    tmp.pop()  <span class="hljs-comment"># 回溯第二步，因为变成未访问了，所以也要把这个数弹出</span><br><br>        dfs(<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>Solution</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Leetcode</tag>
      
      <tag>深度优先搜索</tag>
      
      <tag>广度优先搜索</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣-907. 子数组的最小值之和 &amp; 2104. 子数组范围和</title>
    <link href="/2022/10/28/leetcode-907-2104/"/>
    <url>/2022/10/28/leetcode-907-2104/</url>
    
    <content type="html"><![CDATA[<h1>题目描述</h1><p><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_907_1.png" alt="907"><br><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_2104_1.png" alt="2104"></p><h1>思路及实现</h1><h2 id="907-子数组的最小值之和">907. 子数组的最小值之和</h2><p>摆了，怎么有些人有了单调栈的基础还不会写单调栈的题啊？变一下就不行了，呜呜</p><h3 id="单调栈">单调栈</h3><p>如果要求直接求一个子数组里面的最小值，那么这个问题可能挺复杂的，如果只是单纯暴力遍历求最小值，那时间复杂度会很高，当然这里也直接超时了。<br>所以我们尝试另一种思路，分解成两个问题：<br>1、 求以arr[i]为最右且最小的子数组的数量（arr[i] &gt; arr[i - 1]、arr[i - 2]…），用left[i]保存<br>2、 求以arr[i]为最左且最小的子数组的数量（arr[i] &gt; arr[i + 1]、arr[i + 2]…），用right[i]保存<br>然后，left[i]和right[i]的积，就是以arr[i]为最小元素的子数组的数量。</p><blockquote><p>为什么呢？因为最右和最左都是以arr[i]为最小，所以最右的集合和最左的集合的&quot;笛卡尔积&quot;(因为突然觉得很像就说了)（其实是乘法原理（逃））就是以arr[i]为最小元素的子数组的数量。<br>比如 arr = [3, 1, 2, 4]，当 arr[i] = 1 时，left[i] 的集合就是 ([3, 1], [1])，right[i] 的集合就是 ([1], [1, 2], [1, 2, 4])<br>&quot;笛卡尔积&quot;就是： ([3, 1], [1], [3, 1, 2], [3, 1, 2, 4], [1, 2], [1, 2, 4])<br>而我们最后的结果，就是遍历数组，计算arr[i] * left[i] * right[i]的总和。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sumSubarrayMins</span>(<span class="hljs-params">self, arr: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        mod = <span class="hljs-number">10</span> ** <span class="hljs-number">9</span> + <span class="hljs-number">7</span><br>        result = <span class="hljs-number">0</span><br>        n = <span class="hljs-built_in">len</span>(arr)<br>        left = [<span class="hljs-number">0</span>] * n<br>        right = [<span class="hljs-number">0</span>] * n<br>        a_stack = []<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):  <span class="hljs-comment"># 从左往右遍历，找以arr[i]为最右且最小的子数组的数量</span><br>            <span class="hljs-keyword">while</span> a_stack <span class="hljs-keyword">and</span> arr[a_stack[-<span class="hljs-number">1</span>]] &gt;= arr[i]:<br>                a_stack.pop()<br>            left[i] = i - (a_stack[-<span class="hljs-number">1</span>] <span class="hljs-keyword">if</span> a_stack <span class="hljs-keyword">else</span> -<span class="hljs-number">1</span>)<br>            a_stack.append(i)<br>        a_stack = []<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):  <span class="hljs-comment"># 从右往左遍历，找以arr[i]为最左且最小的子数组的数量</span><br>            <span class="hljs-keyword">while</span> a_stack <span class="hljs-keyword">and</span> arr[a_stack[-<span class="hljs-number">1</span>]] &gt; arr[i]:<br>                a_stack.pop()<br>            right[i] = (a_stack[-<span class="hljs-number">1</span>] <span class="hljs-keyword">if</span> a_stack <span class="hljs-keyword">else</span> n) - i<br>            a_stack.append(i)<br>        <span class="hljs-keyword">for</span> num, l, r <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(arr, left, right):  <span class="hljs-comment"># 计算结果</span><br>            result = (result + num * l * r) % mod<br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><p>优化思路来源：(灵神的题解)[<a href="https://leetcode.cn/problems/sum-of-subarray-minimums/solution/gong-xian-fa-dan-diao-zhan-san-chong-shi-gxa5/">https://leetcode.cn/problems/sum-of-subarray-minimums/solution/gong-xian-fa-dan-diao-zhan-san-chong-shi-gxa5/</a>]<br>这个两次遍历也是可以优化的，思考一下就会发现，其实arr[i]在和栈顶元素进行比较并使其出栈的时候，就已经暗指arr[i]是栈顶元素的右边界了（右边第一个比它小的数）。</p><h2 id="2104-子数组范围和">2104. 子数组范围和</h2><h3 id="暴力遍历">暴力遍历</h3><p>直接让时间复杂度变成O(n^2)，穷举序列并找每个序列最小最大值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">subArrayRanges</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        result = <span class="hljs-number">0</span><br>        n = <span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):  <span class="hljs-comment"># 先拿一个数</span><br>            max_num = min_num = nums[i]<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>, n):  <span class="hljs-comment"># i这个数所构成的所有子数组</span><br>                max_num = <span class="hljs-built_in">max</span>(max_num, nums[j])  <span class="hljs-comment"># 及时更新最大最小值</span><br>                min_num = <span class="hljs-built_in">min</span>(min_num, nums[j])<br>                result += max_num - min_num  <span class="hljs-comment"># 把每个子数组的结果加到最终结果上</span><br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><h3 id="单调栈-2">单调栈</h3><p>其实这题的单调栈思路我是不会的（逃，因为一直在想这怎么单调这怎么单调，要求的可是一个子数组里的最大和最小，同时求不出啊。<br>一看题解，哦，这里有笨蛋，等级四。题目要求的每个子数组的最大和最小的差的和，不就是先求出每个子数组的最大值的和，然后再求每个子数组最小值的和，再相减嘛。<br>我完全明白了！这下确实是单调栈了。然后这题就成了907的扩展了：求出以当前数字为最小值的所有子数组的数量，然后计算最小值的和，以及以当前数字为最大值的所有子数组的数量，求出最大值的和，最后相减。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">subArrayRanges</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        max_sum = <span class="hljs-number">0</span><br>        min_sum = <span class="hljs-number">0</span><br>        left = [-<span class="hljs-number">1</span>] * n<br>        right = [n] * n<br>        a_stack = []<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):  <span class="hljs-comment"># 先求最大</span><br>            <span class="hljs-keyword">while</span> a_stack <span class="hljs-keyword">and</span> nums[a_stack[-<span class="hljs-number">1</span>]] &lt;= nums[i]:<br>                right[a_stack.pop()] = i<br>            <span class="hljs-keyword">if</span> a_stack:<br>                left[i] = a_stack[-<span class="hljs-number">1</span>]<br>            a_stack.append(i)<br>        <span class="hljs-keyword">for</span> i, (num, l, r) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(<span class="hljs-built_in">zip</span>(nums, left, right)):<br>            max_sum += num * (i - l) * (r - i)<br>        left = [-<span class="hljs-number">1</span>] * n<br>        right = [n] * n<br>        a_stack = []<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):  <span class="hljs-comment"># 再求最小</span><br>            <span class="hljs-keyword">while</span> a_stack <span class="hljs-keyword">and</span> nums[a_stack[-<span class="hljs-number">1</span>]] &gt;= nums[i]:<br>                right[a_stack.pop()] = i<br>            <span class="hljs-keyword">if</span> a_stack:<br>                left[i] = a_stack[-<span class="hljs-number">1</span>]<br>            a_stack.append(i)<br>        <span class="hljs-keyword">for</span> i, (num, l, r) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(<span class="hljs-built_in">zip</span>(nums, left, right)):<br>            min_sum += num * (i - l) * (r - i)<br>        <span class="hljs-keyword">return</span> max_sum - min_sum<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>Solution</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Leetcode</tag>
      
      <tag>单调栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣-3. 无重复字符的最长子串</title>
    <link href="/2022/10/28/leetcode-3/"/>
    <url>/2022/10/28/leetcode-3/</url>
    
    <content type="html"><![CDATA[<h1>题目描述</h1><p><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_3_1.png" alt="3"></p><h1>思路及实现</h1><p>找一个不含有重复字符的最长字串，由不重复字符我们可以想到哈希表，在遍历字符串的时候，遇到一个字符就判断这个字符在不在哈希表里边，如果在就说明出现重复字符，此时可以计算子串的长度（两个重复字符的索引相减）。<br>然后为了节省时间复杂度，我们可以使用滑动窗口来防止重复遍历。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lengthOfLongestSubstring</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        result = <span class="hljs-number">0</span><br>        left = right = <span class="hljs-number">0</span><br>        a_dict = &#123;&#125;<br>        n = <span class="hljs-built_in">len</span>(s)<br>        <span class="hljs-keyword">while</span> right &lt; n:<br>            <span class="hljs-keyword">if</span> s[right] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> a_dict:  <span class="hljs-comment"># 字典中未查到该字符出现过</span><br>                a_dict[s[right]] = right  <span class="hljs-comment"># 记录索引位置</span><br>                right += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">if</span> (right - left) &gt; result:  <span class="hljs-comment"># 更新最大值</span><br>                    result = right - left<br>                <span class="hljs-keyword">if</span> left &lt; a_dict[s[right]] + <span class="hljs-number">1</span>:<br>                    left = a_dict[s[right]] + <span class="hljs-number">1</span><br>                a_dict.pop(s[right])<br>        <span class="hljs-keyword">if</span> right - left &gt; result:  <span class="hljs-comment"># 更新最大值</span><br>            result = right - left<br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><p>但是我们可以发现，在检查到重复字符出现后，其实并不需要弹出相应键值对，我们可以直接在检查每个字符的时候更新左指针索引，左指针是不需要回头看的，只会往右走。<br>然后更新结果，最后更新字典中当前字符的索引即可。<br>优化后的另一种写法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lengthOfLongestSubstring</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        result = <span class="hljs-number">0</span><br>        left = right = <span class="hljs-number">0</span><br>        a_dict = &#123;&#125;<br>        n = <span class="hljs-built_in">len</span>(s)<br>        <span class="hljs-keyword">for</span> right <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">if</span> s[right] <span class="hljs-keyword">in</span> a_dict:  <span class="hljs-comment"># 字典中查到该字符出现过</span><br>                left = <span class="hljs-built_in">max</span>(left, a_dict[s[right]])<br>            result = <span class="hljs-built_in">max</span>(result, right - left + <span class="hljs-number">1</span>)<br>            a_dict[s[right]] = right + <span class="hljs-number">1</span>  <span class="hljs-comment"># 记录索引位置</span><br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>Solution</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Leetcode</tag>
      
      <tag>字符串</tag>
      
      <tag>哈希表</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣-934. 最短的桥</title>
    <link href="/2022/10/25/leetcode-934/"/>
    <url>/2022/10/25/leetcode-934/</url>
    
    <content type="html"><![CDATA[<h1>题目描述</h1><p><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_934_1.png" alt="934"></p><h1>思路及实现</h1><p>看题，想都不用想迷宫问题直接bfs或者dfs完事了好吧（<br>可能题目描述不是很好，在这里简单描述一下，岛是这样定义的：相连的1。也就是一个1，它的四个方向如果某个方向有1，那么这些1算一个岛，如果没有，那它本身就是一个岛。<br>所以，为了防止我们搭桥搭到本岛，我们需要先把第一个岛找出来：首先直接遍历，直到找到是一个是1的位置（代表陆地的位置），然后用dfs或者bfs把所有相邻的1找出来，下面代码我用的是迭代实现的dfs。<br>找完一个岛之后，我们就开始搭桥了。这里需要用到bfs，因为需要搭一个最短的桥，bfs可以每次往外扩一圈。<br>但是这里需要对bfs进行一点修改，采用的是这样的策略：我们把当前踩的地方利用bfs遍历完，这才代表往外扩大一圈，桥长度加一，然后这次遍历新找到的地方存放在一个新队列，用于下次扩圈。当然如果bfs过程中找到1（陆地）了，就直接返回桥的长度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">shortestBridge</span>(<span class="hljs-params">self, grid: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(grid)  <span class="hljs-comment"># 构建标记二维数组，0和1都表示unvisited，-1表示visited</span><br>        a_stack = deque()  <span class="hljs-comment"># dfs用的栈</span><br>        a_queue = deque()  <span class="hljs-comment"># bfs用的队列</span><br>        step = <span class="hljs-number">0</span>  <span class="hljs-comment"># 桥的长度(必须翻转的0的最小数目)</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                <span class="hljs-keyword">if</span> grid[i][j] == <span class="hljs-number">1</span>:  <span class="hljs-comment"># 先找第一个岛</span><br>                    grid[i][j] = -<span class="hljs-number">1</span><br>                    a_stack.append((i, j))<br>                    a_queue.append((i, j))<br>                    <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">if</span> a_stack:<br>                <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">while</span> a_stack:  <span class="hljs-comment"># dfs把第一个岛的范围找出来</span><br>            i, j = a_stack.pop()<br>            <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> (i + <span class="hljs-number">1</span>, j), (i - <span class="hljs-number">1</span>, j), (i, j + <span class="hljs-number">1</span>), (i, j - <span class="hljs-number">1</span>):  <span class="hljs-comment"># 上下左右找</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= x &lt; n <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= y &lt; n <span class="hljs-keyword">and</span> grid[x][y] == <span class="hljs-number">1</span>:  <span class="hljs-comment"># 如果unvisited而且是陆地</span><br>                    grid[x][y] = -<span class="hljs-number">1</span>  <span class="hljs-comment"># 标记visited</span><br>                    a_stack.append((x, y))  <span class="hljs-comment"># 入栈</span><br>                    a_queue.append((x, y))  <span class="hljs-comment"># 入队</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:  <span class="hljs-comment"># bfs搭桥</span><br>            tmp = a_queue<br>            a_queue = deque()<br>            <span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> tmp:<br>                <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> (i + <span class="hljs-number">1</span>, j), (i - <span class="hljs-number">1</span>, j), (i, j + <span class="hljs-number">1</span>), (i, j - <span class="hljs-number">1</span>):  <span class="hljs-comment"># 上下左右找</span><br>                    <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= x &lt; n <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= y &lt; n:<br>                        <span class="hljs-keyword">if</span> grid[x][y] == <span class="hljs-number">0</span>:  <span class="hljs-comment"># 如果unvisited而且是陆地</span><br>                            grid[x][y] = -<span class="hljs-number">1</span>  <span class="hljs-comment"># 标记visited</span><br>                            a_queue.append((x, y))  <span class="hljs-comment"># 入队</span><br>                        <span class="hljs-keyword">elif</span> grid[x][y] == <span class="hljs-number">1</span>:  <span class="hljs-comment"># 找到下一座岛</span><br>                            <span class="hljs-keyword">return</span> step<br>            step += <span class="hljs-number">1</span>  <span class="hljs-comment"># 每往外找一圈桥的长度就加一</span><br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>Solution</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣-901.股票价格跨度 &amp;&amp; 单调栈</title>
    <link href="/2022/10/21/leetcode-901/"/>
    <url>/2022/10/21/leetcode-901/</url>
    
    <content type="html"><![CDATA[<h1>题目描述</h1><p><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_901_1.png" alt="901.股票价格跨度"><br><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_496_1.png" alt="496.下一个更大元素 I"><br><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_503_1.png" alt="503.下一个更大元素 II"></p><h1>思路及实现</h1><h2 id="901-股票价格跨度">901.股票价格跨度</h2><p>你别说，这题求的是当天的股票价格趋势，然后是要用之前的状态求解当前状态的，这何尝不是DP（逃</p><h3 id="向前遍历">向前遍历</h3><p>最容易想到的一种实现就是每天都往前遍历之前的股票价格，如果满足就加上，同时因为我们使用了数组<code>days</code>保存每天的股票价格的跨度，所以可以避免一定的重复遍历。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StockSpanner</span>:<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.prices = []  <span class="hljs-comment"># 保存每天的股票价格</span><br>        self.days = []  <span class="hljs-comment"># 保存今天股票价格的跨度</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">next</span>(<span class="hljs-params">self, price: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        self.prices.append(price)<br>        p = <span class="hljs-built_in">len</span>(self.days) - <span class="hljs-number">1</span><br>        day = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> p &gt;= <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">if</span> self.prices[p] &lt;= price:<br>                day += self.days[p]  <span class="hljs-comment"># 如果今天价格大于之前某一天，那么他也大于那一天股票价格大于的其他天的价格（if a &gt; b and b &gt; c then a &gt; c），直接加上那一天的股票价格的跨度</span><br>                p -= self.days[p]  <span class="hljs-comment"># 一定程度上避免重复遍历</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">break</span><br>        self.days.append(day)<br>        <span class="hljs-keyword">return</span> day<br></code></pre></td></tr></table></figure><h3 id="单调栈">单调栈</h3><p>（P.S. 可以先去看看下面496）<br>既然是要求下一个更大的元素，很容易就能想到用单调栈求解，为了省去不必要的麻烦，我们可以使用二元组来保存每一个数据（当天是从第一天起计的第几天和当天股票的价格）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StockSpanner</span>:<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.a_stack = [(-<span class="hljs-number">1</span>, math.inf)]<br>        self.i = -<span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">next</span>(<span class="hljs-params">self, price: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        self.i += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> price &gt;= self.a_stack[-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]:  <span class="hljs-comment"># 遇到栈中有比自己小的股票价格就将其出栈（保持栈单调）</span><br>            self.a_stack.pop()<br>        self.a_stack.append((self.i, price))  <span class="hljs-comment"># 把当前的股票的情况入栈</span><br>        <span class="hljs-keyword">return</span> self.i - self.a_stack[-<span class="hljs-number">2</span>][<span class="hljs-number">0</span>]  <span class="hljs-comment"># 计算股票价格的跨度</span><br></code></pre></td></tr></table></figure><p>如果不是很理解为什么把小于当前价格的元素出栈之后减去下一个天数返回的就是当天股票价格的跨度的话，那可以不保存第几天，而是保存股票价格趋势，这样的话也是可以的，而且好理解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StockSpanner</span>:<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.a_stack = [(-<span class="hljs-number">1</span>, math.inf)]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">next</span>(<span class="hljs-params">self, price: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        i = <span class="hljs-number">1</span>  <span class="hljs-comment"># 股票价格趋势最少为一天</span><br>        <span class="hljs-keyword">while</span> price &gt;= self.a_stack[-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]:  <span class="hljs-comment"># 遇到栈中有比自己小的股票价格就将其出栈（保持栈单调）</span><br>            i += self.a_stack.pop()[<span class="hljs-number">0</span>]  <span class="hljs-comment"># 加上出栈的股票价格天数</span><br>        self.a_stack.append((i, price))  <span class="hljs-comment"># 把当前的股票的情况入栈</span><br>        <span class="hljs-keyword">return</span> i<br></code></pre></td></tr></table></figure><h2 id="496-下一个更大元素-I">496.下一个更大元素 I</h2><h3 id="暴力遍历">暴力遍历</h3><p>看一眼题目就知道可以暴力遍历的啦，正向也行反向也行，下面的代码把<code>nums2</code>反转了，然后遍历<code>rvs_nums2</code>，再对其中每个数往前遍历，找第一个大于当前数的数（也就是题目所说的下一个更大元素），并记录到一个字典中，<br>因为我们最后是需要返回一个对应<code>nums1</code>中的数的顺序的数组的，且没有相同的数字，所以利用字典可以很方便地存储每个数的状态。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">nextGreaterElement</span>(<span class="hljs-params">self, nums1: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], nums2: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        a_dict = &#123;&#125;<br>        rvs_nums2 = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">reversed</span>(nums2))<br>        <span class="hljs-keyword">for</span> i, num <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(rvs_nums2):<br>            <span class="hljs-keyword">while</span> i &gt; <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">if</span> rvs_nums2[i - <span class="hljs-number">1</span>] &gt; num:  <span class="hljs-comment"># 如果前边有更大的数</span><br>                    a_dict[num] = rvs_nums2[i - <span class="hljs-number">1</span>]  <span class="hljs-comment"># 保存更大的数字为值到当前数字为键的字典的键值对中</span><br>                    <span class="hljs-keyword">break</span><br>                i -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> num <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> a_dict:  <span class="hljs-comment"># 找不到更大的数</span><br>                a_dict[num] = -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> [a_dict[num] <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums1]<br></code></pre></td></tr></table></figure><h3 id="单调栈-2">单调栈</h3><p>很喜欢力扣这题的官方题解评论区一位老哥说的话：<br><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_496_2.png" alt="神评"><br>单调栈，用于解决NGE（Next Greater Element）问题，因所维护的栈中元素呈单调递增/递减，所以叫单调栈。<br>下面是解决这类题目的模板代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">nextGreaterElement</span>(<span class="hljs-params">self, nums1: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], nums2: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        a_dict=&#123;&#125;<br>        a_stack=[]<br>        <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> <span class="hljs-built_in">reversed</span>(nums2):<br>            <span class="hljs-keyword">while</span> a_stack <span class="hljs-keyword">and</span> a_stack[-<span class="hljs-number">1</span>] &lt;= num:<br>                a_stack.pop()<br>            a_dict[num] = a_stack[-<span class="hljs-number">1</span>] <span class="hljs-keyword">if</span> a_stack <span class="hljs-keyword">else</span> -<span class="hljs-number">1</span><br>            a_stack.append(num)<br>        <span class="hljs-keyword">return</span> [a_dict[num] <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums1]<br></code></pre></td></tr></table></figure><p>可以看到我们会把题目给的数组先反转一次再进行遍历，然后直到当前数不大于栈顶数或空栈为止，执行弹出（pop）操作。<br>这是因为如果当前数比栈顶数大的话，那么在这之后的数如果能以栈顶数作为下一个更大元素，那肯定也能以当前数作为下一个更大元素，且我们的数组是反转过的，也就是后来数的下标才离得更近。<br>找到结果之后，把当前数入栈。</p><h2 id="503-下一个更大元素-II">503.下一个更大元素 II</h2><p>既然已经解决了最基本的单调栈，现在让我们来看看变形：现在不止要看右边了，因为是循环数组，所以也要看左边了。<br>看到题目给的循环，大家是不是马上就想到：<code>%</code>运算符！确实，数据结构不也这么学了吗，超过数组下标的话对数组长度取余就回去了，没错，这里也是一个道理。<br>仔细想想，我们可以知道无论怎么循环，这题本质上就是两个给定的数组拼在一起的NGE问题罢了，然后可以得出以下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">nextGreaterElements</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        a_list = [-<span class="hljs-number">1</span>] * n<br>        a_stack = []<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">while</span> a_stack <span class="hljs-keyword">and</span> a_stack[-<span class="hljs-number">1</span>] &lt;= nums[i % n]:<br>                a_stack.pop()<br>            <span class="hljs-keyword">if</span> a_stack:<br>                a_list[i % n] = a_stack[-<span class="hljs-number">1</span>]<br>            a_stack.append(nums[i % n])<br>        <span class="hljs-keyword">return</span> a_list<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>Solution</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣-779. 第K个语法符号 &amp;&amp; 位运算</title>
    <link href="/2022/10/21/leetcode-779/"/>
    <url>/2022/10/21/leetcode-779/</url>
    
    <content type="html"><![CDATA[<h1>题目描述</h1><p><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_191_1.png" alt="191"><br><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_779_1.png" alt="779"></p><h1>思路及实现</h1><h2 id="191-位1的个数">191.位1的个数</h2><h3 id="作弊流写法">作弊流写法</h3><p>除了学会一个新方法之外什么都学不到的写法（</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hammingWeight</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">return</span> n.bit_count()<br></code></pre></td></tr></table></figure><h3 id="循环检查">循环检查</h3><p>检查题目所给定的数中1的个数即可，每次检查1位，<code>i</code>从0取到31，每次都用<code>1 &lt;&lt; i</code>（1,10,100…）和<code>n</code>作与运算，如果n的二进制表示的当前位是1那么就是1，是0就是0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hammingWeight</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        ret = <span class="hljs-built_in">sum</span>(<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">if</span> n &amp; (<span class="hljs-number">1</span> &lt;&lt; i))<br>        <span class="hljs-keyword">return</span> ret<br></code></pre></td></tr></table></figure><h3 id="位运算优化">位运算优化</h3><p>其实优化的关键就是一个式子：<code>n &amp; (n−1)</code>。大家可以举个例子试一下一个数和它自身减一的数做与运算会发生什么，没错，其运算结果恰为把<code>n</code>的二进制位中的最低位的1变为0之后的结果。<br>也就是说，我们只需要不断计算这个式子，<code>n</code>最后会变成0，而每次计算，<code>n</code>就少一个1，相应的结果（1的个数）计数加一就好。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hammingWeight</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        ret = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> n:<br>            n &amp;= n - <span class="hljs-number">1</span><br>            ret += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> ret<br></code></pre></td></tr></table></figure><h3 id="奇偶校验">奇偶校验</h3><p>额，说实话，翻来覆去看不懂代码，好不容易找到了个有解释的网站，转载一波explanation吧。<br>先上网站：<a href="https://bits.stephan-brumme.com/countBits.html">Count bits set in parallel a.k.a. Population Count</a><br>附赠网址：<a href="https://graphics.stanford.edu/~seander/bithacks.html">Bit Twiddling Hacks</a></p><blockquote><p>countBits (line 1 − line 13):<br>Counting all set bits of an integer was part of many mainframe CPU’s assembler language but somehow<br>x86 CPUs ignored it for decades. Apparently Intel introduced the POPCNT opcode in its Core i7 design.</p><p>Meanwhile, the population count has to be implemented by other means.<br>The main observations lies in the fact that you can subdivide any bitblock into smaller chunks,<br>compute their population count and add all intermediate results.</p><p>First, the code counts the bits of two adjacent bits:</p><p>0b and 0b → 00b<br>0b and 1b → 01b<br>1b and 0b → 01b<br>1b and 1b → 10b</p><p>The whole algorithm modifies the input in order to generate the output, that means it works in-place.<br>Line 4 performs the 2-bit count at once based on the observation:</p><p>00b → unchanged, still 00b<br>01b → unchanged, still 01b<br>10b → must be converted to 01b<br>11b → must be converted to 10b</p><p>Whenever the higher bit of each 2-bit group is set, subtracting 01b gives the desired outcome.<br>Looks like branching … but as it turns out, the subtraction can be done always: just subtract the higher bit !<br>If it is 0, the result remains unchanged, if it is 1, then we get the right numbers, too.<br>The shift x &gt;&gt; 1 and the following mask of all odd bits (0x55 is 01010101b):</p><p>00b → shifted: ?0b → masked: 00b → subtraction: 00b − 00b → 00b<br>01b → shifted: ?0b → masked: 00b → subtraction: 01b − 00b → 01b<br>10b → shifted: ?1b → masked: 01b → subtraction: 10b − 01b → 01b<br>11b → shifted: ?1b → masked: 01b → subtraction: 11b − 01b → 10b</p><p>Now the 2-bit count is done. As you can see, there are just three possible decimal results: 0, 1 or 2.</p><p>Then, two adjacent 2-bit groups are joined to 4-bit groups (line 6):</p><p>00b and 00b → 0000b<br>00b and 01b → 0001b<br>00b and 10b → 0010b<br>01b and 00b → 0001b<br>01b and 01b → 0010b<br>01b and 10b → 0011b<br>10b and 00b → 0010b<br>10b and 01b → 0011b<br>10b and 10b → 0100b</p><p>This time, the 2-bit groups are masked and shifted to match and then simply added. No overflow is possible.</p><p>00b + 00b → 0000b<br>00b + 01b → 0001b<br>00b + 10b → 0010b<br>01b + 00b → 0001b<br>01b + 01b → 0010b<br>01b + 10b → 0011b<br>10b + 00b → 0010b<br>10b + 01b → 0011b<br>10b + 10b → 0100b</p><p>The same procedure is done for all 4-bit groups yielding the bit counts for each of the four bytes (line 8)<br>in their lower four bits. That means, each byte contains its bit count, however, the upper four bits may<br>contain junk and are masked out (line 10).</p><p>Multiplying by 0x01010101 has an interesting property if we name the four bytes A, B, C, D:</p><p>A, B, C, D → A+B+C+D, B+C+D, C+D, D</p><p>Obviously the highest byte is what we are looking for. The right shift (line 12) returns just it.</p></blockquote><p>顺便附上代码里边十六进制数对应的二进制数。<br>0x55555555 = 01010101 01010101 01010101 01010101<br>0x33333333 = 00110011 00110011 00110011 00110011<br>0x0F0F0F0F = 00001111 00001111 00001111 00001111<br>0x00FF00FF = 00000000 11111111 00000000 11111111<br>0x0000FFFF = 00000000 00000000 11111111 11111111<br>0x01010101 = 00000001 00000001 00000001 00000001<br>0x0000003f = 00000000 00000000 00000000 00111111</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hammingWeight</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = n - ((n &gt;&gt; <span class="hljs-number">1</span>) &amp; <span class="hljs-number">0x55555555</span>)<br>        n = (n &amp; <span class="hljs-number">0x33333333</span>) + ((n &gt;&gt; <span class="hljs-number">2</span>) &amp; <span class="hljs-number">0x33333333</span>)<br>        n = (n + (n &gt;&gt; <span class="hljs-number">4</span>)) &amp; <span class="hljs-number">0x0f0f0f0f</span><br>        n = n + (n &gt;&gt; <span class="hljs-number">8</span>)<br>        n = n + (n &gt;&gt; <span class="hljs-number">16</span>)<br>        <span class="hljs-keyword">return</span> n &amp; <span class="hljs-number">0x3f</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// you need to treat n as an unsigned value</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hammingWeight</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br><span class="hljs-comment">// count bits of each 2-bit chunk</span><br>        n = n - ((n &gt;&gt;&gt; <span class="hljs-number">1</span>) &amp; <span class="hljs-number">0x55555555</span>);<br><span class="hljs-comment">// count bits of each 4-bit chunk</span><br>        n = (n &amp; <span class="hljs-number">0x33333333</span>) + ((n &gt;&gt;&gt; <span class="hljs-number">2</span>) &amp; <span class="hljs-number">0x33333333</span>);<br><span class="hljs-comment">// count bits of each 8-bit chunk:x  = x + (x &gt;&gt; 4);</span><br><span class="hljs-comment">// mask out junk:x &amp;= 0xF0F0F0F;</span><br><span class="hljs-comment">// add all four 8-bit chunks:(x * 0x01010101) &gt;&gt; 24;</span><br>        <span class="hljs-keyword">return</span> ((n + (n &gt;&gt;&gt; <span class="hljs-number">4</span>) &amp; <span class="hljs-number">0xF0F0F0F</span>) * <span class="hljs-number">0x1010101</span>) &gt;&gt;&gt; <span class="hljs-number">24</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>建议还是用第三种循环法，好理解且复杂度不高。</p><h2 id="779-第K个语法符号">779.第K个语法符号</h2><h3 id="找规律，然后递归求解">找规律，然后递归求解</h3><p>根据题目所给规则，我们先构造出前几个数：<br>0<br>0 1<br>01 10<br>0110 1001<br>01101001 10010110<br>可以看到每一行的后半部分的数都是前半部分数的翻转，即：0变1，1变0。那么对k，如果k在后半部分，我们可以尝试求解上一行前半部分对应位置的数，然后将其翻转；如果k在前半部分，那么直接求上一行对应位置的数即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">kthGrammar</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">if</span> k == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> k &gt; (<span class="hljs-number">1</span> &lt;&lt; (n - <span class="hljs-number">2</span>)):  <span class="hljs-comment"># 1 &lt;&lt; (n - 2) = 上一行长度的一半</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> ^ self.kthGrammar(n - <span class="hljs-number">1</span>, k - (<span class="hljs-number">1</span> &lt;&lt; (n - <span class="hljs-number">2</span>)))  <span class="hljs-comment"># k大于当前行长度一半，那么要返回的数就等于镜像位置的数字取反</span><br>        <span class="hljs-keyword">return</span> self.kthGrammar(n - <span class="hljs-number">1</span>, k)  <span class="hljs-comment"># k小于等于当前行长度一半，那么要返回的数就等于上一行当前位置的数字</span><br></code></pre></td></tr></table></figure><h3 id="构造完全二叉树，然后递归求解">构造完全二叉树，然后递归求解</h3><p>这个是看了别人的思路，发现好厉害，居然还有这种操作，还是我思维不行呜呜呜<br>上链接：<a href="https://leetcode.cn/problems/k-th-symbol-in-grammar/solution/nao-jin-ji-zhuan-wan-by-heren1229-nvf5/">大佬的二叉树解题思路</a><br>下边是按照思路写的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">kthGrammar</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:  <span class="hljs-comment"># 第一层，直接返回0</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        num = self.kthGrammar(n - <span class="hljs-number">1</span>, (k + <span class="hljs-number">1</span>) // <span class="hljs-number">2</span>)  <span class="hljs-comment"># 找一下父节点是0还是1</span><br>        <span class="hljs-keyword">if</span> num == <span class="hljs-number">0</span>:  <span class="hljs-comment"># 父节点为0</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> k % <span class="hljs-number">2</span> <span class="hljs-keyword">else</span> <span class="hljs-number">1</span>  <span class="hljs-comment"># 如果k是奇数，那就是左子节点；如果k是偶数，那就是右子节点</span><br>        <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 父节点为1</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> k % <span class="hljs-number">2</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>Solution</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣-904.水果成篮</title>
    <link href="/2022/10/17/leetcode-904/"/>
    <url>/2022/10/17/leetcode-904/</url>
    
    <content type="html"><![CDATA[<h1>题目描述</h1><p><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_904_1.png" alt="第一张图"></p><h1>思路及实现</h1><h2 id="if-else分析法">if-else分析法</h2><p>由题我们可以知道，其实题目就是给你一个数组，然后让你找出只包含两个不同元素（数字）的最长切片长度。<br>那么我们可以用一个<code>basket</code>列表来存储当前篮子中的水果类型（也就是数字），<code>max_num</code>则是最多能采摘的水果数量（只包含两个不同数字的最大切片长度），<code>cnt</code>保存当前篮子里的水果数量（当前切片长度），<code>mark</code>则是用于帮助回溯前一个水果类型最前边的一颗果树的位置（比如：<code>[3, 3, 3]</code>，那么mark应该是1）。<br>然后对数组<code>fruits</code>进行遍历，一共四种情况，可以看代码注释。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">totalFruit</span>(<span class="hljs-params">self, fruits: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        max_num = <span class="hljs-number">0</span><br>        cnt = <span class="hljs-number">0</span><br>        basket = []<br>        mark = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i, num <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(fruits):<br>            <span class="hljs-keyword">if</span> num <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> basket:  <span class="hljs-comment"># 水果不在篮子里边</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(basket) &lt; <span class="hljs-number">2</span>:  <span class="hljs-comment"># 篮子没满</span><br>                    mark = i<br>                    basket.append(num)<br>                    cnt += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 篮子满了，前一个水果和当前水果必定不同，从mark开始，构造一个新果篮的同时看下前一个果篮的值是否大于最大的果篮</span><br>                    basket = [fruits[i - <span class="hljs-number">1</span>], num]<br>                    <span class="hljs-keyword">if</span> cnt &gt; max_num:<br>                        max_num = cnt<br>                    cnt = i - mark + <span class="hljs-number">1</span><br>                    mark = i<br>            <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 水果在篮子里边</span><br>                <span class="hljs-keyword">if</span> num != fruits[i - <span class="hljs-number">1</span>]:  <span class="hljs-comment"># 不和前一个水果相同，更新mark标记</span><br>                    mark = i<br>                cnt += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> cnt &gt; max_num:  <span class="hljs-comment"># 循环结束后别忘记比较最后的果篮和最大的果篮</span><br>            max_num = cnt<br>        <span class="hljs-keyword">return</span> max_num<br></code></pre></td></tr></table></figure><h2 id="滑动窗口">滑动窗口</h2><p>我们用<code>left</code>和<code>right</code>分别表示满足要求的窗口的左右边界，然后用哈希表来存储这个窗口内的水果（数）以及水果的数量（出现的次数）。哈希表中的<code>Key</code>的数量就是果篮里装的水果类型的数量，<code>Value</code>则是水果类型对应水果的数量。<br>然后每次<code>right</code>都会向右移动一个位置，记录并更新哈希表，并判断哈希表中是否超过两种水果（<code>Key</code>的数量大于2），如果超过，就要开始移动<code>left</code>，同时更新哈希表，如果哈希表中一个水果的数量<code>Value</code>为0，那就删除对应的键值对，让哈希表中只留下两种水果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">totalFruit</span>(<span class="hljs-params">self, fruits: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:  <span class="hljs-comment"># 官方题解滑动窗口</span><br>        cnt = Counter()<br><br>        left = ans = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> right, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(fruits):<br>            cnt[x] += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(cnt) &gt; <span class="hljs-number">2</span>:<br>                cnt[fruits[left]] -= <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> cnt[fruits[left]] == <span class="hljs-number">0</span>:<br>                    cnt.pop(fruits[left])<br>                left += <span class="hljs-number">1</span><br>            ans = <span class="hljs-built_in">max</span>(ans, right - left + <span class="hljs-number">1</span>)<br>        <br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><blockquote><p>看到的优化思路：因为题目是要找最大的窗口，所以我们可以不缩小窗口，只不过不满足条件的时候不更新窗口，直接让窗口整体向右移动即可。</p></blockquote><hr>]]></content>
    
    
    <categories>
      
      <category>Solution</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣-1441.用栈操作构建数组</title>
    <link href="/2022/10/15/leetcode-1441/"/>
    <url>/2022/10/15/leetcode-1441/</url>
    
    <content type="html"><![CDATA[<h1>题目描述</h1><p><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_1441_1.png" alt="第一张图"></p><h1>思路及实现</h1><p>我们可以知道，<code>list</code>和<code>target</code>都是严格递增的，而我们取数也是按顺序：1、2、3…取下去，<br>所以用<code>for</code>循环遍历一遍<code>target</code>数组，并计算当前数字和前一数字的差，如果当前数字和前一个数字之差大于1，说明前一数字和当前数字之间还隔了几个数，那么我们需要进行数个<code>push</code>和<code>pop</code>操作，来达到<code>list</code>中当前数字的位置，并把它<code>push</code>进去；<br>如果差刚好为1，说明当前数字就是前一数字的下一位，直接<code>push</code>即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">buildArray</span>(<span class="hljs-params">self, target: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:<br>        push = <span class="hljs-string">&quot;Push&quot;</span><br>        pop = <span class="hljs-string">&quot;Pop&quot;</span><br>        result = []<br>        pre_num = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i, num <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(target):<br>            cnt = num - pre_num<br>            <span class="hljs-keyword">if</span> cnt &gt; <span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">while</span> cnt != <span class="hljs-number">1</span>:<br>                    result.append(push)<br>                    result.append(pop)<br>                    cnt -= <span class="hljs-number">1</span><br>            result.append(push)<br>            pre_num = num<br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><p>额，这题难度中等不知道是怎么来的，十分朴素的栈模拟，一分钟就能出答案。</p><hr>]]></content>
    
    
    <categories>
      
      <category>Solution</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣-769.最多能完成排序的块</title>
    <link href="/2022/10/13/leetcode-769/"/>
    <url>/2022/10/13/leetcode-769/</url>
    
    <content type="html"><![CDATA[<h1>题目描述</h1><h2 id="769">769</h2><p><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_769_1.png" alt="第一张图"></p><h2 id="768">768</h2><p><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_768_1.png" alt="第一张图"></p><h1>思路及实现</h1><h2 id="769-2">769</h2><p>说实话，这题我的路子挺野的，感觉做法不太对，有点歪，但是由于这题数据的特殊性，我的做法还刚好挺吃香的（但是别学.jpg）。<br>我们能够知道的是，数组里的每个元素都不同而且数组长度还 &lt;= 10，再观察题目要求和示例，分块需要在单独排序后连接起来还是有序的，说明在当前分块中，最大的元素如果小于剩下数组中的最小元素，就可以进行分块；反之不行。<br>那么我们设置一个最大值来保存当前分块的最大值的同时，也利用一个<code>cnt</code>保存分块数量。由于最小分块是1，我们的<code>cnt</code>也应该初始化为<code>1</code>。<br>然后对数组进行遍历，并给剩下的数组临时排序，以便找出最小元素，进行判断即可。每次循环后记得更新当前分块最大值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxChunksToSorted</span>(<span class="hljs-params">self, arr: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-built_in">max</span> = arr[<span class="hljs-number">0</span>]<br>        cnt = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(arr) - <span class="hljs-number">1</span>):<br>            tmp = <span class="hljs-built_in">sorted</span>(arr[i + <span class="hljs-number">1</span>:])<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">max</span> &lt; tmp[<span class="hljs-number">0</span>]:<br>                <span class="hljs-built_in">max</span> = arr[i + <span class="hljs-number">1</span>]<br>                cnt += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> <span class="hljs-built_in">max</span> &lt; arr[i + <span class="hljs-number">1</span>]:<br>                <span class="hljs-built_in">max</span> = arr[i + <span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">return</span> cnt<br></code></pre></td></tr></table></figure><h2 id="768-2">768</h2><p>好的我们来看到下一道题，这题是上一题的困难版本，除了元素会重复出现以外，数据还非常大，不过我仍然尝试使用769的做法来解了一下题目，结果是通过了，但是花了1400ms左右，可见十分不理想。<br>所以我们需要换一种方法，来降低如此庞大的时间代价。（官方题解时间到）</p><h3 id="单调栈">单调栈</h3><p>由上一题的思路，我们知道如果不能分块，那就是因为右边存在更小的数字，导致现在无法进行分块。<br>那我们思考一个问题，当一个新的数字加入进来后，怎么找出数组变化后的分块方式呢？<br>我们可以使用单调栈来解决这个问题。设置一个栈（单调递增），如果新的数字大于或等于栈顶的数字，说明这个数字可以分成一个独立的块，直接入栈；<br>如果新的数字小于栈顶的数字，那就需要重新分块，直到找到栈中小于等于它的数（另一个块的最大值），此过程保存栈顶的值（倒数第一个块的最大值），然后栈顶数字出栈（块融合）直到满足条件（大于等于栈顶数字）。<br>在此过程中，我们每次留下的都是块中的最大值（栈中的每个数都是它所在分块的最大值），所以最后的块数也就等于栈的长度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxChunksToSorted</span>(<span class="hljs-params">self, arr: [<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        stack = []<br>        <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> arr:<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(stack) == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> a &gt;= stack[-<span class="hljs-number">1</span>]:<br>                stack.append(a)<br>            <span class="hljs-keyword">else</span>:<br>                mx = stack.pop()<br>                <span class="hljs-keyword">while</span> stack <span class="hljs-keyword">and</span> stack[-<span class="hljs-number">1</span>] &gt; a:<br>                    stack.pop()<br>                stack.append(mx)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(stack)<br></code></pre></td></tr></table></figure><h3 id="排序-哈希表">排序+哈希表</h3><p>看了下官方题解发现原来规律总结地不够好。仔细观察就会发现，当前分块的数组中的每个数的出现频率，一定和排好序后的数组中的这部分分块中那些数的出现频率相同。<br>所以我们遍历给定数组，再使用另一个排序后的数组，一个表示元素数量加，另一个表示元素数量减，最后比较元素频率是否相同即可（这里用的字典来比较频率，如果字典里没东西了说明元素频率一致，结果加一即可）。</p><hr>]]></content>
    
    
    <categories>
      
      <category>Solution</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣-817.链表组件</title>
    <link href="/2022/10/12/leetcode-817/"/>
    <url>/2022/10/12/leetcode-817/</url>
    
    <content type="html"><![CDATA[<h1>题目描述</h1><p><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_817_1.png" alt="第一张图"></p><h1>思路及实现</h1><p>看到题目给的组件定义，链表中最长连续节点，该节点的值在所给数组中。那么我们可以利用一个<code>flag</code>来判断这个值是否在数组中，在的话就把<code>flag</code>设置成<code>1</code>，不在的话，再判断此时<code>flag</code>的值是否为<code>1</code>，如果为<code>1</code>说明此处是一个组件的结束处，让组件数量加一即可。<br>当然如果这么写，还需要在循环结束后再检查一次<code>flag</code>的值，确保没有落下最后一个组件。如果不想最后再检查值，可以把判断条件改为值不在数组中。<br>由于在数组中找某个值是否存在的时间复杂度是<code>O(n)</code>，所以我们可以使用<code>set</code>来替代数组，这样可以使搜索值的时间复杂度降到<code>O(1)</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">numComponents</span>(<span class="hljs-params">self, head: <span class="hljs-type">Optional</span>[ListNode], nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        count = <span class="hljs-number">0</span><br>        flag = <span class="hljs-number">0</span><br>        a_set = <span class="hljs-built_in">set</span>(nums)<br>        <span class="hljs-keyword">while</span> head <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">if</span> head.val <span class="hljs-keyword">in</span> a_set:  <span class="hljs-comment"># or: if head.val not in a_set:</span><br>                flag = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> flag == <span class="hljs-number">1</span>:<br>                flag = <span class="hljs-number">0</span><br>                count += <span class="hljs-number">1</span><br>            head = head.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> count <span class="hljs-keyword">if</span> flag == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> count + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>Solution</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣-1790.仅执行一次字符串交换能否使两个字符串相等</title>
    <link href="/2022/10/11/leetcode-1790/"/>
    <url>/2022/10/11/leetcode-1790/</url>
    
    <content type="html"><![CDATA[<h1>题目描述</h1><p><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_1790_1.png" alt="第一张图"></p><h1>思路及实现</h1><p>首先考虑到特殊情况，如果两个字符串相等，那么直接返回True即可。<br>如果不相等，题目所给条件是仅交换一次，顺着这一点我们可以想到，找到需要进行交换的两个位置，如果交换后不相等，返回True即可。<br>在我的代码中使用了变量<code>cnt</code>来寻找字符串中出现不匹配字符的次数，并且用了一个<code>scout</code>来保存第一次找到的不匹配的位置。如果<code>cnt &gt; 1</code>说明有两个地方不匹配了，此时将当前位置与<code>scout</code>位置的元素进行交换，再比较字符串即可知道一次交换是否相等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">areAlmostEqual</span>(<span class="hljs-params">self, s1: <span class="hljs-built_in">str</span>, s2: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-keyword">if</span> s1 == s2:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">else</span>:<br>            cnt = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s1)):<br>                <span class="hljs-keyword">if</span> s1[i] != s2[i]:<br>                    cnt += <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">if</span> cnt &gt; <span class="hljs-number">1</span>:<br>                        s: <span class="hljs-built_in">str</span> = s2[<span class="hljs-number">0</span>: scout] + s2[i] + s2[scout + <span class="hljs-number">1</span>: i] + s2[scout] + s2[i + <span class="hljs-number">1</span>:]<br>                        <span class="hljs-keyword">if</span> s1 == s:<br>                            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>                        <span class="hljs-keyword">else</span>:<br>                            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>                    scout = i<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>其实可以使用两个变量和一组<code>if...elif</code>保存两个位置，<code>else</code>情况则是多于两个位置的字符不同，这种情况一次交换肯定无法导致两个字符串相同，返回<code>False</code>即可。<br>而且这样最后也不需要拼接字符串，只需要判断两个字符串两个位置（<code>s1[i]</code>对<code>s2[j]</code>，<code>s1[j]</code>对<code>s2[i]</code>）的字符是否相同。</p><hr>]]></content>
    
    
    <categories>
      
      <category>Solution</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣-801.使序列递增的最小交换次数</title>
    <link href="/2022/10/11/leetcode-801/"/>
    <url>/2022/10/11/leetcode-801/</url>
    
    <content type="html"><![CDATA[<h1>题目描述</h1><p><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_801_1.png" alt="第一张图"></p><h1>实现</h1><p>今天这个动态规划，不会，摆了.jpg<br>之后看了下官方题解的思路，然后照着思路写了一下代码，下面贴大体思路和代码：<br><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_801_2.png" alt="思路"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minSwap</span>(<span class="hljs-params">self, nums1: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], nums2: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(nums1)<br>        dp0 = [<span class="hljs-number">0</span>] * n<br>        dp1 = [<span class="hljs-number">1</span>] * n<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>            <span class="hljs-keyword">if</span> nums1[i] &gt; nums1[i - <span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> nums2[i] &gt; nums2[i - <span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> nums1[i] &gt; nums2[i - <span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> nums2[i] &gt; nums1[i - <span class="hljs-number">1</span>]:<br>                dp0[i] = <span class="hljs-built_in">min</span>(dp0[i - <span class="hljs-number">1</span>], dp1[i - <span class="hljs-number">1</span>])<br>                dp1[i] = <span class="hljs-built_in">min</span>(dp0[i - <span class="hljs-number">1</span>], dp1[i - <span class="hljs-number">1</span>]) + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> nums1[i] &gt; nums2[i - <span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> nums2[i] &gt; nums1[i - <span class="hljs-number">1</span>]:<br>                dp0[i] = dp1[i - <span class="hljs-number">1</span>]<br>                dp1[i] = dp0[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                dp0[i] = dp0[i - <span class="hljs-number">1</span>]<br>                dp1[i] = dp1[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(dp0[-<span class="hljs-number">1</span>], dp1[-<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><p>还是得多多练习动态规划呜呜</p><hr>]]></content>
    
    
    <categories>
      
      <category>Solution</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣-856.括号的分数</title>
    <link href="/2022/10/09/leetcode-856/"/>
    <url>/2022/10/09/leetcode-856/</url>
    
    <content type="html"><![CDATA[<h1>题目描述</h1><p><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_856_1.png" alt="第一张图"></p><h1>实现</h1><p>哈哈家人们！今天的题目又是找规律（<br>来看题目告诉我们的，再多看看几个例子，我们可以总结出下面的规律：</p><blockquote><p>'()'字符串，就是一个1<br>')('字符串，就是一个+<br>'(('字符串，就是<em>2<br>'))'字符串则是告诉我们，需要从栈中取数出来进行运算，直到进行过</em>运算为止<br>所以我们还需要两个栈，一个用来保存数字，一个用来保存数组。然后遍历题目给我们的字符串即可。当然最后不能忘记把运算符栈清空。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">scoreOfParentheses</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        nums = deque()<br>        ops = deque()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(s)):  <span class="hljs-comment"># 因为每次要读取两个字符，所以从第二个字符开始读</span><br>            <span class="hljs-keyword">if</span> s[i - <span class="hljs-number">1</span>: i + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;()&#x27;</span>:<br>                nums.append(<span class="hljs-built_in">int</span>(<span class="hljs-number">1</span>))<br>            <span class="hljs-keyword">elif</span> s[i - <span class="hljs-number">1</span>: i + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;)(&#x27;</span>:<br>                ops.append(<span class="hljs-string">&#x27;+&#x27;</span>)<br>            <span class="hljs-keyword">elif</span> s[i - <span class="hljs-number">1</span>: i + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;((&#x27;</span>:<br>                nums.append(<span class="hljs-built_in">int</span>(<span class="hljs-number">2</span>))<br>                ops.append(<span class="hljs-string">&#x27;*&#x27;</span>)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">while</span> ops.pop() != <span class="hljs-string">&#x27;*&#x27;</span>:<br>                    nums.append(nums.pop() + nums.pop())<br>                nums.append(nums.pop() * nums.pop())<br>        <span class="hljs-keyword">while</span> ops:<br>            ops.pop()<br>            nums.append(nums.pop() + nums.pop())<br>        <span class="hljs-keyword">return</span> nums.pop()<br></code></pre></td></tr></table></figure><h2 id="（一看题解又是被薄纱，无论是编程思维还是数学思维这块还是不如人家，把这个想成树也是厉害，用dfs出答案。）">（一看题解又是被薄纱，无论是编程思维还是数学思维这块还是不如人家，把这个想成树也是厉害，用dfs出答案。）</h2>]]></content>
    
    
    <categories>
      
      <category>Solution</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣-870.优势洗牌</title>
    <link href="/2022/10/08/leetcode-870/"/>
    <url>/2022/10/08/leetcode-870/</url>
    
    <content type="html"><![CDATA[<h1>题目描述</h1><p><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_870_1.png" alt="第一张图"></p><h1>思路及实现</h1><p>根据题目我们很容易想到用贪心解决问题。即每次取<code>nums1</code>中最小的数字跟<code>nums2</code>中的比较。可以将<code>nums1</code>按升序排序，用另一个数组<code>reslut</code>保存结果。<br>最开始无脑写的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">advantageCount</span>(<span class="hljs-params">self, nums1: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], nums2: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        nums1.sort()<br>        result: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>] = []<br>        <span class="hljs-keyword">for</span> num2 <span class="hljs-keyword">in</span> nums2:<br>            <span class="hljs-keyword">for</span> i, num1 <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums1):<br>                <span class="hljs-keyword">if</span> num1 &gt; num2:<br>                    nums1.remove(num1)<br>                    result.append(num1)<br>                    <span class="hljs-keyword">break</span><br>                <span class="hljs-keyword">elif</span> i == <span class="hljs-built_in">len</span>(nums1) - <span class="hljs-number">1</span>:  <span class="hljs-comment"># 没有大于数组2当前数字的数字了</span><br>                    result.append(nums1.pop(<span class="hljs-number">0</span>))<br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><p>超时，好的，我就知道（怕不怕我10^5长度的数组）。重新想过后，确实有更好的方法，原理不变，也是贪心，但是对两个数组都进行排序，并“浪费”点空间，创建一些辅助数组。<br>我们对数组1进行遍历，对<code>nums2</code>则是利用一下双指针。当<code>nums1</code>的数大于<code>nums2</code>的数时，由于我们已经排过序，那么此时肯定满足优势最大化，因为<code>nums1</code>之后的数都会比当前数大了，所以直接进行配对就行。<br>如果小于的话，那这个数也小于<code>nums2</code>之后的数，所以就把这个数丢给<code>nums2</code>中最大的数，也就是尾指针指向的数。<br>其实难点在于怎么保持原来的顺序输出，也就是下标问题。由于<code>sort()</code>函数接受一个<code>key</code>参数，而这个参数会将接收到的数据用于排序的关键，所以可以利用这点来排序下标数组，以保证最后的输出。<br>由于我们的数是一一对应的，所以不必担心重复访问，也就是说，我们可以直接对<code>nums2</code>数组进行修改，并返回它。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">advantageCount</span>(<span class="hljs-params">self, nums1: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], nums2: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        len2 = <span class="hljs-built_in">len</span>(nums2)<br>        index2 = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(len2))<br>        index2.sort(key=<span class="hljs-keyword">lambda</span> x: nums2[x])<br>        nums1.sort()<br>        head = <span class="hljs-number">0</span><br>        tail = len2 - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums1:  <span class="hljs-comment"># 遍历数组1</span><br>            <span class="hljs-keyword">if</span> num &gt; nums2[index2[head]]:<br>                nums2[index2[head]] = num<br>                head += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                nums2[index2[tail]] = num<br>                tail -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> nums2<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>Solution</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣-450.删除二叉搜索树中的节点</title>
    <link href="/2022/10/07/leetcode-450/"/>
    <url>/2022/10/07/leetcode-450/</url>
    
    <content type="html"><![CDATA[<h1>题目描述</h1><p><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_450_1.png" alt="第一张图"><br><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_450_2.png" alt="第二张图"></p><h1>思路和实现</h1><p>二叉搜索树，即二叉查找树，Binary Search Tree，简称BST。在BST中，给定节点左子树里的节点会小于给定节点，而右子树里的节点会大于给定节点。<br>那么我们需要在满足约束的情况下进行删除，就需要特别的策略，以下给出我的策略的描述：（P.S：看题目的示例有两种答案，那么你也应该知道策略不止一种）</p><blockquote><p>迭代找到要删除的节点，以及它的父节点<br>如果被删除的节点有左右子树，那么应该用被删除节点的左子树的最大元素节点来替代这个被删除节点</p><blockquote><p>根据BST的约束，我们可以知道被删除节点的左子树中的最大元素节点应该是该子树最右边的节点，迭代找出这个节点和它的父节点<br>如果这个最大元素节点就是被删除节点的左子节点，那么需要把该左子节点的左子节点挂在它的父节点的左子节点上<br>如果这个最大元素节点不是被删除节点的左子节点，那么要把这个最大元素节点的父节点的右子节点指向该最大元素节点的左子节点<br>上述操作完成后，将该最大元素节点左右子树的引用改为删除节点左右子树的引用<br>如果被删除的节点只有左子树或者右子树，那么只需要把被删除节点的父节点指向被删除节点的引用指向这个被删除节点的左子树或右子树即可<br>如果被删除的节点没有左右子树，把它的父节点指向它的引用改为None即可<br>最开始的实现：</p></blockquote></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode:</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">deleteNode</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode], key: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:<br>        current, parent = root, <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">while</span> current <span class="hljs-keyword">and</span> current.val != key:  <span class="hljs-comment"># 找到要删除的节点，以及它的父节点</span><br>            parent = current<br>            current = current.left <span class="hljs-keyword">if</span> current.val &gt; key <span class="hljs-keyword">else</span> current.right<br>        <span class="hljs-keyword">if</span> current <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:  <span class="hljs-comment"># 不存在该节点</span><br>            <span class="hljs-keyword">return</span> root<br>        <span class="hljs-keyword">elif</span> current.left <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> current.right <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:  <span class="hljs-comment"># 如果被删除节点拥有左右子节点，找到左子树中的最大节点current</span><br>            successor, successor_parent = current.left, current<br>            <span class="hljs-keyword">while</span> successor.right:  <span class="hljs-comment"># 遍历到最右后，就找到了最大节点</span><br>                successor_parent = successor<br>                successor = successor.right<br>            <span class="hljs-keyword">if</span> successor_parent.val == current.val:  <span class="hljs-comment"># 如果这个最大元素节点就是被删除节点的左子节点，那么需要把该左子节点的左子节点挂在它父节点的左子节点上</span><br>                successor_parent.left = successor.left<br>            <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 如果这个最大元素节点不是被删除节点的左子节点，那么要把这个最大元素节点的父节点的右子节点指向该最大元素节点的左子节点</span><br>                successor_parent.right = successor.left<br>            successor.left = current.left<br>            successor.right = current.right<br>            current = successor<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">if</span> current.left <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                current = current.right<br>            <span class="hljs-keyword">elif</span> current.right <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                current = current.left<br>            <span class="hljs-keyword">else</span>:<br>                current = <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">if</span> parent <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> current<br>        <span class="hljs-keyword">elif</span> parent.left <span class="hljs-keyword">and</span> parent.left.val == key:<br>            parent.left = current<br>        <span class="hljs-keyword">else</span>:<br>            parent.right = current<br>        <span class="hljs-keyword">return</span> root<br></code></pre></td></tr></table></figure><p>优化后：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">deleteNode</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode], key: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:<br>        current, parent = root, <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">while</span> current <span class="hljs-keyword">and</span> current.val != key:<br>            parent = current<br>            current = current.left <span class="hljs-keyword">if</span> current.val &gt; key <span class="hljs-keyword">else</span> current.right<br>        <span class="hljs-keyword">if</span> current <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> root<br>        <span class="hljs-keyword">if</span> current.left <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> current.right <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            current = <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">elif</span> current.left <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            current = current.right<br>        <span class="hljs-keyword">elif</span> current.right <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            current = current.left<br>        <span class="hljs-keyword">else</span>:<br>            successor, successor_parent = current.left, current<br>            <span class="hljs-keyword">while</span> successor.right:<br>                successor_parent = successor<br>                successor = successor.right<br>            <span class="hljs-keyword">if</span> successor_parent.val == current.val:<br>                successor_parent.left = successor.left<br>            <span class="hljs-keyword">else</span>:<br>                successor_parent.right = successor.left<br>            successor.left = current.left<br>            successor.right = current.right<br>            current = successor<br>        <span class="hljs-keyword">if</span> parent <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> current<br>        <span class="hljs-keyword">elif</span> parent.left <span class="hljs-keyword">and</span> parent.left.val == key:<br>            parent.left = current<br>        <span class="hljs-keyword">else</span>:<br>            parent.right = current<br>        <span class="hljs-keyword">return</span> root<br></code></pre></td></tr></table></figure><h1>题外话</h1><p>基础不牢地动山摇。属实是把我干碎了，树和图掌握得依然不行，还得找时间补习。</p><hr>]]></content>
    
    
    <categories>
      
      <category>Solution</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Leetcode</tag>
      
      <tag>二叉搜索树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣-1800.最大升序子数组和</title>
    <link href="/2022/10/07/leetcode-1800/"/>
    <url>/2022/10/07/leetcode-1800/</url>
    
    <content type="html"><![CDATA[<h1>题目描述</h1><p><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_1800_1.png" alt="第一张图"></p><h1>思路和实现</h1><p>其实就是遍历一遍题目所给数组，使用一个<code>max_sum</code>保存当前最大和，<code>tmp_sum</code>保存当前子数组和，将当前元素和下个元素（若存在）进行比较，如果大于下个元素，说明该升序子数组结束，并和当前最大升序子数组元素和进行比较，否则计入当前子数组和。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxAscendingSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        max_sum: <span class="hljs-built_in">int</span> = <span class="hljs-number">0</span>  <span class="hljs-comment"># 当前最大和</span><br>        tmp_sum: <span class="hljs-built_in">int</span> = <span class="hljs-number">0</span>  <span class="hljs-comment"># 当前子数组和</span><br>        <span class="hljs-keyword">for</span> i, num <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):<br>            <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; <span class="hljs-built_in">len</span>(nums) <span class="hljs-keyword">and</span> num &gt;= nums[i + <span class="hljs-number">1</span>]) <span class="hljs-keyword">or</span> i + <span class="hljs-number">1</span> &gt;= <span class="hljs-built_in">len</span>(nums):  <span class="hljs-comment"># 当前元素大于下个元素，或没有下个元素，该升序子数组结束</span><br>                tmp_sum += num<br>                max_sum = <span class="hljs-built_in">max</span>(max_sum, tmp_sum)<br>                tmp_sum = <span class="hljs-number">0</span>  <span class="hljs-comment"># 重置临时子数组和</span><br>            <span class="hljs-keyword">elif</span> i + <span class="hljs-number">1</span> &lt; <span class="hljs-built_in">len</span>(nums):  <span class="hljs-comment"># 当前元素小于下个元素，后面的条件可省略不写</span><br>                tmp_sum += num<br>        <span class="hljs-keyword">return</span> max_sum<br></code></pre></td></tr></table></figure><p>（看完官方题解后：寄！以后要改掉我喜欢往后看的思想了！）<br>（没碰过动态规划的我：？这是什么.JPG）</p><hr>]]></content>
    
    
    <categories>
      
      <category>Solution</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣-927.三等分</title>
    <link href="/2022/10/06/leetcode-927/"/>
    <url>/2022/10/06/leetcode-927/</url>
    
    <content type="html"><![CDATA[<h1>题目描述</h1><p><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_927_1.png" alt="第一张图"></p><h1>实现</h1><p>今天一看题目，坏了家人们，怎么是纯数学题啊（悲），这下不会了。<br>那既然是数学题，那就要仔细分析题目了。<br>首先，题目是将数组分为3个非空的部分，所有这些部分表示相同的二进制值，数组只存在0和1两个表示二进制的数字。<br>分析下示例，可以看到我们应该把重点放在1这个数字上，并且分情况讨论：</p><ol><li>如果可以做到，那么数组其中的1的个数应该能被3整除，并且得到的3个部分中，1的个数应一致。</li><li>特殊情况，没有一个1，即数组全是0的情况，我们只要随意给出一个合理答案即可，如[0,2]。<br>那么我们知道数组中可能存在解后，要怎么得到这个解呢？其实就是逐一比较。虽然数组中存在前导0，但是我们完全可以避开它，因为我们把重点放在了1上。无论有几个前导0，我们只要从每个数字的第一个1开始比较就不会受前导0影响。<br>知道了从每个部分的第一个1开始比较后，我们的重点就转变为了怎么找到每个部分第一个1在数组中的位置。前面提到，如果存在解，那么每个部分的1的个数是一致的。我们可以遍历数组，并使用一个计数器来帮助确定每个部分的1的位置。举个例子：</li></ol><blockquote><p>假设给出数组[1,1,0,0,1,1,0,1,1]，我们可以得知其中1的个数为6，那么每个部分包含的1的个数应该为：6/3 == 2。<br>遍历数组，cnt开始设为0，如果遇到了1，那么进行判断，cnt为0，那么当前位置就是第一部分第一个1的位置，如果cnt为2，那么就是第二个部分第一个1的位置，如果cnt为4，那么就是第三部分第一个1的位置，最后cnt++。<br>现在我们得到了每个部分第一个1的位置，接下来要做的就是进行比较了。同样是遍历数组，一直比到数组越界都一致的话，我们就得到了解。否则无解。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">threeEqualParts</span>(<span class="hljs-params">self, arr: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        nums = arr.count(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 统计1出现的次数</span><br>        <span class="hljs-keyword">if</span> nums == <span class="hljs-number">0</span>:  <span class="hljs-comment"># 数组中全0，返回一个合理答案即可</span><br>            <span class="hljs-keyword">return</span> [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>]<br>        <span class="hljs-keyword">elif</span> nums % <span class="hljs-number">3</span> != <span class="hljs-number">0</span>:  <span class="hljs-comment"># 1的个数无法被3整除，返回无解</span><br>            <span class="hljs-keyword">return</span> [-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>]<br>        cnt = index1 = index2 = index3 = <span class="hljs-number">0</span>  <span class="hljs-comment"># 辅助变量</span><br>        ones_cnt = nums // <span class="hljs-number">3</span>  <span class="hljs-comment"># 每个部分1的个数</span><br>        <span class="hljs-keyword">for</span> index, item <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(arr):<br>            <span class="hljs-keyword">if</span> item:  <span class="hljs-comment"># 如果item是1</span><br>                <span class="hljs-keyword">if</span> cnt == <span class="hljs-number">0</span>:<br>                    index1 = index  <span class="hljs-comment"># 第一部分第一个1的位置</span><br>                <span class="hljs-keyword">elif</span> cnt == ones_cnt:<br>                    index2 = index  <span class="hljs-comment"># 第二部分第一个1的位置</span><br>                <span class="hljs-keyword">elif</span> cnt == <span class="hljs-number">2</span> * ones_cnt:<br>                    index3 = index  <span class="hljs-comment"># 第三部分第一个1的位置</span><br>                cnt += <span class="hljs-number">1</span>  <span class="hljs-comment"># 找到的1的个数增加</span><br>        <span class="hljs-keyword">while</span> index3 + <span class="hljs-number">1</span> &lt; <span class="hljs-built_in">len</span>(arr):<br>            <span class="hljs-keyword">if</span> arr[index1 + <span class="hljs-number">1</span>] != arr[index2 + <span class="hljs-number">1</span>]  <span class="hljs-keyword">or</span> arr[index1 + <span class="hljs-number">1</span>] != arr[index3 + <span class="hljs-number">1</span>]:  <span class="hljs-comment"># 匹配失败，返回无解</span><br>                <span class="hljs-keyword">return</span> [-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>]<br>            index1 += <span class="hljs-number">1</span><br>            index2 += <span class="hljs-number">1</span><br>            index3 += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> [index1, index2 + <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Solution</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣-811.子域名访问计数</title>
    <link href="/2022/10/05/leetcode-811/"/>
    <url>/2022/10/05/leetcode-811/</url>
    
    <content type="html"><![CDATA[<h1>题目描述</h1><p><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_811_1.png" alt="第一张图"></p><h1>实现</h1><p>我是这么想的，每个字符串都使用两次<code>spilt()</code>方法进行字符串的提取，第一次分隔符为<code>&quot; &quot;</code>，第二次则为<code>&quot;.&quot;</code>，这样，我们第一次提取出来的就是访问次数和访问域名，第二次则是提取子域名和父域名。<br>然后把所有东西都塞进哈希表（字典）里，<code>Key</code>为域名，<code>Value</code>为访问次数。如果哈希表存在该域名就直接加访问次数，否则就创建一个新键值对并加上访问次数。<br>程序应该是二重循环，要遍历一次传入的字符串数组，还要遍历第二次使用<code>spilt()</code>得到的域名。<br>关于输出格式，同样的用一个字符串数组保存结果，遍历字典，字符串格式为：<code>Value + &quot; &quot; + Key</code>。<br>然后我的第一遍实现（代码未优化）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">subdomainVisits</span>(<span class="hljs-params">self, cpdomains: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:<br>        result: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>] = <span class="hljs-built_in">list</span>()<br>        a_dict = <span class="hljs-built_in">dict</span>()<br>        <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> cpdomains:  <span class="hljs-comment"># 遍历给定数组</span><br>            tmp = s.split(<span class="hljs-string">&quot; &quot;</span>)<br>            count = <span class="hljs-built_in">int</span>(tmp[<span class="hljs-number">0</span>])<br>            domains = tmp[<span class="hljs-number">1</span>].split(<span class="hljs-string">&quot;.&quot;</span>)<br>            <span class="hljs-keyword">for</span> i, domain <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(domains):  <span class="hljs-comment"># 遍历域名</span><br>                <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(domains)):  <span class="hljs-comment"># 拼接域名</span><br>                    domain = domain + <span class="hljs-string">&quot;.&quot;</span> + domains[j]<br>                <span class="hljs-keyword">if</span> domain <span class="hljs-keyword">in</span> a_dict:<br>                    a_dict[domain] += count<br>                <span class="hljs-keyword">else</span>:<br>                    a_dict[domain] = count<br>        <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> a_dict.items():<br>            result.append(<span class="hljs-built_in">str</span>(v) + <span class="hljs-string">&quot; &quot;</span> + k)<br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><p>好，写完发现我怎么用了三重循环，哦，原来是自己光记着把域名拆开没记着把域名拼起来才行了。<br>然后是官方题解：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">subdomainVisits</span>(<span class="hljs-params">self, cpdomains: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:<br>        cnt = Counter()<br>        <span class="hljs-keyword">for</span> domain <span class="hljs-keyword">in</span> cpdomains:<br>            c, s = domain.split()<br>            c = <span class="hljs-built_in">int</span>(c)<br>            cnt[s] += c<br>            <span class="hljs-keyword">while</span> <span class="hljs-string">&#x27;.&#x27;</span> <span class="hljs-keyword">in</span> s:<br>                s = s[s.index(<span class="hljs-string">&#x27;.&#x27;</span>) + <span class="hljs-number">1</span>:]<br>                cnt[s] += c<br>        <span class="hljs-keyword">return</span> [<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;c&#125;</span> <span class="hljs-subst">&#123;s&#125;</span>&quot;</span> <span class="hljs-keyword">for</span> s, c <span class="hljs-keyword">in</span> cnt.items()]<br></code></pre></td></tr></table></figure><p>我草，好嗯必，他用的是<code>Counter</code>，直接在知道格式的情况下利用<code>spilt</code>返回两个值就完事了，他用<code>while</code>循环检查<code>'.'</code>在不在域名字符串里，返回语句更是上列表解析式，我草，太嗯必了，薄纱我这种垃圾代码好吧。。。</p><hr>]]></content>
    
    
    <categories>
      
      <category>Solution</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣-2.两数相加</title>
    <link href="/2022/10/04/leetcode-2/"/>
    <url>/2022/10/04/leetcode-2/</url>
    
    <content type="html"><![CDATA[<h1>题目描述</h1><p><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_2_1.png" alt="第一张图"></p><h1>实现</h1><p>什么额外要求都没有，也没让你把数字正序输出拼起来，那就直接简单遍历喽</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addTwoNumbers</span>(<span class="hljs-params">self, l1: <span class="hljs-type">Optional</span>[ListNode], l2: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        head: ListNode = ListNode()<br>        scout: ListNode = head<br>        c_flag: <span class="hljs-built_in">int</span> = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> l1 <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> l2 <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:  <span class="hljs-comment"># 遍历l1和l2</span><br>            tmp: ListNode = ListNode()<br>            num1 = l1.val <span class="hljs-keyword">if</span> l1 <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br>            num2 = l2.val <span class="hljs-keyword">if</span> l2 <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br>            <span class="hljs-keyword">if</span> num1 + num2 + c_flag &gt;= <span class="hljs-number">10</span>:  <span class="hljs-comment"># 产生进位，要把进位标志设置成1</span><br>                tmp.val = num1 + num2 + c_flag - <span class="hljs-number">10</span><br>                c_flag = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 没有进位，把进位标志设置成0</span><br>                tmp.val = num1 + num2 + c_flag<br>                c_flag = <span class="hljs-number">0</span><br>            scout.<span class="hljs-built_in">next</span> = tmp<br>            scout = tmp<br>            l1 = <span class="hljs-literal">None</span> <span class="hljs-keyword">if</span> l1 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> l1.<span class="hljs-built_in">next</span>  <span class="hljs-comment"># l1和l2若是还有后续，那就取后续，如果没有就要设置成None</span><br>            l2 = <span class="hljs-literal">None</span> <span class="hljs-keyword">if</span> l2 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> l2.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">if</span> c_flag == <span class="hljs-number">1</span>:  <span class="hljs-comment"># 不要忘了遍历结束后，进位标志如果是1的话，还要加个最高位</span><br>            scout.<span class="hljs-built_in">next</span> = ListNode(<span class="hljs-number">1</span>, <span class="hljs-literal">None</span>)<br><br>        <span class="hljs-keyword">return</span> head.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure><p>千万别忘记遍历结束还要检查进位标志啊家人们，第一次交我直接漏了一个1没输出，执行示例那里看错了把预期结果看成我的输出我还以为没错TvT</p><blockquote><p>执行用时：56 ms, 在所有 Python3 提交中击败了87.89%的用户<br>内存消耗：15.1 MB, 在所有 Python3 提交中击败了26.41%的用户<br><s>打不过，告辞.jpg</s></p></blockquote><hr>]]></content>
    
    
    <categories>
      
      <category>Solution</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣-921.使括号有效的最少添加</title>
    <link href="/2022/10/04/leetcode-921/"/>
    <url>/2022/10/04/leetcode-921/</url>
    
    <content type="html"><![CDATA[<h1>题目描述</h1><p><img src="http://imagehost.map1e-g.cn/Leetcode/leetcode_921_1.png" alt="第一张图"><br>这个题目描述我只能说呃呃，其实就是括号匹配成立问题。再丢个实例就很明白了：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">Input:</span> s = <span class="hljs-string">&quot;()))((&quot;</span><br><span class="hljs-symbol">Output:</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h1>实现</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minAddToMakeValid</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        flag = <span class="hljs-number">0</span><br>        result = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> bracket <span class="hljs-keyword">in</span> s[::-<span class="hljs-number">1</span>]:<br>            <span class="hljs-keyword">if</span> bracket == <span class="hljs-string">&#x27;(&#x27;</span> <span class="hljs-keyword">and</span> flag &gt; <span class="hljs-number">0</span>:<br>                flag -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> bracket == <span class="hljs-string">&#x27;(&#x27;</span>:<br>                result += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                flag += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> result + flag<br></code></pre></td></tr></table></figure><blockquote><p>执行用时：44 ms, 在所有 Python3 提交中击败了17.39%的用户<br>内存消耗：14.9 MB, 在所有 Python3 提交中击败了78.09%的用户<br>只能说不是很理想捏~<br>典型的<s>(简单)</s>贪心，上面代码我还把字符串反过来了，其实并不需要，但是<s>我比较笨</s>。</p></blockquote><h1>小声嘀咕</h1><p>我趣家人们，少一个切片操作直接：</p><blockquote><p>执行用时：36 ms, 在所有 Python3 提交中击败了74.09%的用户<br>内存消耗：14.8 MB, 在所有 Python3 提交中击败了的用户<br>我是珍珠啊<br><s>可恶我甚至看见了一个利用<code>replace</code>逃课的方法，这么做真的是太可恶了！</s></p></blockquote><hr>]]></content>
    
    
    <categories>
      
      <category>Solution</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux学习笔记1</title>
    <link href="/2022/10/04/linux-learning-1/"/>
    <url>/2022/10/04/linux-learning-1/</url>
    
    <content type="html"><![CDATA[<h1>想说的话</h1><p>本系列文章可能不会是你所期待的文章，在阅读的时候你可能会觉得该文章的问题包括但不限于：抽象、错误、跳跃，是因为我在写该系列文章的时候并没有像之前其他系列文章那样做。<br>该系列文章更多的是我对书中知识的大概概括。<br>阅读该系列文章可能会需要一定编程基础。<br>敬请谅解。</p><h1>第一章 入门</h1><h2 id="命令"><code>./</code>命令</h2><p>例子：<code>./hello</code><br>特别指示shell去执行当前目录下给定的名称的程序</p><h2 id="gcc命令"><code>gcc</code>命令</h2><p><code>-I + 位置</code><br>例子：<code>gcc -I/usr/openwin/include fred.c</code><br>查找包含保存在子目录或非标准位置中的头文件</p><h2 id="命令的简写">命令的简写</h2><p><code>gcc -o fred fred.c /usr/lib/libm.a</code>可以写成<code>gcc -o fred fred.c -lm</code><br>l == lib, m == 函数库名,即：<code>-l + 函数库名</code></p><h2 id="L-位置"><code>-L + 位置</code></h2><p>例子：<code>gcc -o x11fred -L/usr/openwin/lib x11fred.c -lX11</code><br>为编译器增加库的搜索路径</p><h2 id="c"><code>-c</code></h2><p>作用是阻止编译器创建一个完整的程序(一般情况下输出一个<code>.o</code>文件</p><h2 id="ar程序"><code>ar</code>程序</h2><p>例子：<code>ar crv libfoo.a bill.o fred.o</code><br>将若干单独的文件归并到一个大的文件中以创建归档文件或集合</p><h2 id="grep命令"><code>grep</code>命令</h2><p>搜索包含某些特定定义和函数原型的头文件<br>例子：<code>grep EXIT_ *.h</code><br>在当前目录下的所有以<code>.h</code>结尾的文件中搜索字符串<code>EXIT_</code>。</p><h2 id="nm命令"><code>nm</code>命令</h2><p>查看哪些函数被包含在目标文件、函数库或可执行文件里。</p><h2 id="Linux和Windows环境下的文件格式区分">Linux和Windows环境下的文件格式区分</h2><p>第一行为在Linux环境下对应的文件格式，第二行则是在Windows环境下产生的文件格式。</p><table><thead><tr><th style="text-align:center">目标模块</th><th style="text-align:center">静态函数库</th><th style="text-align:center">程序</th></tr></thead><tbody><tr><td style="text-align:center">func.o</td><td style="text-align:center">lib.a</td><td style="text-align:center">program</td></tr><tr><td style="text-align:center">FUNC.OBJ</td><td style="text-align:center">LIB.LIB</td><td style="text-align:center">PROGRAM.EXE</td></tr></tbody></table><h2 id="man命令"><code>man</code>命令</h2><p>例子：<code>man gcc</code><br>访问在线手册页，按空格键读下一页，按<code>Enter/Return</code>键读下一行，按<code>q</code>退出。</p><h2 id="info命令"><code>info</code>命令</h2><p>GNU软件使用的在线文档系统，按下<code>Ctrl+H</code>以获得帮助信息。</p><h1>第二章 Shell程序设计</h1><h2 id="2-1-重定向输出">2.1 重定向输出</h2><p>文件描述符0代表一个程序的标准输入，文件描述符1代表标准输出，2代表标准错误输出。</p><h3 id="操作符"><code>&gt;</code>操作符</h3><p>例子：<code>ls -l &gt; lsoutput.txt</code><br>把命令的输出保存到文件中。如果文件已存在则覆盖，可使用命令<code>set -o noclobber</code>或<code>set -C</code>设置<code>noclobber</code>选项，从而阻止重定向操作对一个已有文件的覆盖。可以使用<code>set +o noclobber</code>命令取消该选项。</p><h3 id="操作符-2"><code>&gt;&gt;</code>操作符</h3><p>例子：<code>ps &gt;&gt; lsoutput.txt</code><br>把命令的输出附加到指定文件的尾部。</p><h3 id="2"><code>2&gt;</code></h3><p>例子：<code>kill -HUP 1234 &gt;killout.txt 2&gt;killerr.txt</code><br>对标准错误输出进行重定向。当需要丢弃错误信息并阻止它显示在屏幕上时，这个方法很有用(比如一些错误无伤大雅，不需要弹框提示，但是应该把它写进去log)。<br>在上面的例子中，标准输出和标准错误输出分别被重定向到不同的文件中了。<br><code>kill -1 1234 &gt;killouterr.txt 2&gt;&amp;1</code><br>两组输出都被重定向到一个文件中了。 <code>&gt;&amp;</code>操作符可以结合两个输出。</p><h3 id="dev-null"><code>&gt;/dev/null</code></h3><p>例子：<code>kill -l 1234 &gt;/dev/null 2&gt;&amp;1</code><br>丢弃输出。</p><h3 id="操作符-3"><code>|</code>操作符</h3><p>例子：<code>ps &gt; psout.txt</code><br>你可以用管道操作符<code>|</code>来连接进程。<br>比如<code>sort psout.txt &gt; pssort.out</code>可以写成：<code>ps | sort &gt; pssort.out</code></p><h2 id="2-2-编写第一个脚本">2.2 编写第一个脚本</h2><p>假设现在我们已经编写好了一个脚本文件<code>first</code>，我们可以这样使用：<code>/bin/sh first</code><br>看上去很麻烦，可以用<code>chmod</code>命令来改变这个文件的模式：<code>chmod +x first</code><br>然后就可以使用<code>first</code>(配置过环境变量PATH)或者<code>./first</code>(推荐)执行了。</p><h2 id="2-3-shell的语法">2.3 shell的语法</h2><h3 id="2-3-1-变量">2.3.1 变量</h3><p>创建变量：<code>x=1</code>(在默认情况下，所有变量都被看作字符串并以字符串来存储。shell和一些工具程序会在需要时把数值型字符串转换为对应的数值以对它们进行操作。)<br>访问变量：通过在变量名前加一个<code>$</code>符号来访问它的内容。<br>例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">salutation=Hello</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$salutation</span></span><br>Hello<br></code></pre></td></tr></table></figure><p>注意，如果字符串里包含空格，就必须用引号把它们括起来。此外，等号两边不能有空格。</p><h4 id="read命令">read命令</h4><p>例子：<code>read salutation</code><br>将用户的输入赋值给一个变量。</p><h4 id="引号的使用">引号的使用</h4><p>变量在引号中的行为取决于你所使用的引号类型。如果把<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>变量表达式放在双引号中，程序执行到这一行时就会把变量替换为它的值；如果放在单引号中，就不会替换。在</mtext><mi mathvariant="normal">‘</mi></mrow><annotation encoding="application/x-tex">变量表达式放在双引号中，程序执行到这一行时就会把变量替换为它的值；如果放在单引号中，就不会替换。在`</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord cjk_fallback">变量表达式放在双引号中，程序执行到这一行时就会把变量替换为它的值；如果放在单引号中，就不会替换。在</span><span class="mord">‘</span></span></span></span><code>前面加上一个</code>`字符会取消<code>$</code>的特殊含义。</p><h4 id="环境变量">环境变量</h4><p>当一个shell脚本程序开始执行时，一些变量会根据环境设置中的值进行初始化。下面列举一些主要的变量：</p><table><thead><tr><th style="text-align:center">环境变量</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>$HOME</code></td><td style="text-align:center">当前用户的家目录</td></tr><tr><td style="text-align:center"><code>$PATH</code></td><td style="text-align:center">以冒号分隔的用来搜索命令的目录列表</td></tr><tr><td style="text-align:center"><code>$PS1</code></td><td style="text-align:center">命令提示符，通常是<code>$</code>字符，但在bash中，你可以使用一些更复杂的值。例如，字符串<code>[\u@\h\W]$</code>就是一个流行的默认值，它给出用户名、机器名和当前目录名，当然也包括一个<code>$</code>提示符</td></tr><tr><td style="text-align:center"><code>$PS2</code></td><td style="text-align:center">二级提示符，用来提示后续的输入，通常是<code>&gt;</code>字符</td></tr><tr><td style="text-align:center"><code>$IFS</code></td><td style="text-align:center">输入域分隔符。当shell读取输入时，它给出用来分隔单词的一组字符，它们通常是空格、制表符和换行符</td></tr><tr><td style="text-align:center"><code>$0</code></td><td style="text-align:center">shell脚本的名字</td></tr><tr><td style="text-align:center"><code>$#</code></td><td style="text-align:center">传递给脚本的参数个数</td></tr><tr><td style="text-align:center"><code>$$</code></td><td style="text-align:center">shell脚本的进程号，脚本程序通常会用它来生成一个唯一的临时文件如<code>/tmp/tmpfile_$$</code></td></tr></tbody></table><h4 id="参数变量">参数变量</h4><p>如果脚本程序在调用时带有参数，一些额外的变量就会被创建。</p><blockquote><p>即使没有传递任何参数，环境变量<code>$#</code>也依然存在，只不过它的值时0罢了。<br>例子：<code>$ ./try_var foo bar baz</code><br>|参数变量|说明|<br>|:----:|:----:|<br>|<code>$1, $2, ...</code>|脚本程序的参数|<br>|<code>$*</code>|在一个变量中列出所有的参数，各个参数之间用环境变量<code>IFS</code>中的第一个字符分隔开。如果<code>IFS</code>被修改了，那么<code>$#</code>将命令行分割为参数的方式就将随之改变|<br>|<code>$@</code>|它是<code>$*</code>的一种变体，它不使用<code>IFS</code>环境变量，所以即使<code>IFS</code>为空，参数也不会挤在一起|</p></blockquote><h3 id="2-3-2-条件">2.3.2 条件</h3><h4 id="test或-命令"><code>test</code>或<code>[</code>命令</h4><p>例子：检查一个文件是否存在</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Shell">if test -f fred.c<br>then<br>...<br>else<br>...<br>fi<br></code></pre></td></tr></table></figure><p>或者写成：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Shell">if [ -f fred.c ]<br>then<br>...<br>else<br>...<br>fi<br></code></pre></td></tr></table></figure><p>注意要在[符号和被检查的条件之间留出空格。<br>可以把<code>if</code>和<code>then</code>放在同一行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Shell">if [ -f fred.c ]; then  <br>...<br>fi<br></code></pre></td></tr></table></figure><p><code>test</code>命令可以使用的条件类型可以归为三类：字符串比较、算数比较和与文件有关的条件测试。</p><h3 id="2-3-3控制结构">2.3.3控制结构</h3><h4 id="if…elif…else语句">if…elif…else语句</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Shell">if condition<br>then<br>    statements<br>elif condition<br>then<br>    statements<br>else<br>    statements<br>fi<br></code></pre></td></tr></table></figure><h4 id="for语句">for语句</h4><p>我们可以用for结构来循环处理一组值，这组值可以是任意字符串的集合。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Shell">for variable in values<br>do<br>    statements<br>done<br></code></pre></td></tr></table></figure><p>例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Shell">for foo in bar fud 43<br>do<br>    echo $foo<br>done<br>exit 0<br></code></pre></td></tr></table></figure><h4 id="while语句">while语句</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Shell">while condition<br>do<br>    statements<br>done<br></code></pre></td></tr></table></figure><h4 id="until语句">until语句</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Shell">until condition<br>do<br>    statements<br>done<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>Learning Log</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣-13.两数之和</title>
    <link href="/2022/10/01/leetcode-1/"/>
    <url>/2022/10/01/leetcode-1/</url>
    
    <content type="html"><![CDATA[<h1>题目描述</h1><p>（如果看不到的话就去力扣吧）<br><img src="https://s1.ax1x.com/2022/10/01/xK6wo6.png" alt="第一张图"></p><h1>实现</h1><h2 id="暴力枚举">暴力枚举</h2><p>不用动脑子，直接遍历！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums), <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i, <span class="hljs-built_in">len</span>(nums), <span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> nums[i] + nums[j] == target:<br>                    <span class="hljs-keyword">return</span> [i, j]<br></code></pre></td></tr></table></figure><h2 id="字典查找">字典查找</h2><p>在字典里边查找值，这样可以防止重复遍历。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        a_dict = <span class="hljs-built_in">dict</span>()<br>        <span class="hljs-keyword">for</span> i, num <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):<br>            <span class="hljs-keyword">if</span> target - num <span class="hljs-keyword">in</span> a_dict:  <span class="hljs-comment"># in是在字典中存不存在对应key</span><br>                <span class="hljs-keyword">return</span> [a_dict[target - num], i]<br>            a_dict[nums[i]] = i<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>Solution</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣-13.罗马数字转整数</title>
    <link href="/2022/09/30/leetcode-13/"/>
    <url>/2022/09/30/leetcode-13/</url>
    
    <content type="html"><![CDATA[<h1>题目描述</h1><p>（如果看不到的话就去力扣吧）<br><img src="https://s1.ax1x.com/2022/10/01/xK6BFK.png" alt="第一张图"><br><img src="https://s1.ax1x.com/2022/10/01/xK6ddx.png" alt="第二张图"></p><h1>实现</h1><p>其实自己并没有想到好的实现，索性就直接暴力遍历然后分情况讨论了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">romanToInt</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">char</span> tmp;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">cursor</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; cursor &lt; s.length(); cursor++)&#123;<br>            tmp = s.charAt(cursor);<br>            <span class="hljs-keyword">if</span> (tmp == <span class="hljs-string">&#x27;M&#x27;</span>)&#123;<br>                result += <span class="hljs-number">1000</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tmp == <span class="hljs-string">&#x27;D&#x27;</span>)&#123;<br>                result += <span class="hljs-number">500</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tmp == <span class="hljs-string">&#x27;C&#x27;</span>)&#123;<br>                <span class="hljs-keyword">if</span> (cursor &lt; s.length() - <span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-keyword">if</span>(s.charAt(cursor + <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;M&#x27;</span>)&#123;<br>                        result += <span class="hljs-number">900</span>;<br>                        cursor++;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.charAt(cursor + <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;D&#x27;</span>)&#123;<br>                        result += <span class="hljs-number">400</span>;<br>                        cursor++;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span>&#123;<br>                        result += <span class="hljs-number">100</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    result += <span class="hljs-number">100</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tmp == <span class="hljs-string">&#x27;L&#x27;</span>)&#123;<br>                result += <span class="hljs-number">50</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tmp == <span class="hljs-string">&#x27;X&#x27;</span>)&#123;<br>                <span class="hljs-keyword">if</span> (cursor &lt; s.length() - <span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-keyword">if</span>(s.charAt(cursor + <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;C&#x27;</span>)&#123;<br>                        result += <span class="hljs-number">90</span>;<br>                        cursor++;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.charAt(cursor + <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;L&#x27;</span>)&#123;<br>                        result += <span class="hljs-number">40</span>;<br>                        cursor++;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span>&#123;<br>                        result += <span class="hljs-number">10</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    result += <span class="hljs-number">10</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tmp == <span class="hljs-string">&#x27;V&#x27;</span>)&#123;<br>                result += <span class="hljs-number">5</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (cursor &lt; s.length() - <span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-keyword">if</span>(s.charAt(cursor + <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;X&#x27;</span>)&#123;<br>                        result += <span class="hljs-number">9</span>;<br>                        cursor++;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.charAt(cursor + <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;V&#x27;</span>)&#123;<br>                        result += <span class="hljs-number">4</span>;<br>                        cursor++;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span>&#123;<br>                        result += <span class="hljs-number">1</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    result += <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>太久没写了，写得太久了，写的挺急的，就想着怎么写出来其他都没管了，看上去挺笨重的（<br>我就没多想，转就转呗，那我就嗯遍历一遍字符串，特殊情况拿出来特殊讨论就好了。一开始是往前看的，发现不对劲，往前看结果不对，只好往后看顺便多加一条条件防止索引出界（好笨啊好笨啊好笨啊）<br>行吧，毕竟我现在水平感觉跟刚学编程的没什么差别，只能说慢慢来了（倒</p><hr>]]></content>
    
    
    <categories>
      
      <category>Solution</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python随笔-5</title>
    <link href="/2022/09/22/python-essay-5/"/>
    <url>/2022/09/22/python-essay-5/</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>文章未完成</p>          </div><h1><code>__future__</code>模块</h1><p>说白了就是把新版本的特性导入到当前Python版本。<br>然后程序里是这个东西：<code>from __future__ import annotations</code><br>额，这条语句其实搞不是很懂，参考了下别人的博文，大概有这么两种解释得好的：</p><blockquote><p>加入以下语句，解释器将不再构造这些复合类型。<br><code>from __future__ import annotations</code><br>一旦解释器解析脚本语法树后，它会识别类型提示并绕过评估它，将其保留为原始字符串。这种机制使得类型提示发生在需要它们的地方：由linter来进行类型检查。 在Python 4中，这种机制将成为默认行为。<br>原文链接：<a href="https://sikasjc.github.io/2018/07/14/type-hint-in-python/">全面理解Python中的类型提示（Type Hints）</a><br>还有一个是代码例子:(原文链接：<a href="https://www.jtr109.com/posts/python-self-typing-annotation/">Python Class 定义时声明当前 Class 类型</a>)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span>:<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self: Foo, bar: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        self.bar = bar<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    Foo(<span class="hljs-string">&#x27;bar&#x27;</span>)<br></code></pre></td></tr></table></figure><p>但是上面的代码是会报错的，原因就在于<code>self: Foo</code>。因为在类<code>Foo</code>定义前就已经被自己的方法<code>__init__</code>使用了，解释器无法理解，报出<code>NameError: name 'Foo' is not defined</code>错误。<br>这个时候这条语句就有用了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> __future__ <span class="hljs-keyword">import</span> annotations<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span>:<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self: Foo, bar: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        self.bar = bar<br></code></pre></td></tr></table></figure><h1><code>typing</code>模块——类型注解支持</h1><p>这个模块提供对类型提示的运行时支持。下边详细介绍一下程序里边的从typing导入的各种东西：</p><h2 id="TypeVar">TypeVar</h2><p>类型变量的缩写。类型变量主要是为静态类型检查器提供支持，用于泛型类型与泛型函数定义的参数。有关泛型类型，详见<code>Generic</code>。<br>其实就是定义一个泛型变量，然后你就能把这个泛型变量用在泛型类型或者泛型函数定义的参数中了。直接上例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Python">T = TypeVar(<span class="hljs-string">&#x27;T&#x27;</span>)  <span class="hljs-comment"># Can be anything</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">repeat</span>(<span class="hljs-params">x: T, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Sequence</span>[T]:  <span class="hljs-comment"># 这里的 Sequence[T] 就是把泛型变量用在泛型类型中，x: T 就是把泛型变量用在泛型函数定义的参数中。</span><br>    <span class="hljs-string">&quot;&quot;&quot;Return a list containing n references to x.&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> [x]*n<br></code></pre></td></tr></table></figure><p>你也可以对类型变量进行<strong>绑定(bound)</strong>，或者<strong>约束</strong>类型变量，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Python">S = TypeVar(<span class="hljs-string">&#x27;S&#x27;</span>, bound=<span class="hljs-built_in">str</span>)  <span class="hljs-comment"># Can be any subtype of str</span><br>A = TypeVar(<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-built_in">str</span>, <span class="hljs-built_in">bytes</span>)  <span class="hljs-comment"># Must be exactly str or bytes</span><br></code></pre></td></tr></table></figure><p>但是要注意的是，类型变量不能既是被绑定的又是被约束的。</p><h2 id="Generic">Generic</h2><p>用于泛型类型的抽象基类。<br><strong>泛型类型一般通过继承含一个或多个类型变量的类实例进行声明</strong>。官方文档给出的例子是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mapping</span>(<span class="hljs-type">Generic</span>[KT, VT]):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self, key: KT</span>) -&gt; VT:<br>        ...<br>        <span class="hljs-comment"># Etc.</span><br><br>X = TypeVar(<span class="hljs-string">&#x27;X&#x27;</span>)<br>Y = TypeVar(<span class="hljs-string">&#x27;Y&#x27;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">lookup_name</span>(<span class="hljs-params">mapping: Mapping[X, Y], key: X, default: Y</span>) -&gt; Y:<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">return</span> mapping[key]<br>    <span class="hljs-keyword">except</span> KeyError:<br>        <span class="hljs-keyword">return</span> default<br></code></pre></td></tr></table></figure><p>这里还给出了另一篇<a href="https://zhuanlan.zhihu.com/p/486772116">文章</a>中的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> TypeVar, <span class="hljs-type">Union</span>, <span class="hljs-type">Generic</span>, <span class="hljs-type">List</span><br><br><span class="hljs-comment"># 通过TypeVar限定为整数型的列表和浮点数的列表</span><br>T = TypeVar(<span class="hljs-string">&quot;T&quot;</span>, bound=<span class="hljs-type">Union</span>[<span class="hljs-built_in">int</span>, <span class="hljs-built_in">float</span>])<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyList</span>(<span class="hljs-type">Generic</span>[T]):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, size: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        self.size = size<br>        self.<span class="hljs-built_in">list</span>: <span class="hljs-type">List</span>[T] = []<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">append</span>(<span class="hljs-params">self, e: T</span>):<br>        self.<span class="hljs-built_in">list</span>.append(e)<br>        <span class="hljs-built_in">print</span>(self.<span class="hljs-built_in">list</span>)<br><br><span class="hljs-comment"># 适用于整数型</span><br>intList = MyList[<span class="hljs-built_in">int</span>](<span class="hljs-number">3</span>)    <span class="hljs-comment"># 通过[int]进行类型提示！</span><br>intList.append(<span class="hljs-number">101</span>)<br><br><span class="hljs-comment"># 也适用于浮点数</span><br>floatList = MyList[<span class="hljs-built_in">float</span>](<span class="hljs-number">3</span>)<br>floatList.append(<span class="hljs-number">1.1</span>)<br><br><span class="hljs-comment"># 但不适用于字符串，以下代码通过mypy检查会报错！</span><br>strList = MyList[<span class="hljs-built_in">str</span>](<span class="hljs-number">3</span>)<br>strList.append(<span class="hljs-string">&quot;test&quot;</span>)<br></code></pre></td></tr></table></figure><p>或许可以理解为，如果你定义的一个类中使用了某种类型变量，那么你可以通过<code>Generic</code>来对你的类声明。（如果你创建的类中想要使用某种类型变量，如T，那么你就通过继承<code>Generic[T]</code>类来使用。）</p><h2 id="Protocol">Protocol</h2><p>官方文档是这么描述的：协议类的基类。呃，那么问题来了，我也不知道什么是协议类啊。。。所以我直接使用搜索引擎，找到了点零零散散的东西。<br>在Python中，协议就是一个或一组方法（接口），那协议类很明显就是包含协议的类，就是在这个类里边放一些不实现的方法，是不是像那啥，抽象基类啊？<br>比如下面的代码，<code>__eq__</code>和<code>__lt__</code>不就pass了吗，这俩就能看成协议。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># ... 表示函数没有实现任何代码，跟 pass 的作用类似</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Comparable</span>(<span class="hljs-title class_ inherited__">Protocol</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__eq__</span>(<span class="hljs-params">self, other: <span class="hljs-type">Any</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        ...<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__lt__</span>(<span class="hljs-params">self: C, other: C</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        ...<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__gt__</span>(<span class="hljs-params">self: C, other: C</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">not</span> self &lt; other) <span class="hljs-keyword">and</span> self != other<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__le__</span>(<span class="hljs-params">self: C, other: C</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-keyword">return</span> self &lt; other <span class="hljs-keyword">or</span> self == other<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__ge__</span>(<span class="hljs-params">self: C, other: C</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">not</span> self &lt; other<br></code></pre></td></tr></table></figure><p>然后官方文档接着说了：这些类主要与静态类型检查器搭配使用，用来识别结构子类型（静态鸭子类型）。啊，好的，我也不知道啥是鸭子类型，所以我又去找搜索引擎帮忙了，然后我找到这么一篇文章：<a href="https://cloud.tencent.com/developer/article/1484390#3.2">你知道什么是Python里的鸭子类型和猴子补丁吗？</a><br>文章里是这么说的：</p><blockquote><p>鸭子类型是对Python中数据类型本质上是由属性和行为来定义的一种解读。<br>Python是一种动态语言，不像Java和C++这种强类型语言，Python里实际上没有严格的类型检查。<br>只要某个对象具有鸭子的方法，可以像鸭子那样走路和嘎嘎叫，那么它就可以被其它函数当做鸭子一样调用。<br>啥意思呢，举个栗子：<br>假设我们现在有两个类，一个<code>Duck</code>类，一个<code>Goose</code>类，两个类都实现了同样的方法<code>bark()</code><br>然后我们自定义了一个函数<code>test</code>，这个函数接受一个<code>Duck</code>对象，并调用该对象的<code>bark()</code>方法。在其它语言中，我们需要指定传入形参<code>duck</code>的类型，得这么写<code>test(Duck duck)</code>，但是在Python中不需要，直接这么写：<code>test(duck)</code><br>但由于Python是动态语言，没有严格类型检查，这就导致你把一个<code>Goose</code>类的对象塞进去也不会报错，因为<code>Goose</code>类也实现了<code>bark()</code>方法。<br>卸载再来看下官方文档给出的例子：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Proto</span>(<span class="hljs-title class_ inherited__">Protocol</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">meth</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        ...<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">meth</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">x: Proto</span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-keyword">return</span> x.meth()<br><br>func(C())  <span class="hljs-comment"># Passes static type check</span><br></code></pre></td></tr></table></figure><p>上面的<code>Proto</code>类即是协议类，里面只有一个协议（方法）<code>meth()</code>，而另一个则是<code>C</code>，它实现了协议<code>meth()</code>，那么它就可以看作是鸭子类型。<br>这里的<code>func()</code>函数用了类型检查，虽然指定了参数<code>x</code>的类型是<code>Proto</code>，但是由于<code>Proto</code>继承了<code>Protocol</code>，所以传入鸭子类型<code>C</code>的时候，跳过了静态类型检查。</p><div class="note note-info">            <p>Protocol 类可以是泛型，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GenProto</span>(Protocol[T]):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">meth</span>(<span class="hljs-params">self</span>) -&gt; T:<br>        ...<br></code></pre></td></tr></table></figure>          </div><h2 id="Callable">Callable</h2><hr>]]></content>
    
    
    <categories>
      
      <category>Essay</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>斐波那契数列</title>
    <link href="/2022/09/14/fibonacci_1/"/>
    <url>/2022/09/14/fibonacci_1/</url>
    
    <content type="html"><![CDATA[<h1>什么是斐波那契数列？</h1><p>相信对于各位程序员来说，斐波那契数列是个无比熟悉的东西了（递 归 启 蒙），不需要什么多余的介绍。不过出于让文章变得更友好些，还是简单提一下吧。<br>其实在数学上，斐波那契数列就是以递归的形式定义的：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>F</mi><mn>0</mn></msub><mo>=</mo><mn>0</mn><mspace linebreak="newline"></mspace><msub><mi>F</mi><mn>1</mn></msub><mo>=</mo><mn>1</mn><mspace linebreak="newline"></mspace><msub><mi>F</mi><mi>n</mi></msub><mo>=</mo><msub><mi>F</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>F</mi><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow></msub><mtext>（</mtext><mi>n</mi><mo>≥</mo><mn>2</mn><mtext>）</mtext></mrow><annotation encoding="application/x-tex">F_0=0 \\F_1=1 \\F_n=F_{n-1}+F_{n-2}（n \ge 2）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">（</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">2</span><span class="mord cjk_fallback">）</span></span></span></span></span></p><p>用文字来说，就是斐波那契数列由0和1开始，之后的斐波那契数就是由之前的两数相加而得出。</p><h1>最先想到的实现！</h1><p>其实看完上面的三个公式，很快就能把对应的求斐波那契数的函数写出来了。最经典（应该吧）的写法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fib0</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br><span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">2</span>:<br><span class="hljs-keyword">return</span> n<br><span class="hljs-keyword">return</span> fib0(n - <span class="hljs-number">1</span>) + fib0(n - <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>虽然这种写法是根据数学公式直接转换过来的，十分简单暴力，但是它的运算时间是随n而指数上升的！</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">55</span><br>计算第<span class="hljs-number">10</span>个斐波那契数所需时间：<span class="hljs-number">0</span>.<span class="hljs-number">3194000000000009m</span>s<br><span class="hljs-number">6765</span><br>计算第<span class="hljs-number">20</span>个斐波那契数所需时间：<span class="hljs-number">1</span>.<span class="hljs-number">1687000000000016m</span>s<br><span class="hljs-number">832040</span><br>计算第<span class="hljs-number">30</span>个斐波那契数所需时间：<span class="hljs-number">108</span>.<span class="hljs-number">93619999999999m</span>s<br><span class="hljs-number">102334155</span><br>计算第<span class="hljs-number">40</span>个斐波那契数所需时间：<span class="hljs-number">12987</span>.<span class="hljs-number">193299999999m</span>s<br></code></pre></td></tr></table></figure><p>可以看到，从30到40，计算时间直接翻了100倍！更不要说运行<code>fib0(50)</code>了，可能根本等不到运行结果。。。</p><h1>想办法进行优化</h1><p>那如果我们有额外需求要求如此之“大”的斐波那契数，要怎么办呢？这里给出两种办法：利用结果缓存、将递归改为迭代。</p><h2 id="简直不要太好用的结果缓存">简直不要太好用的结果缓存</h2><p>结果缓存是一种缓存技术，即在每次计算任务完成后就把结果保存起来，这样在下次需要时即可直接检索出结果，避免了重复计算。</p><h3 id="使用字典进行结果缓存">使用字典进行结果缓存</h3><p>我们可以将每次计算得到的斐波那契数存入字典中，需要的时候再把它取出来，这样就可以避免重复运算，提高运行效率了。<br>下面给出了在Python中利用<code>Dict</code>实现结果缓存和在Java中使用<code>Map</code>实现结果缓存的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Dict</span><br><br>memo: <span class="hljs-type">Dict</span>[<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>] = &#123;<span class="hljs-number">0</span>: <span class="hljs-number">0</span>, <span class="hljs-number">1</span>: <span class="hljs-number">1</span>&#125;<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fib1</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-keyword">if</span> n <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> memo:<br>        memo[n] = fib1(n - <span class="hljs-number">1</span>) + fib1(n - <span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">return</span> memo[n]<br><br><span class="hljs-comment"># output</span><br><span class="hljs-number">354224848179261915075</span><br>计算第<span class="hljs-number">100</span>个斐波那契数所需时间：<span class="hljs-number">0.3382000000000003</span>ms<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CalculateFib</span> &#123;<br>    <span class="hljs-keyword">static</span> Map&lt;Integer, Integer&gt; m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, Integer&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (m.get(n) == <span class="hljs-literal">null</span>) &#123;<br>            m.put(n, fib(n - <span class="hljs-number">1</span>) + fib(n - <span class="hljs-number">2</span>));<br>        &#125;<br>        <span class="hljs-keyword">return</span> m.get(n);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        m.put(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        m.put(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>        System.out.println(CalculateFib.fib(<span class="hljs-number">20</span>));<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// output</span><br><span class="hljs-number">102334155</span><br>Spend time:<span class="hljs-number">134100.</span>0ns<br></code></pre></td></tr></table></figure><p>比较一下现在的效率和之前的效率，怎么样，是不是有了飞一般的提升？不过，使用字典并不是Python最方便的结果缓存方法，因为在Python里有一个内置的装饰器，可以自动为任何函数缓存结果。</p><h3 id="自动化的结果缓存">自动化的结果缓存</h3><p><code>@functools.lru_cache(maxsize=128, typed=False)</code>是一个为函数提供缓存功能的装饰器，缓存 maxsize 组传入参数，在下次以相同参数调用时直接返回上一次的结果。<br>如果 maxsize 设为 None，LRU 特性将被禁用且缓存可无限增长。<br>如果 typed 被设置为 true ，不同类型的函数参数将被分别缓存。 如果 typed 为 false ，实现通常会将它们视为等价的调用，只缓存一个结果。(有些类型，如 str 和 int ，即使 typed 为 false ，也可能被分开缓存）。<br>我们只需要在最开始实现的<code>fib0()</code>函数上加上装饰器即可，非常简单友好，不是吗？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> lru_cache<br><span class="hljs-meta">@lru_cache(<span class="hljs-params">maxsize=<span class="hljs-literal">None</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fib0</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br><span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">2</span>:<br><span class="hljs-keyword">return</span> n<br><span class="hljs-keyword">return</span> fib0(n - <span class="hljs-number">1</span>) + fib0(n - <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>但是其实，就算利用结果缓存，因为还是利用递归的原因，回溯存在上限，还是无法计算一些大数，比如<code>fib(1000)</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Python">Traceback (most recent call last):<br>RecursionError: maximum recursion depth exceeded<br></code></pre></td></tr></table></figure><p>这种情况下，我们就改用<strong>迭代法</strong>来求斐波那契数了。</p><h2 id="迭代法">迭代法</h2><p>递归解决方案是反向求解，而迭代则是正向求解，也就是说，我们不再是从n往前求解，而是从0开始推导出n。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fib2</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> n<br>    last: <span class="hljs-built_in">int</span> = <span class="hljs-number">0</span><br>    <span class="hljs-built_in">next</span>: <span class="hljs-built_in">int</span> = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>        last, <span class="hljs-built_in">next</span> = <span class="hljs-built_in">next</span>, last + <span class="hljs-built_in">next</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">next</span><br><br><span class="hljs-comment"># output</span><br><span class="hljs-number">139423224561697880139724382870407283950070256587697307264108962948325571622863290691557658876222521294125</span><br>计算第<span class="hljs-number">500</span>个斐波那契数所需时间：<span class="hljs-number">0.30870000000000203</span>ms<br></code></pre></td></tr></table></figure><p>因为利用了迭代法的原因，我们可以在此基础上将这个函数写成生成器，这样就可以输出到n的每一个斐波那契数了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Generator<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fib3</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; Generator[<span class="hljs-built_in">int</span>, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>]:<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> n &gt; <span class="hljs-number">0</span>: <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span><br>    last: <span class="hljs-built_in">int</span> = <span class="hljs-number">0</span><br>    <span class="hljs-built_in">next</span>: <span class="hljs-built_in">int</span> = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>        last, <span class="hljs-built_in">next</span> = <span class="hljs-built_in">next</span>, last + <span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">next</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> fib3(<span class="hljs-number">50</span>):<br><span class="hljs-built_in">print</span>(i)<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>Essay</category>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Java</tag>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python学习笔记——循环与迭代</title>
    <link href="/2022/07/19/python-learning-5/"/>
    <url>/2022/07/19/python-learning-5/</url>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>由于我实在想不出写什么前言好，所以这里我选择直截了当地概括内容！(<br>在本篇中，你可以学到：怎么<s>漂亮地</s>写Python中的循环，<s>轻松地</s>认识Python中的迭代器和生成器。</p><h1>正文</h1><h2 id="Python中的循环">Python中的循环</h2><h3 id="认识Python中的循环">认识Python中的循环</h3><p>如果是刚接触Python，那么可能会对Python中循环的写法感到奇怪，因为Python中的循环并不像其他语言那样写。先来比较一下我们熟悉的循环和Python的循环。<br>就以Java语言为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"># Java语言举例循环<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> a; i &lt; n; i += s)&#123;<br><span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>然后再来看看Python的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># Python语言的循环，a为起始值，n为终止值，s为步长。</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(a, n, s)<br></code></pre></td></tr></table></figure><p>其他语言转换成Python中的循环，就是用<code>range()</code>函数，它接受三个可选参数，在上边程序段中也说明了三个参数代表什么。<br>哦，当然，譬如Java和C#这样的语言也提供foreach循环，可以说Python中的基本循环就是比较接近于foreach循环的，直接在容器或序列中迭代元素，无需通过索引查找，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Python">items = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]<br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> items:<br><span class="hljs-built_in">print</span>(item)<br><br><span class="hljs-comment"># 输出如下：</span><br>a<br>b<br>c<br></code></pre></td></tr></table></figure><p>所以如果是刚刚接触Python可能还需要一段时间来适应循环的写法，熟悉后便会觉得“诶，这样写循环还挺不错挺方便的哦！”<br>当然这里要提的不仅仅是这点东西，我还会介绍一下<code>range()</code>函数、解析式、以及一些循环写法。</p><div class="note note-warning">            <p><strong>在Python循环中需要注意的几点！</strong><br>1、 循环中不再跟踪容器的大小，也不使用运行时索引来访问元素。<br>2、 容器本身现在负责分发将要处理的元素。如果容器是有序的，那么所得到的元素序列也是有序的。如果容器是无序的，那么将以随机顺序返回其元素，但循环仍然会遍历所有元素。</p>          </div><h3 id="Python中的循环的一些神必写法">Python中的循环的一些神必写法</h3><p><s>好吧其实并不神必只是想取个有意思的标题</s><br>我们知道，Python的循环可以取索引，或者直接取容器中的元素，但是有的时候我们既需要索引，也需要元素，能不能做到呢？其实是可以的，利用内置的<code>enumerate()</code>即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> i, item <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(items):<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;i&#125;</span>: <span class="hljs-subst">&#123;item&#125;</span>&#x27;</span>)<br><br><span class="hljs-number">0</span>: a<br><span class="hljs-number">1</span>: b<br><span class="hljs-number">2</span>: c<br></code></pre></td></tr></table></figure><blockquote><p>Python中的迭代器可以连续返回多个值。迭代器可以返回含有任意个元素的元组，然后在for语句内解包。</p></blockquote><h3 id="Python中的解析式">Python中的解析式</h3><p>列表解析式是Python的一个特性，也可以看作是一种语法糖<s>（或者是神必写法）</s>。它可以简化（前提是能够理解）并使循环更加紧凑，举个栗子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 如果要写一个平方列表，我们可能会这么做：</span><br>squares = []<br>    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>        squares.append(x * x)<br><br><span class="hljs-comment"># 如果使用列表解析式，就会变得十分简洁紧凑：</span><br>    squares = [x * x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)]<br></code></pre></td></tr></table></figure><p>上边可以说是最基本的列表解析式构建列表了，列表解析式能做到的还不止这样，它还能使用条件来过滤元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Python">even_squares = [x * x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">if</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p>在上面的代码段中，构建了一个从0到9所有偶数整数的平方组成的列表。<br>归纳一下，可以得到如下列表解析式模板：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 一般循环：</span><br>values = []<br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> collection:<br><span class="hljs-keyword">if</span> condition:<br>values.append(expression)<br><br><span class="hljs-comment"># 使用列表解析式的循环：</span><br>values = [expression <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> collection <span class="hljs-keyword">if</span> condition]<br></code></pre></td></tr></table></figure><p>以上就是列表解析式的所有内容啦，不过既然有列表解析式，那Python中是否还有<strong>字典解析式</strong>呢？<br>你好，有的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">&gt;&gt;&gt; </span>&#123; x: x * x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>)&#125;<br>&#123;<span class="hljs-number">0</span>: <span class="hljs-number">0</span>, <span class="hljs-number">1</span>: <span class="hljs-number">1</span>, <span class="hljs-number">2</span>: <span class="hljs-number">4</span>, <span class="hljs-number">3</span>: <span class="hljs-number">9</span>, <span class="hljs-number">4</span>: <span class="hljs-number">16</span>&#125;<br></code></pre></td></tr></table></figure><p>不仅是字典解析式，还有<strong>集合解析式</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">&gt;&gt;&gt; </span>&#123; x * x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(-<span class="hljs-number">9</span>, <span class="hljs-number">10</span>) &#125;<br>&#123;<span class="hljs-number">64</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">36</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">81</span>, <span class="hljs-number">49</span>, <span class="hljs-number">25</span>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>集合是无需类型，所以在将元素加到set容器时顺序是随机的。</p></blockquote><div class="note note-info">            <p>“不过Python解析式中有一个需要注意的地方：在熟悉了解析式之后，很容易就会编写出难以阅读的代码。”<br>“在经历了许多烦恼之后，我给解析式设定的限制是只能嵌套一层。在大多数情况下，多层嵌套最好直接使用for循环，这样代码更加易读且容易维护。”</p>          </div><h3 id="Python中的列表切片及其技巧">Python中的列表切片及其技巧</h3><p>Python的列表对象有方便的切片特性。<strong>切片</strong>可被视为方括号索引语法的扩展，通常用于访问有序集合中某一范围的元素。例如，将一个大型列表对象分成几个较小的子列表。<br>我们可以这么看切片语法：<code>a_list[start:stop:step]</code>，其中<strong>start</strong>为起始索引，<strong>stop</strong>为终止索引，<strong>step</strong>为步长（也叫<strong>stride</strong>，步幅）。不过要记住一点，切片计算方法是算头不算尾，也就是切片里面包含的元素是<strong>start到stop-1</strong>。<br>了解了语法，就可以来看看它的一些应用技巧了。首先是用切片语法创建一个原始列表的逆序副本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">&gt;&gt;&gt; </span>a_list = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>a_list[::-<span class="hljs-number">1</span>]<br>[<span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>稍微分析一下，在<code>[::-1]</code>这里， :: 让Python提供了完整的列表，而将步长设置为-1则让Python从后到前来遍历所有元素。</p><blockquote><p>这么做其实和<code>list.reverse()</code>或是<code>reverse()</code>是一样的<br>这里还有另一个列表切片技巧：使用 : 操作符清空列表中的所有元素，同时不会破坏列表对象本身。<br>这适用于在程序中有其他引用指向这个列表时清空列表。在这种情况下，通常不能用新的列表对象替换已有列表来清空列表，替换列表不会更新原列表的引用。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">del</span> a_list[:]<br><span class="hljs-meta">&gt;&gt;&gt; </span>a_list<br>[]<br></code></pre></td></tr></table></figure><blockquote><p>在Python3中也可以使用<code>a_list.clear()</code>完成同样的工作，而且这种方式在某些情况下可读性更好。<br>也就是说，我们还能利用这个技巧，用切片来在不创建新列表对象的情况下替换列表中的所有元素：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">&gt;&gt;&gt; </span>a_list = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>b_list = a_list<br><span class="hljs-meta">&gt;&gt;&gt; </span>a_list[:] = [<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>a_list<br>[<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>b_list<br>[<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>b_list <span class="hljs-keyword">is</span> a_list<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>利用 : 操作符还可以创建现有列表的浅副本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">&gt;&gt;&gt; </span>copied_list = a_list[:]<br><span class="hljs-meta">&gt;&gt;&gt; </span>copied_list<br>[<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>copied_list <span class="hljs-keyword">is</span> a_list<br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>创建浅副本意味着只复制元素的结构，而不复制元素本身。两个列表中的每个元素都是相同的实例。<br>如果需要复制所有内容（包括元素），则需要创建列表的深副本。创建深副本可以使用Python内置的copy模块。</p>          </div><h2 id="迭代器">迭代器</h2><h3 id="什么是迭代器？">什么是迭代器？</h3><blockquote><p>“迭代器（iterator），是确使用户可在容器对象（container，例如链表或数组）上遍访的对象，设计人员使用此接口无需关心容器对象的内存分配的实现细节。其行为很像数据库技术中的光标（cursor）。”——维基百科<br>举个例子，列表就属于迭代器，因此列表能用于for-in循环：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Python">numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> numbers:<br>    <span class="hljs-built_in">print</span>(num)<br></code></pre></td></tr></table></figure><p>在Python中，只要对象支持<code>__iter__</code>和<code>__next__</code>双下划线方法（或者说支持迭代器协议），那么就能使用for-in循环。正是由于这个特点，使得我们在需要遍历一个对象中的某些内容时能通过使用迭代器而变得十分方便。<br>所以我们可以编写一个支持迭代器协议的类，从而对这个类创建的实例使用for-in循环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Repeater</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, value</span>):<br>        self.value = value<br>            <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__next__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self.value<br></code></pre></td></tr></table></figure><p>这里编写了一个Repeater类，该类在迭代时类的实例会重复返回同一个值，效果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">&gt;&gt;&gt; </span>repeater = Repeater(<span class="hljs-string">&#x27;Hello&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> repeater:<br><span class="hljs-built_in">print</span>(item)<br>    <br>Hello<br>Hello<br>...<br>Hello<br>Hello<br></code></pre></td></tr></table></figure><p>其实到这迭代器就可以算介绍完了。看到这里，我相信有些人可以理解，但是有些人会觉得挺抽象的（因为我就觉得），也没搞明白到底是个什么工作原理，怎么iter返回个self啊，next返回个value什么的，所以下面会以书上的另一种方式再次解读迭代器。</p><blockquote><p>还是用到上面的Repeater类为例子，但是这里我们把它拆分为两个类（Repeater、RepeaterIterator）来分别实现迭代器协议中的两个方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Repeater</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, value</span>):<br>        self.value = value<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> RepeaterIterator(self)<br>    <br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RepeaterIterator</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, source</span>):<br>        self.source = source<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__next__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self.source.value<br></code></pre></td></tr></table></figure><p>我们要关注的是上面的<code>__iter__</code>和<code>__next__</code>两个方法以及RepeaterIterator类。<br>首先是<code>__iter__</code>。<code>__iter__</code>创建并返回了RepeaterIterator对象，从意思上看，也能说创建了一个Repeater类的迭代器对象。<br>然后就是RepeaterIterator类，我们要注意以下两点：<br>（1）在<code>__init__</code>方法中，每个RepeaterIterator实例都链接到创建它的Repeater对象。这样可以持有迭代的“源”（source）对象。<br>（2）在<code>RepeaterIterator.__next__</code>中，回到“源”Repeater实例并返回与其关联的值。<br>如此一来，我们便可以在for-in中使用Repeater实例。那么for-in循环又是怎么工作的呢？看下面一段代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Python">repeater = Repeater(<span class="hljs-string">&#x27;Hello&#x27;</span>)<br>iterator = repeator.__iter__()<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    item = iterator.__next__()<br>    <span class="hljs-built_in">print</span>(item)<br></code></pre></td></tr></table></figure><p>首先让repeater对象准备迭代，即调用<code>__iter__</code>方法来返回实际的迭代器对象。<br>然后循环反复调用迭代器对象的<code>__next__</code>方法，从中获取值。<br>如果有数据库相关知识，你还会发现迭代器和游标的相似之处：首先初始化游标并准备读取，然后从中逐个取出数据存入局部变量中。<br>无论是元素列表、字典，还是Repeater类提供的无限序列，或是其他序列类型，对于迭代器来说只是实现细节不同。迭代器能以相同的方式遍历这些对象中的元素。</p></blockquote><h3 id="在Python解释器会话中模拟循环使用迭代器协议的方式">在Python解释器会话中模拟循环使用迭代器协议的方式</h3><p>实际上，我们可以手动模拟这个过程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">&gt;&gt;&gt; </span>repeater = Repeater(<span class="hljs-string">&#x27;Hello&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>iterator = <span class="hljs-built_in">iter</span>(repeater)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(iterator)<br><span class="hljs-string">&#x27;Hello&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(iterator)<br><span class="hljs-string">&#x27;Hello&#x27;</span><br>...<br></code></pre></td></tr></table></figure><p>在这里，我们没有使用双下划线方法，作为替代，我们使用了Python内置函数<code>iter()</code>和<code>next()</code>。<br>这些内置函数在内部会调用相同的双下划线方法，为迭代器协议提供一个简洁的封装（facade）。</p><h3 id="有限迭代">有限迭代</h3><p>既然可以手动模拟迭代过程，我们不妨来学习一下其他实现了迭代器协议的对象是怎么停下迭代的。<br>就用开头那个列表作为例子，让我们手动模拟一下它的迭代过程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">&gt;&gt;&gt; </span>iterator = <span class="hljs-built_in">iter</span>(numbers)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(iterator)<br><span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(iterator)<br><span class="hljs-number">2</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(iterator)<br><span class="hljs-number">3</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(iterator)<br>StopIteration<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(iterator)<br>StopIteration<br>...<br></code></pre></td></tr></table></figure><p>可以看到，在遍历完列表中的所有元素后，继续调用<code>next()</code>函数将会抛出StopIteration异常。<br>所以我们也可以在我们自己编写的支持迭代器协议的类中，通过抛出StopIteration异常来停止迭代。<br>下面是书上的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BoundedRepeater</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, value, max_repeats</span>):<br>        self.value = value<br>        self.max_repeats = max_repeats<br>        self.count = <span class="hljs-number">0</span><br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__next__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> self.count &gt;= self.max_repeats:<br>            <span class="hljs-keyword">raise</span> StopIteration<br>        self.count += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> self.value<br></code></pre></td></tr></table></figure><h2 id="生成器">生成器</h2><h3 id="什么是生成器">什么是生成器</h3><p>生成器说白了吧，就是简化版的迭代器。它不是基于类的迭代器，而是基于函数的迭代器，因此也不需要实现两个双下划线方法，而且在生成器中不是使用return语句，而是使用yield语句将数据传回给调用者：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">repeater</span>(<span class="hljs-params">value</span>):<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br><span class="hljs-keyword">yield</span> value<br></code></pre></td></tr></table></figure><p>这样一个简单的无限生成器就写好了，很简单对吧！虽然它像普通函数，但是要注意，调用生成器函数并不会运行该函数，而是仅仅创建并返回一个生成器对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">&gt;&gt;&gt; </span>repeater(<span class="hljs-string">&#x27;Hey&#x27;</span>)<br>&lt;generator <span class="hljs-built_in">object</span> repeater at <span class="hljs-number">0x00000188C0A32E40</span>&gt;<br></code></pre></td></tr></table></figure><p>只有在生成器对象上调用<code>next()</code>时才会执行生成器函数中的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">&gt;&gt;&gt; </span>generator_obj = repeater(<span class="hljs-string">&#x27;Hey&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(generator_obj)<br><span class="hljs-string">&#x27;Hey&#x27;</span><br></code></pre></td></tr></table></figure><blockquote><p>return 和 yield 的区别<br>1.当函数内部调用return语句时，控制权会永久性地交还给函数的调用者。在调用yield时，虽然控制权也是交还给函数的调用者，但只是暂时的。<br>2.return语句会丢弃函数的局部状态，而yield语句会暂停该函数并保留其局部状态。</p></blockquote><h3 id="有限生成器">有限生成器</h3><p>在基于类的迭代器中，我们通过抛出StopIteration异常来表示迭代结束，那么在生成器中呢？<br>由于生成器与基于类的迭代器完全兼容，所以背后仍然使用这种方法。<br>或者，我们可以使用更好的接口。如果控制流从生成器函数中返回，但不是通过yield语句，那么生成器就会停止：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">repeat_three_times</span>(<span class="hljs-params">value</span>):<br><span class="hljs-keyword">yield</span> value<br><span class="hljs-keyword">yield</span> value<br><span class="hljs-keyword">yield</span> value<br><span class="hljs-meta">&gt;&gt;&gt; </span>iterator = repeat_three_times(<span class="hljs-string">&#x27;Hey there&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(iterator)<br><span class="hljs-string">&#x27;Hey there&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(iterator)<br><span class="hljs-string">&#x27;Hey there&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(iterator)<br>StopIteration<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(iterator)<br>StopIteration<br></code></pre></td></tr></table></figure><p>知道了这些知识，我们就能够转化一下BoundedRepeater类了，让它变成一个生成器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">bounded_repeater</span>(<span class="hljs-params">value, max_repeats</span>):<br>count = <span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br><span class="hljs-keyword">if</span> count &gt;= max_repeats:<br><span class="hljs-keyword">return</span><br>count += <span class="hljs-number">1</span><br><span class="hljs-keyword">yield</span> value<br></code></pre></td></tr></table></figure><p>当然，还有更简便的版本，利用Python为每个函数的末尾添加一个隐式<code>return None</code>语句的特性，我们甚至可以这样写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">bounded_repeater</span>(<span class="hljs-params">value, max_repeats</span>):<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(max_repeats):<br><span class="hljs-keyword">yield</span> value<br></code></pre></td></tr></table></figure><h3 id="生成器表达式">生成器表达式</h3><p>生成器表达式通过一行代码来定义迭代器。看到这个，我们很快就能联想到列表解析式。是的，生成器表达式的确和列表表达式非常相似：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">&gt;&gt;&gt; </span>listcomp = [<span class="hljs-string">&#x27;Hello&#x27;</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>)]<br><span class="hljs-meta">&gt;&gt;&gt; </span>genexpr = (<span class="hljs-string">&#x27;Hello&#x27;</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>))<br></code></pre></td></tr></table></figure><p>和列表解析式相同，生成器表达式也可以添加条件从而来过滤一些元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">&gt;&gt;&gt; </span>even_squares = (x * x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">if</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> even_squares:<br>...   <span class="hljs-built_in">print</span>(x)<br><span class="hljs-number">0</span><br><span class="hljs-number">4</span><br><span class="hljs-number">16</span><br><span class="hljs-number">36</span><br><span class="hljs-number">64</span><br></code></pre></td></tr></table></figure><p>和列表解析式不同，生成器表达式不会构造列表对象，而是像基于类的迭代器或生成器函数那样“即时”生成值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">&gt;&gt;&gt; </span>listcomp<br>[<span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-string">&#x27;Hello&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>genexpr<br>&lt;generator <span class="hljs-built_in">object</span> &lt;genexpr&gt; at <span class="hljs-number">0x00000188C0A32DD0</span>&gt;<br></code></pre></td></tr></table></figure><p>我们也可以归纳一下，得出一个生成器表达式的模板：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Python">genexpr = (expression <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> collection <span class="hljs-keyword">if</span> condition)<br></code></pre></td></tr></table></figure><blockquote><p>这个模板也可以看成下边的生成器函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">generator</span>():<br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> collection:<br>        <span class="hljs-keyword">if</span> condition:<br>            <span class="hljs-keyword">yield</span> expression<br></code></pre></td></tr></table></figure></blockquote><div class="note note-warning">            <p>生成器表达式一经使用就不能重新启动或重用，所以在某些情况下生成器函数或基于类的迭代器更加合适。</p>          </div><h3 id="内联生成器表达式">内联生成器表达式</h3><p>因为生成器表达式也是表达式，所以可以与其他语句一起内联使用。例如，可以定义一个迭代器并立即在for循环中使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> (<span class="hljs-string">&#x27;Test&#x27;</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>)):<br><span class="hljs-built_in">print</span>(x)<br></code></pre></td></tr></table></figure><p>另外还有一个语法技巧可以美化生成器表达式。如果生成器表达式是作为函数中的单个参数使用，那么可以删除生成器表达式外层的括号：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">sum</span>((x * <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)))<br><span class="hljs-number">90</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">sum</span>(x * <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>))<br><span class="hljs-number">90</span><br></code></pre></td></tr></table></figure><h2 id="迭代器链">迭代器链</h2><p>Python中的迭代器还有另一个重要特性：可以链接多个迭代器，从而编写高效的数据处理“管道”。<br>普通函数只会产生一次返回值，而生成器会多次产生结果。可以认为生成器在整个生命周期中能<strong>产生值的“流”</strong>。下面用例子来说明：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">integers</span>():<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">9</span>):<br><span class="hljs-keyword">yield</span> i<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">squared</span>(<span class="hljs-params">seq</span>):<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> seq:<br><span class="hljs-keyword">yield</span> i * i<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">negated</span>(<span class="hljs-params">seq</span>):<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> seq:<br><span class="hljs-keyword">yield</span> -i<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>chain = negated(squared(integers()))<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(chain)<br>[-<span class="hljs-number">1</span>, -<span class="hljs-number">4</span>, -<span class="hljs-number">9</span>, -<span class="hljs-number">16</span>, -<span class="hljs-number">25</span>, -<span class="hljs-number">36</span>, -<span class="hljs-number">49</span>, -<span class="hljs-number">64</span>]<br></code></pre></td></tr></table></figure><p>在这里，先是由integers()生成器产生值的“流”，然后送入squared()生成器，squared()生成器根据值再生成值，再送入negated()生成器中生成最后的值。</p><blockquote><p>在生成器链中，每次只处理一个元素，这说明链中的处理步骤之间没有缓冲区。下面是详细步骤：</p><ol><li>integers生成器产生一个值，如3.</li><li>这个值“激活”squared生成器来处理，得到3 * 3 = 9，并将其传递到下一阶段。</li><li>由squared生成器产生的平方数立即送入negated生成器，将其修改为-9并再次yield。</li></ol></blockquote><h1>一些无关的话</h1><p>放假后真的是太懒啦，也是各种作息混乱加上在外游玩又或者干脆睡觉摆烂以至于根本没怎么学（土下座.jpg）。下次更新也是这本好书的最后一章啦，一定会在开学前学完的（确信），就这样啦~</p><hr><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>《Python Tricks 深入理解python特性》 [德]达恩·巴德尔 人民邮电出版社<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Learning Log</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python中的数据结构</title>
    <link href="/2022/07/09/python-learning-4/"/>
    <url>/2022/07/09/python-learning-4/</url>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>其实忙碌的期末周已经过去一个星期多了，但是我又咸🐟了整整一个星期没在学习所以导致博客断更了好长一段时间www<br>正好学到了Python中的数据结构，而我也有复习数据结构的打算，所以很快啊，我就来水（bushi）博文了。<br>Python中的数据结构其实挺多的，而且不像其它语言一样，比如Java中就把列表分为LinkedList和ArrayList，但是在Python中就更“抽象”。所以还是非常有必要下相当一部分功夫的。</p><h1>正文</h1><h2 id="数组数据结构">数组数据结构</h2><p>从我们熟悉而且常用的老朋友——数组开始介绍。在Python中，数组可以是固定大小的，也可以是动态的，可以只装一种数据类型，也可以装很多种，这些都会在后边一一介绍。现在，先来了解一下数组的原理和用途。</p><blockquote><p>数组由大小固定的数据记录组成，根据索引能快速找到其中的每个元素。<br>因为数组将信息存储在依次连接的内存块中，所以它是<strong>连续</strong>的数据结构。</p></blockquote><h3 id="列表——可变动态数组">列表——可变动态数组</h3><p>Python里边常用的列表，即list，就是以动态数组实现的。它实现了增删查改功能，而且可以包含任何对象（也就是说可以装不同的数据类型）。</p><blockquote><p>这个功能很强大，但缺点是同时支持多种数据类型会导致数据存储得不是很紧凑。因此整个结构占据了更多的空间。<br>本质上是因为列表中存储的是PyObject指针，指向不同的对象。然而（其它）数组是直接存放数据本身。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>arr[<span class="hljs-number">0</span>]<br><span class="hljs-number">1</span><br><br><span class="hljs-comment"># 列表的__repr__方法</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>arr<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><br><span class="hljs-comment"># 列表是可变的，且可以含有任意类型的数据</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>arr[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;two&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>arr<br>[<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;two&#x27;</span>, <span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><p>想了解更多有关list的知识，可以翻阅官方文档：<a href="https://docs.python.org/3.9/library/stdtypes.html#list">List</a></p><h3 id="元组——不可变容器">元组——不可变容器</h3><p>元组也是非常熟悉的一个Python中的序列类型了。与列表不同的是，Python的元组对象是不可变的，创建了元组之后，我们就不能对这个元组进行修改了。有些看上去是修改了元组的语法，本质上是创建了一个新的元组，而不是修改原来的元组。<br>和列表一样，元组也可以包含任意数据类型的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>arr = <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>arr[<span class="hljs-number">0</span>]<br><span class="hljs-number">1</span><br><br><span class="hljs-comment"># 元组的__repr__方法</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>arr<br>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><br><span class="hljs-comment"># 元组是不可变的</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>arr[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;two&#x27;</span><br>TypeError: <span class="hljs-string">&#x27;tuple&#x27;</span> <span class="hljs-built_in">object</span> does <span class="hljs-keyword">not</span> support item assignment<br><br><span class="hljs-comment"># 元组可以包含任意类型的数据(注意，这里并没有修改原本的元组，而是创建了一个新的元组)</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>arr + (<span class="hljs-number">23</span>,)<br>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">23</span>)<br></code></pre></td></tr></table></figure><p>想了解更多有关tuple的知识，可以翻阅官方文档：<a href="https://docs.python.org/3.9/library/stdtypes.html#tuple">Tuple</a></p><h3 id="array-array——基本类型数组">array.array——基本类型数组</h3><p>利用array.array创建的数组也是可变的，但是它是只能包含单一数据类型的“<a href="https://docs.python.org/3/library/array.html?highlight=array%20array#array.array">类型数组</a>”,因此它也比列表和元组更为节省空间。<br>此外，数组中也有许多普通列表中含有的方法，使用方式也相同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> array<br><span class="hljs-meta">&gt;&gt;&gt; </span>arr = array.array(<span class="hljs-string">&#x27;f&#x27;</span>, (<span class="hljs-number">1.0</span>, <span class="hljs-number">1.5</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">2.5</span>))<br><span class="hljs-meta">&gt;&gt;&gt; </span>arr[<span class="hljs-number">1</span>]<br><span class="hljs-number">1.5</span><br><br><span class="hljs-comment"># array.array的__repr__方法</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>arr<br>array(<span class="hljs-string">&#x27;f&#x27;</span>, [<span class="hljs-number">1.0</span>, <span class="hljs-number">1.5</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">2.5</span>])<br><br><span class="hljs-comment"># array.array中数据类型是单一的</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>arr[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;one&#x27;</span><br>TypeError: must be real number, <span class="hljs-keyword">not</span> <span class="hljs-built_in">str</span><br></code></pre></td></tr></table></figure><h3 id="str——含有Unicode字符的不可变数组">str——含有Unicode字符的不可变数组</h3><p>Python中的str实际上是不可变的字符数组，而且，str还是一种递归的数据结构，字符串中的每个字符都是长度为1的str对象（很奇怪吧，我也觉得）。<br>如果需要一个可变字符串，Python并不能像Java那样直接拿出一个StringBuffer，而是只能利用列表来作为可变字符串。</p><blockquote><p>python3.x使用str对象将文本数据存储为不可变的Unicode字符序列。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>arr = <span class="hljs-string">&#x27;hello&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>arr[<span class="hljs-number">1</span>]<br><span class="hljs-string">&#x27;e&#x27;</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>arr<br><span class="hljs-string">&#x27;hello&#x27;</span><br><br><span class="hljs-comment"># 字符串是不可变的</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>arr[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;e&#x27;</span><br>TypeError: <span class="hljs-string">&#x27;str&#x27;</span> <span class="hljs-built_in">object</span> does <span class="hljs-keyword">not</span> support item assignment<br><br><span class="hljs-comment"># 字符串是递归型数据类型</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(<span class="hljs-string">&#x27;hello&#x27;</span>)<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;str&#x27;</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(<span class="hljs-string">&#x27;hello&#x27;</span>[<span class="hljs-number">1</span>])<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;str&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>想了解更多有关str的知识，可以翻阅官方文档：<a href="https://docs.python.org/3/library/stdtypes.html#text-sequence-type-str">Str</a></p><h3 id="bytes——含有单字节的不可变数组">bytes——含有单字节的不可变数组</h3><p>bytes对象是单字节的不可变序列，单字节为[0, 255]范围内的整数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>arr = <span class="hljs-built_in">bytes</span>((<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>))<br><span class="hljs-meta">&gt;&gt;&gt; </span>arr[<span class="hljs-number">1</span>]<br><span class="hljs-number">1</span><br><br><span class="hljs-comment"># bytes有自己的语法</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>arr<br><span class="hljs-string">b&#x27;\x00\x01\x02\x03&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>arr = <span class="hljs-string">b&#x27;\x00\x11\x22\x33&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>arr<br><span class="hljs-string">b&#x27;\x00\x01\x02\x03&#x27;</span><br></code></pre></td></tr></table></figure><div class="note note-info">            <p>bytes可以解包到bytearray中。</p>          </div><p>想了解更多有关bytes的知识，可以翻阅官方文档：<a href="https://docs.python.org/3/library/stdtypes.html#bytes">Bytes</a></p><h3 id="bytearray——含有单字节的可变数组">bytearray——含有单字节的可变数组</h3><p>bytearray类型是可变整数序列，包含的整数范围和bytes一样，也是[0, 255]。<br>bytearray数可以转换回不可变的bytes对象，但是这需要复制所存储的数据，是耗时为**O(n)**的慢操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>arr = <span class="hljs-built_in">bytearray</span>((<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>))<br><span class="hljs-meta">&gt;&gt;&gt; </span>arr[<span class="hljs-number">1</span>]<br><span class="hljs-number">1</span><br><br><span class="hljs-comment"># bytearray的__repr__方法</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>arr<br><span class="hljs-built_in">bytearray</span>(<span class="hljs-string">b&#x27;\x00\x01\x02\x03&#x27;</span>)<br><br><span class="hljs-comment"># bytearray可以转换回byte对象，此过程会复制数据</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">bytes</span>(arr)<br><span class="hljs-string">b&#x27;\x00\x01\x02\x03&#x27;</span><br></code></pre></td></tr></table></figure><p>想了解更多有关bytearray的知识，可以翻阅官方文档：<a href="https://docs.python.org/3/library/stdtypes.html#bytearray">Bytes Array</a></p><h2 id="字典数据结构">字典数据结构</h2><p>Python里边第二熟悉的数据结构应该就是字典了。字典可以存储任意数量的对象，每个对象都是一个<strong>值</strong>，每个<strong>值</strong>都被唯一的字典<strong>键</strong>标识。<br>字典通常也被称为<strong>映射</strong>、<strong>散列表</strong>、<strong>查找表</strong>或<strong>关联数组</strong>。<br>在Python中，通常字典都是由dict实现，不过当dict不能满足某些需求的时候，Python还提供了一些特殊字典（尽管特殊，但他们都基于内置的字典类dict）以供使用。</p><h3 id="dict——首选字典实现">dict——首选字典实现</h3><p>Python中最稳健的字典实现就是dict。为方便使用，Python还提供了一些有用的“语法糖”来处理程序中的字典。例如，用花括号字典表达式语法和字典解析式能够方便地创建新的字典对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">number = &#123;<br>    <span class="hljs-string">&#x27;one&#x27;</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-string">&#x27;two&#x27;</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-string">&#x27;three&#x27;</span>: <span class="hljs-number">3</span>,<br>&#125;<br>squares = &#123;x: x * x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>)&#125;<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>number[<span class="hljs-string">&#x27;two&#x27;</span>]<br><span class="hljs-number">2</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>squares<br>&#123;<span class="hljs-number">0</span>: <span class="hljs-number">0</span>, <span class="hljs-number">1</span>: <span class="hljs-number">1</span>, <span class="hljs-number">2</span>: <span class="hljs-number">4</span>, <span class="hljs-number">3</span>: <span class="hljs-number">9</span>, <span class="hljs-number">4</span>: <span class="hljs-number">16</span>, <span class="hljs-number">5</span>: <span class="hljs-number">25</span>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Python的字典由<a href="https://docs.python.org/3/glossary.html#term-hashable">可散列类型</a>的键来索引。 可散列对象具有在其生命周期中永远不会改变的散列值（参见<code>__hash__</code>），并且可以与其他对象进行比较（参见<code>__eq__</code>）。另外，相等的可散列对象，其散列值必然相同。<br>像字符串和数这样的不可变类型是可散列的，它们可以很好地用作字典键。元组对象也可以用作字典键，但这些元组本身必须只包含可散列类型。<br>想了解更多有关dict的知识，可以翻阅官方文档：<a href="https://docs.python.org/3/library/stdtypes.html#mapping-types-dict">Mapping Types — dict</a></p></blockquote><h3 id="collections-OrderDict——能记住键的插入顺序">collections.OrderDict——能记住键的插入顺序</h3><p>collections.OrderDict是特别的dict子类，该类型会记录添加到其中的键的插入顺序。</p><div class="note note-info">            <p>在Python3.7以后，标准的字典实现会保留键的插入顺序这一特性被固定下来了，当然，这只是CPython实现的一个副作用，如果在自己的工作中很需要用到键顺序，最好明确使用OrderedDict类。</p>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> collections<br><span class="hljs-meta">&gt;&gt;&gt; </span>d = collections.OrderedDict(one = <span class="hljs-number">1</span>, two = <span class="hljs-number">2</span>, three = <span class="hljs-number">3</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>d<br>OrderedDict([(<span class="hljs-string">&#x27;one&#x27;</span>, <span class="hljs-number">1</span>), (<span class="hljs-string">&#x27;two&#x27;</span>, <span class="hljs-number">2</span>), (<span class="hljs-string">&#x27;three&#x27;</span>, <span class="hljs-number">3</span>)])<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>d[<span class="hljs-string">&#x27;four&#x27;</span>] = <span class="hljs-number">4</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>d<br>OrderedDict([(<span class="hljs-string">&#x27;one&#x27;</span>, <span class="hljs-number">1</span>), (<span class="hljs-string">&#x27;two&#x27;</span>, <span class="hljs-number">2</span>), (<span class="hljs-string">&#x27;three&#x27;</span>, <span class="hljs-number">3</span>), (<span class="hljs-string">&#x27;four&#x27;</span>, <span class="hljs-number">4</span>)])<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>d.keys()<br>odict_keys([<span class="hljs-string">&#x27;one&#x27;</span>, <span class="hljs-string">&#x27;two&#x27;</span>, <span class="hljs-string">&#x27;three&#x27;</span>, <span class="hljs-string">&#x27;four&#x27;</span>])<br></code></pre></td></tr></table></figure><p>想了解更多有关collections.OrderedDict的知识，可以翻阅官方文档：<a href="https://docs.python.org/3/library/collections.html?highlight=collections%20ordereddict#collections.OrderedDict">collections.OrderedDict</a></p><h3 id="collections-defaultdict——为缺失的键返回默认值">collections.defaultdict——为缺失的键返回默认值</h3><p>defaultdict是另一个dict子类，其构造函数接受一个可调用对象，查找时如果找不到给定的键，就返回这个可调用对象。</p><blockquote><p>与使用<code>get()</code>方法或在普通字典中捕获KeyError异常相比，这种方式的代码较少，并能清晰地表达出程序员的意图。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict<br><span class="hljs-meta">&gt;&gt;&gt; </span>d = defaultdict(<span class="hljs-built_in">list</span>)<br><br><span class="hljs-comment"># 访问缺失的键就会用默认工厂方法创建它并初始化</span><br><span class="hljs-comment"># 在本例中工厂方法为list()</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>d[<span class="hljs-string">&#x27;none&#x27;</span>].append(<span class="hljs-number">1</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>d[<span class="hljs-string">&#x27;none&#x27;</span>].append(<span class="hljs-number">2</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>d[<span class="hljs-string">&#x27;none&#x27;</span>].append(<span class="hljs-number">3</span>)<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>d[<span class="hljs-string">&#x27;none&#x27;</span>]<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><p>可以看到我们在访问缺失的键时，对象 d 自动调用了list()方法为新键的值创建列表并返回这个列表。<br>想了解更多有关collections.defaultdict的知识，可以翻阅官方文档：<a href="https://docs.python.org/3/library/collections.html?highlight=collections%20defaultdict#collections.defaultdict">collections.defaultdict</a></p><h3 id="collections-ChainMap——搜索多个字典">collections.ChainMap——搜索多个字典</h3><p>collections.ChainMap将多个字典分组到一个映射中，在查找时逐个搜索底层映射，直到找到一个符合条件的键。对ChainMap进行插入、更新和删除操作，只会作用于其中的第一个字典。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> ChainMap<br><span class="hljs-meta">&gt;&gt;&gt; </span>d1 = &#123;<span class="hljs-string">&#x27;one&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;two&#x27;</span>: <span class="hljs-number">2</span>,&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>d2 = &#123;<span class="hljs-string">&#x27;three&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;four&#x27;</span>: <span class="hljs-number">4</span>,&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>chainDict = ChainMap(d1, d2)<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>chainDict<br>ChainMap(&#123;<span class="hljs-string">&#x27;one&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;two&#x27;</span>: <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-string">&#x27;three&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;four&#x27;</span>: <span class="hljs-number">4</span>&#125;)<br><br><span class="hljs-comment"># ChinaMap在内部从左到右逐个搜索，直到找到对应的键或全部搜索完毕。</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>chainDict[<span class="hljs-string">&#x27;three&#x27;</span>]<br><span class="hljs-number">3</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>chainDict[<span class="hljs-string">&#x27;one&#x27;</span>]<br><span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>chainDict[<span class="hljs-string">&#x27;none&#x27;</span>]<br>KeyError: <span class="hljs-string">&#x27;none&#x27;</span><br></code></pre></td></tr></table></figure><p>直观地看，我就觉得这东西像是一个包含字典的列表（像啊，很像啊！），操作（如查找）更方便的字典列表（误）。<br>想了解更多有关collections.ChainMap的知识，可以翻阅官方文档：<a href="https://docs.python.org/3/library/collections.html?highlight=collections%20chainmap#collections.ChainMap">collections.ChainMap</a></p><h3 id="types-MappingProxyType——用于创建只读字典">types.MappingProxyType——用于创建只读字典</h3><p>MappingProxyType封装了标准的字典，为封装的字典数据提供只读视图。<br>举例来说，如果希望返回一个字典来表示类或模块的内部状态，同时禁止向该对象写入内容，此时MappingProxyType就能派上用场。使用MappingProxyType无需创建完整的字典副本。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> types <span class="hljs-keyword">import</span> MappingProxyType<br><span class="hljs-meta">&gt;&gt;&gt; </span>writable = &#123;<span class="hljs-string">&#x27;one&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;two&#x27;</span>: <span class="hljs-number">2</span>,&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>readOnly = MappingProxyType(writable)<br><br><span class="hljs-comment"># 代理是只读的</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>readOnly[<span class="hljs-string">&#x27;one&#x27;</span>]<br><span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>readOnly[<span class="hljs-string">&#x27;one&#x27;</span>] = <span class="hljs-string">&#x27;one&#x27;</span><br>TypeError: <span class="hljs-string">&#x27;mappingproxy&#x27;</span> <span class="hljs-built_in">object</span> does <span class="hljs-keyword">not</span> support item assignment<br><br><span class="hljs-comment"># 更新原字典也会影响代理</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>writable[<span class="hljs-string">&#x27;one&#x27;</span>] = <span class="hljs-string">&#x27;one&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>readOnly<br>mappingproxy(&#123;<span class="hljs-string">&#x27;one&#x27;</span>: <span class="hljs-string">&#x27;one&#x27;</span>, <span class="hljs-string">&#x27;two&#x27;</span>: <span class="hljs-number">2</span>&#125;)<br></code></pre></td></tr></table></figure><p>想了解更多有关types.MappingProxyType的知识，可以翻阅官方文档：<a href="https://docs.python.org/3/library/types.html?highlight=types%20mappingproxytype#types.MappingProxyType">types.MappingProxyType</a></p><h2 id="记录、结构体和纯数据对象">记录、结构体和纯数据对象</h2><blockquote><p>与数组相比，记录数据结构中的字段数目固定，每个都有一个名称，类型也可以不同。<br>从这个概念出发，我们很容易地可以想到用python中的字典来实现记录，也可以用元组来实现没有字段名称的特殊记录。但是前者的缺点是没有对字段名称进行保护，后者则是没有字段名称。好在python中还提供了一些数据类型或类来帮助实现这些数据结构。</p></blockquote><h3 id="collections-namedtuple——方便的数据对象">collections.namedtuple——方便的数据对象</h3><p>namedtuple可以看作是普通元组的拓展，也是不可变容器，但是它的每个字段都有名称。也就是说，namedtuple是<strong>具有名称的元组</strong>。<br>namedtuple非常适合在python中以节省内存的方式快速手动定义一个不可变的类，所以也很适合用于实现记录数据类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> namedtuple<br><span class="hljs-meta">&gt;&gt;&gt; </span>Car = namedtuple(<span class="hljs-string">&#x27;Car&#x27;</span>, <span class="hljs-string">&#x27;color mileage automatic&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>car1 = Car(<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-number">3812.4</span>, <span class="hljs-literal">True</span>)<br><br><span class="hljs-comment"># 实例的__repr__方法</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>car1<br>Car(color=<span class="hljs-string">&#x27;red&#x27;</span>, mileage=<span class="hljs-number">3812.4</span>, automatic=<span class="hljs-literal">True</span>)<br><br><span class="hljs-comment"># 访问字段</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>car1.mileage<br><span class="hljs-number">3812.4</span><br><br><span class="hljs-comment"># 字段是不可变的</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>car1.mileage = <span class="hljs-number">12</span><br>AttributeError: can<span class="hljs-string">&#x27;t set attribute</span><br><span class="hljs-string">&gt;&gt;&gt; car1.windshield = &#x27;</span>broken<span class="hljs-string">&#x27;</span><br><span class="hljs-string">AttributeError: &#x27;</span>Ca<span class="hljs-string">r&#x27; object has no attribute &#x27;</span>windshield<span class="hljs-string">&#x27;</span><br></code></pre></td></tr></table></figure><p>想了解更多有关namedtuple的知识，可以翻阅官方文档：<a href="https://docs.python.org/3/library/collections.html?highlight=collections%20namedtuple#collections.namedtuple">collections.namedtuple</a></p><h3 id="typing-NamedTuple——改进版namedtuple">typing.NamedTuple——改进版namedtuple</h3><p>NamedTuple与namedtuple的主要区别就在于用新语法来定义记录类型并支持类型注解（type hint）。</p><blockquote><p>注意，只有像mypy这样独立的类型检查工具才会在意类型注解。不过即使没有工具支持，类型注解也可帮助其他程序员更好地理解代码（如果类型注解没有随代码及时更新则会带来混乱）。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> NamedTuple<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>(<span class="hljs-title class_ inherited__">NamedTuple</span>):<br>color: <span class="hljs-built_in">str</span><br>mileage: <span class="hljs-built_in">float</span><br>automatic: <span class="hljs-built_in">bool</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>car1 = Car(<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-number">3812.4</span>, <span class="hljs-literal">True</span>)<br><br><span class="hljs-comment"># 实例的__repr__方法</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>car1<br>Car(color=<span class="hljs-string">&#x27;red&#x27;</span>, mileage=<span class="hljs-number">3812.4</span>, automatic=<span class="hljs-literal">True</span>)<br><br><span class="hljs-comment"># 访问字段</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>car1.mileage<br><span class="hljs-number">3812.4</span><br><br><span class="hljs-comment"># 字段是不可变的</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>car1.mileage = <span class="hljs-number">12</span><br>AttributeError: can<span class="hljs-string">&#x27;t set attribute</span><br><span class="hljs-string">&gt;&gt;&gt; car1.windshield = &#x27;</span>broken<span class="hljs-string">&#x27;</span><br><span class="hljs-string">AttributeError: &#x27;</span>Ca<span class="hljs-string">r&#x27; object has no attribute &#x27;</span>windshield<span class="hljs-string">&#x27;</span><br><span class="hljs-string"></span><br><span class="hljs-string"># 只有像mypy这样的类型检查工具才会落实类型注解</span><br><span class="hljs-string">&gt;&gt;&gt; Car(&#x27;</span>red<span class="hljs-string">&#x27;, &#x27;</span>NOT_A_FLOAT<span class="hljs-string">&#x27;, 99)</span><br><span class="hljs-string">Car(color=&#x27;</span>red<span class="hljs-string">&#x27;, mileage=&#x27;</span>NOT_A_FLOAT<span class="hljs-string">&#x27;, automatic=99)</span><br></code></pre></td></tr></table></figure><p>想了解更多有关NamedTuple的知识，可以翻阅官方文档：<a href="https://docs.python.org/3/library/typing.html?highlight=typing%20namedtuple#typing.NamedTuple">typing.NamedTuple</a></p><h3 id="types-SimpleNamespace——花哨的属性访问">types.SimpleNamespace——花哨的属性访问</h3><p>SimpleNamespace同样可以用于创建数据对象，它主要提供通过属性访问的方式访问其名称空间。<br>也就是说，SimpleNamespace实例将其中的所有键都公开为类属性。因此访问属性时可以使用obj.key这样的点式语法，不需要像普通字典一样通过索引来访问值。</p><blockquote><p>正如其名，SimpleNamespace很简单，基本上就是扩展版的字典，能够很好地访问属性并以字符串打印出来，还能自由地添加、修改和访问属性。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> types <span class="hljs-keyword">import</span> SimpleNamespace<br><span class="hljs-meta">&gt;&gt;&gt; </span>car1 = SimpleNamespace(color = <span class="hljs-string">&#x27;red&#x27;</span>, mileage = <span class="hljs-number">3812.4</span>, automatic = <span class="hljs-literal">True</span>)<br><br><span class="hljs-comment"># 实例的__repr__方法</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>car1<br>namespace(color=<span class="hljs-string">&#x27;red&#x27;</span>, mileage=<span class="hljs-number">3812.4</span>, automatic=<span class="hljs-literal">True</span>)<br><br><span class="hljs-comment"># 实例支持属性访问并且是可变的</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>car1.mileage = <span class="hljs-number">12</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>car1.windshield = <span class="hljs-string">&#x27;broken&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">del</span> car1.automatic<br><span class="hljs-meta">&gt;&gt;&gt; </span>car1<br>namespace(color=<span class="hljs-string">&#x27;red&#x27;</span>, mileage=<span class="hljs-number">12</span>, windshield=<span class="hljs-string">&#x27;broken&#x27;</span>)<br></code></pre></td></tr></table></figure><p>想了解更多有关SimpleNamespace的知识，可以翻阅官方文档：<a href="https://docs.python.org/3/library/types.html?highlight=types%20simplenamespace#types.SimpleNamespace">types.SimpleNamespace</a></p><h3 id="为什么没有struct-Struct？">为什么没有struct.Struct？</h3><p>因为我认为这个东西太过高级<s>（懒）</s>，如同书中所说：“大多数情况下这都属于高级（且可能不必要的）优化。”如果想了解可以自行翻阅相关文档。</p><h2 id="集合和多重集合">集合和多重集合</h2><p><strong>集合</strong>含有一组不含重复元素的<strong>无序</strong>对象。集合可用来快速检查元素的包含性，插入或删除值，计算两个集合的并集或交集。<br>在python中，集合和字典一样，也拥有语法糖：利用花括号表达式就可以快速创建集合，但是要注意，如果需要创建<strong>空集</strong>（不含任何元素的集合），就要用<code>set()</code>构造函数，如果用空花括号<code>&#123;&#125;</code>的话，创建的是一个空字典。</p><h3 id="set——首选集合实现">set——首选集合实现</h3><p>set就是Python中的内置集合实现，可以看成是最基本的集合。set类型是可变的，能够动态插入和删除元素，所有可散列的对象都可以存储在集合中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>animal = &#123;<span class="hljs-string">&#x27;cat&#x27;</span>, <span class="hljs-string">&#x27;bird&#x27;</span>, <span class="hljs-string">&#x27;dog&#x27;</span>, <span class="hljs-string">&#x27;panda&#x27;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&#x27;cat&#x27;</span> <span class="hljs-keyword">in</span> animal<br><span class="hljs-literal">True</span><br><br><span class="hljs-comment"># intersection方法返回包含存在于集合 x 和集合 y 中的项目的集合（返回集合 x 和集合 y 的交集）</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>my_pet = &#123;<span class="hljs-string">&#x27;cat&#x27;</span>, <span class="hljs-string">&#x27;dog&#x27;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>my_pet.intersection(animal)<br>&#123;<span class="hljs-string">&#x27;dog&#x27;</span>, <span class="hljs-string">&#x27;cat&#x27;</span>&#125;<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>animal.add(<span class="hljs-string">&#x27;bat&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>animal<br>&#123;<span class="hljs-string">&#x27;dog&#x27;</span>, <span class="hljs-string">&#x27;cat&#x27;</span>, <span class="hljs-string">&#x27;bat&#x27;</span>, <span class="hljs-string">&#x27;panda&#x27;</span>, <span class="hljs-string">&#x27;bird&#x27;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">len</span>(animal)<br><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>想了解更多有关set的知识，可以翻阅官方文档：<a href="https://docs.python.org/3/library/stdtypes.html?highlight=set#set">set</a></p><h3 id="frozenset——不可变集合">frozenset——不可变集合</h3><p>其实看名字就知道这是什么东西啦，就是一个静态集合，里边的元素只读不改。因此frozenset是可用作字典的键的（静态且可散列），也可以放置在另一个集合中，这些都是set没办法做到的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>vowels = <span class="hljs-built_in">frozenset</span>(&#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;u&#x27;</span>&#125;)<br><span class="hljs-meta">&gt;&gt;&gt; </span>vowels.add(<span class="hljs-string">&#x27;p&#x27;</span>)<br>AttributeError: <span class="hljs-string">&#x27;frozenset&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;add&#x27;</span><br><br><span class="hljs-comment"># frozenset用作字典键</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>d = &#123;<span class="hljs-built_in">frozenset</span>(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;): <span class="hljs-string">&#x27;hello&#x27;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>d[<span class="hljs-built_in">frozenset</span>(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;)]<br><span class="hljs-string">&#x27;hello&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>key = <span class="hljs-built_in">frozenset</span>(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;)<br><span class="hljs-meta">&gt;&gt;&gt; </span>d[key]<br><span class="hljs-string">&#x27;hello&#x27;</span><br></code></pre></td></tr></table></figure><p>想了解更多有关frozenset的知识，可以翻阅官方文档：<a href="https://docs.python.org/3/library/stdtypes.html?highlight=frozenset#frozenset">frozenset</a></p><h3 id="collections-Counter——多重集合">collections.Counter——多重集合</h3><p>其实这个东西也非常简单，就是允许出现重复元素（允许在集合中多次出现同一个元素）的集合，它也叫做背包（bag）类型。</p><blockquote><p>如果既要检查元素是否为集合的一部分，又要记录元素在集合中出现的次数，那么就需要用到这个类型</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter<br><span class="hljs-meta">&gt;&gt;&gt; </span>inventory = Counter()<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>loot = &#123;<span class="hljs-string">&#x27;sword&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;bread&#x27;</span>: <span class="hljs-number">3</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>inventory.update(loot)<br><span class="hljs-meta">&gt;&gt;&gt; </span>inventory<br>Counter(&#123;<span class="hljs-string">&#x27;bread&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;sword&#x27;</span>: <span class="hljs-number">1</span>&#125;)<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>more_loot = &#123;<span class="hljs-string">&#x27;sword&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;apple&#x27;</span>: <span class="hljs-number">1</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>inventory.update(more_loot)<br><span class="hljs-meta">&gt;&gt;&gt; </span>inventory<br>Counter(&#123;<span class="hljs-string">&#x27;bread&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;sword&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;apple&#x27;</span>: <span class="hljs-number">1</span>&#125;)<br></code></pre></td></tr></table></figure><p>想了解更多有关Counter的知识，可以翻阅官方文档：<a href="https://docs.python.org/3/library/collections.html?highlight=counter#collections.Counter">collections.Counter</a></p><h2 id="栈与队列">栈与队列</h2><p><strong>栈</strong>是含有一组对象的容器，支持快速<strong>后进先出（LIFO）<strong>的插入（<strong>入栈push</strong>）和删除（<strong>出栈pop</strong>）操作。<br><strong>队列</strong>则是</strong>先进先出（FIFO）</strong>，插入和删除分别称作<strong>入队enqueue</strong>和<strong>出队dequeue</strong>。<br>可以很容易地想到用python内置的列表来实现，但是列表只对随机访问的性能好，对于插入和删除元素则差，所以python在这方面还提供了另外的类来实现。</p><h3 id="collections-deque——快速且稳健的栈">collections.deque——快速且稳健的栈</h3><p>deque类实现了一个双端队列，所以它既可以作为栈也可以作为队列。</p><blockquote><p>Python的deque对象以双向链表实现，这为插入和删除元素提供了出色且一致的性能，但是随机访问位于栈中间元素的性能很差，耗时为O(n)。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br><span class="hljs-meta">&gt;&gt;&gt; </span>s = deque()<br><span class="hljs-meta">&gt;&gt;&gt; </span>s.append(<span class="hljs-string">&#x27;eat&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>s.append(<span class="hljs-string">&#x27;sleep&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>s.append(<span class="hljs-string">&#x27;code&#x27;</span>)<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>s<br>deque([<span class="hljs-string">&#x27;eat&#x27;</span>, <span class="hljs-string">&#x27;sleep&#x27;</span>, <span class="hljs-string">&#x27;code&#x27;</span>])<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>s.pop()<br><span class="hljs-string">&#x27;code&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>s.pop()<br><span class="hljs-string">&#x27;sleep&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>s.pop()<br><span class="hljs-string">&#x27;eat&#x27;</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>s.pop()<br>IndexError: pop <span class="hljs-keyword">from</span> an empty deque<br></code></pre></td></tr></table></figure><p>想了解更多有关deque的知识，可以翻阅官方文档：<a href="https://docs.python.org/3/library/collections.html?highlight=collections%20deque#collections.deque">collections.deque</a></p><h3 id="queue-LifoQueue——为并行计算提供的锁语义">queue.LifoQueue——为并行计算提供的锁语义</h3><p>queue.LifoQueue这个位于Python标准库中的栈实现是同步的，提供了锁语义来支持多个并发的生产者和消费者。（可以参考一下PV操作）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> queue <span class="hljs-keyword">import</span> LifoQueue<br><span class="hljs-meta">&gt;&gt;&gt; </span>s = LifoQueue()<br><span class="hljs-meta">&gt;&gt;&gt; </span>s.put(<span class="hljs-string">&#x27;eat&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>s.put(<span class="hljs-string">&#x27;sleep&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>s.put(<span class="hljs-string">&#x27;code&#x27;</span>)<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>s<br>&lt;queue.LifoQueue <span class="hljs-built_in">object</span> at <span class="hljs-number">0x000001E3F4D22430</span>&gt;<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>s.get()<br><span class="hljs-string">&#x27;code&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>s.get()<br><span class="hljs-string">&#x27;sleep&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>s.get()<br><span class="hljs-string">&#x27;eat&#x27;</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>s.get()<br><span class="hljs-comment"># 阻塞，永远停在这里...</span><br></code></pre></td></tr></table></figure><p>想了解更多有关LifoQueue的知识，可以翻阅官方文档：<a href="https://docs.python.org/3/library/queue.html?highlight=queue%20lifoqueue#queue.LifoQueue">queue.LifoQueue</a></p><h3 id="collections-deque——快速且稳健的队列">collections.deque——快速且稳健的队列</h3><p>上边已经介绍过所以在这里不重复叙述了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br><span class="hljs-meta">&gt;&gt;&gt; </span>q = deque()<br><span class="hljs-meta">&gt;&gt;&gt; </span>q.append(<span class="hljs-string">&#x27;eat&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>q.append(<span class="hljs-string">&#x27;sleep&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>q.append(<span class="hljs-string">&#x27;code&#x27;</span>)<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>q<br>deque([<span class="hljs-string">&#x27;eat&#x27;</span>, <span class="hljs-string">&#x27;sleep&#x27;</span>, <span class="hljs-string">&#x27;code&#x27;</span>])<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>q.popleft()<br><span class="hljs-string">&#x27;eat&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>q.popleft()<br><span class="hljs-string">&#x27;sleep&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>q.popleft()<br><span class="hljs-string">&#x27;code&#x27;</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>q.popleft()<br>IndexError: pop <span class="hljs-keyword">from</span> an empty deque<br></code></pre></td></tr></table></figure><p>想了解更多有关deque的知识，可以翻阅官方文档：<a href="https://docs.python.org/3/library/collections.html?highlight=collections%20deque#collections.deque">collections.deque</a></p><h3 id="queue-Queue——为并行计算提供的锁语义">queue.Queue——为并行计算提供的锁语义</h3><p>参考LifoQueue。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> queue <span class="hljs-keyword">import</span> Queue<br><span class="hljs-meta">&gt;&gt;&gt; </span>q = Queue()<br><span class="hljs-meta">&gt;&gt;&gt; </span>q.put(<span class="hljs-string">&#x27;eat&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>q.put(<span class="hljs-string">&#x27;sleep&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>q.put(<span class="hljs-string">&#x27;code&#x27;</span>)<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>q<br>&lt;queue.Queue <span class="hljs-built_in">object</span> at <span class="hljs-number">0x0000026060A55FA0</span>&gt;<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>q.get()<br><span class="hljs-string">&#x27;eat&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>q.get()<br><span class="hljs-string">&#x27;sleep&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>q.get()<br><span class="hljs-string">&#x27;code&#x27;</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>q.get()<br><span class="hljs-comment"># 阻塞，永远停在这里...</span><br></code></pre></td></tr></table></figure><p>想了解更多有关Queue的知识，可以翻阅官方文档：<a href="https://docs.python.org/3/library/queue.html?highlight=queue%20queue#queue.Queue">queue.Queue</a></p><h2 id="优先队列">优先队列</h2><p>优先队列是一个容器数据结构，使用具有<a href="zh.wikipedia.org/zh-hans/%E5%85%A8%E5%BA%8F%E5%85%B3%E7%B3%BB">全序关系</a>的键（例如用数值表示的权重）来管理元素，以便快速访问容器中键值<strong>最小</strong>或<strong>最大</strong>的元素。<br>所以说python的列表挺全能了，甚至也能当优先队列，只不过每次添加新元素时，都要重新排序。<br>当然了，也有其他办法实现优先队列。</p><h3 id="heapq——基于列表的二叉堆">heapq——基于列表的二叉堆</h3><p>heapq是二叉堆，通常用普通列表实现，能在O(logn)时间内插入和获取最小的元素。</p><blockquote><p>由于heapq在技术上只提供最小堆实现，因此必须添加额外步骤来确保排序稳定性，以此来获得“实际”的优先级队列中所含有的预期特性。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> heapq<br><br>q = []<br>heapq.heappush(q, (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;code&#x27;</span>))<br>heapq.heappush(q, (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;eat&#x27;</span>))<br>heapq.heappush(q, (<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;sleep&#x27;</span>))<br><br><span class="hljs-keyword">while</span> q:<br>    next_item = heapq.heappop(q)<br>    <span class="hljs-built_in">print</span>(next_item)<br><br><span class="hljs-comment"># 输出如下</span><br><span class="hljs-comment"># (1, &#x27;eat&#x27;)</span><br><span class="hljs-comment"># (2, &#x27;code&#x27;)</span><br><span class="hljs-comment"># (3, &#x27;sleep&#x27;)</span><br></code></pre></td></tr></table></figure><p>想了解更多有关heapq的知识，可以翻阅官方文档：<a href="https://docs.python.org/3.9/library/heapq.html?highlight=heapq#module-heapq">heapq</a></p><h3 id="queue-PriorityQueue——美丽的优先级队列">queue.PriorityQueue——美丽的优先级队列</h3><p>其实这个类就是在内部使用了heapq来实现优先级队列，相当于让程序员看起来更容易明白。而且它是基于类的接口，而不像heapq是基于函数的接口。</p><blockquote><p>PriorityQueue是同步的，提供了锁语义来支持多个并发的生产者和消费者。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> queue <span class="hljs-keyword">import</span> PriorityQueue<br><br>q = PriorityQueue()<br>q.put((<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;code&#x27;</span>))<br>q.put((<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;eat&#x27;</span>))<br>q.put((<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;sleep&#x27;</span>))<br><br><span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> q.empty():<br>    next_item = q.get()<br>    <span class="hljs-built_in">print</span>(next_item)<br><br><span class="hljs-comment"># 输出如下</span><br><span class="hljs-comment"># (1, &#x27;eat&#x27;)</span><br><span class="hljs-comment"># (2, &#x27;code&#x27;)</span><br><span class="hljs-comment"># (3, &#x27;sleep&#x27;)</span><br></code></pre></td></tr></table></figure><p>想了解更多有关PriorityQueue的知识，可以翻阅官方文档：<a href="https://docs.python.org/3.9/library/queue.html?highlight=queue%20priorityqueue#queue.PriorityQueue">queue.PriorityQueue</a></p><h1>尾声</h1><p>在我不断地拖延症发作下漫长的更新终于结束啦蛤蛤蛤马上就有又会接着更新的现在就先这样啦</p><hr><p>参考书目： 《Python Tricks 深入理解python特性》 [德]达恩·巴德尔 人民邮电出版社</p>]]></content>
    
    
    <categories>
      
      <category>Learning Log</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PYQT6疑难杂症解决方案</title>
    <link href="/2022/06/15/pyqt-essay-1/"/>
    <url>/2022/06/15/pyqt-essay-1/</url>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>谁能想到课程设计要用pyqt+qt来写呢？我是没想到的。还好是老师会给课件，这下一周速通了。问题是老师给的pyqt5，而我作死用pyqt6导致自己碰一大堆壁。<br>所以这篇随笔就是把碰的壁整合一下，不知道以后有没有机会用到（虽然我并不是很喜欢用python来干这种事情（指写GUI和操作数据库））。</p><h1>正文</h1><h2 id="QPalette-setColor">QPalette.setColor</h2><p>在pyqt5里边，是这么写的：<code>palette1.setColor(palette1.Background, QtGui.QColor(255,  210,  210))</code><br>但是在pyqt6里边，多了两个东西，ColorRole 和 ColorGroup，这就导致你要这么写：<code>palette1.setColor(palette1.ColorRole.Window, QtGui.QColor('gray'))</code><br>上边的Background是被弃用了的，取而代之的是Window，而Window归于ColorRole，所以写法大大地不同（闷了）。</p><div class="note note-warning">            <p>设置某些控件的字体颜色的时候不要用调色盘！！！比如QLabel和QPlainTextEdit，用他们自带的<code>setStyleSheet()</code>，向里面传字符串<code>&quot;color: xx&quot;</code>，xx替换成相应颜色。</p>          </div><h2 id="关于鼠标相关的事件">关于鼠标相关的事件</h2><p>其实每个组件都已经写好了相关事件，只不过有些组件本来就没必要和鼠标进行交互当然不会触发相关事件。但是我们可以自己编写自己的类，通过继承和重载来对鼠标的信号作出反应。<br>和鼠标事件有关的方法有：<code>mousePressEvent(self, event)</code>、<code>wheelEvent(self, event)</code>、<code>mouseDoubieCiickEvent(self, event)</code>、<code>mouseReleaseEvent(self, event)</code>、<code>mouseMoveEvent(self, event)</code>、<code>enterEvent(self, event)</code>和<code>leaveEvent(self, event)</code>。<br>分别是：鼠标按下事件、滚轮滚动事件、鼠标双击事件、鼠标释放事件、鼠标移动事件、鼠标进入控件事件和鼠标离开控件事件。鼠标按下事件中可以通过event来获取具体按下的键再来配置更详细的操作。</p><div class="note note-warning">            <p>如果要实现实时监测鼠标移动，需要<code>setMouseTracking(True)</code>，否则只会在<code>mousePress</code>的时候触发鼠标移动事件。</p>          </div><h2 id="关于pyqt6把pyrcc删除了这件事">关于pyqt6把pyrcc删除了这件事</h2><p>老师给的课件用的是pyqt5，此时还存在pyrcc5这种东西，但是到了6能编译资源文件的pyrcc就惨遭阉割（误）。结果弄到我在这里卡了挺久，找了个什么pyqt6rc装一下不仅没用还把我pyqt6搞崩了，郁闷。<br>但是我们可以用pyside6-rcc进行编译（我是没想到的）。我们需要先安装pyside6：<code>pip install pyside6</code>，安装成功后，进入到资源文件所在文件夹中，使用命令：<code>pyside6-rcc res.qrc -o res.py</code>即可编译。<br>但是pyuic6编译后的py文件中不会自带<code>import res</code>，需要我们手动写进去。</p><h2 id="关于我的电脑时区为了登上xbox改成了香港特别行政区结果数字全显示成苏州码子这件事">关于我的电脑时区为了登上xbox改成了香港特别行政区结果数字全显示成苏州码子这件事</h2><p>如果你发现数字显示成苏州码子：〡〢〣〤〥〦〧〨〩<br>把电脑时区改回来！具体操作：控制面板 -&gt; 时钟和区域 -&gt; 区域，格式改成：中文(简体，中国)。</p><h2 id="关于pyCharm读取数据库或文件导致程序崩溃报错-1073740791-0xC0000409">关于pyCharm读取数据库或文件导致程序崩溃报错-1073740791 (0xC0000409)</h2><p>菜单栏Run -&gt; Edit Configuration，把Emulate terminal in output console勾选上。</p><h2 id="关于pyqt6里边枚举类型是：类名-枚举名-枚举值这件事">关于pyqt6里边枚举类型是：类名.枚举名.枚举值这件事</h2><p>简单的例子，pyqt5里边：<code>self.tabModel.setEditStrategy(QSqlTableModel.OnManualSubmit)</code>，pyqt6里边：<code>self.tabModel.setEditStrategy(QSqlTableModel.EditStrategy.OnManualSubmit)</code><br>就这么简单。虽然老师提醒过了但是我一开始根本就没想到这里面是枚举。查文档看到的确存在这种属性，然后又忽略了枚举。闷了很久，突然就灵光一闪这不是枚举值吗，不会是枚举的锅吧！然后就解决了。。。</p><h2 id="关于某些时候一些行为触发两次相同的槽函数这件事">关于某些时候一些行为触发两次相同的槽函数这件事</h2><p>本来是不想管的，但是open两次数据库就直接炸了啊我能不管吗？最简单的解决办法：给槽函数上@pyqtSlot()装饰器。</p><h2 id="关于QSqlTableMode、QSqlQueryModel、QSqlRelationalTableMode、QSqlQuery这四个东西用来干嘛">关于QSqlTableMode、QSqlQueryModel、QSqlRelationalTableMode、QSqlQuery这四个东西用来干嘛</h2><p>在课件里边，老师是这么用的：<code>QSqlTableMode</code>用来写了对数据库进行增删查改等操作的界面，<code>QSqlQueryModel</code>用来写对数据库进行查询的界面，从这里边我们就能很好地总结出：前者可以对数据库进行读写操作，而后者对数据库是只读的。<br>在网络上也找了一点说法：</p><blockquote><p>提供了一个sql查询结果的只读数据模型。它从查询QSqlQueryModel获取数据。可以方便的用于在QListView, QTableView, QTreeView等各种view上展示数据。但它是只读的，不能编辑。<br>继承于QSqlQueryModel，与QSqlQueryModel功能相似。比QSqlQueryModel的限制在于不能是任意sql语句，只是对单个数据表操作。拓展在于在各种view上展示表格数据的同时，还允许用户进行编辑操作。</p></blockquote><p>那<code>QSqlRelationalTableMode</code>是用来干什么的呢？在课件里边，它被用来做便捷的联合查询操作（也可以对数据表进行操作），且可以快速设置代理组件而不需要自己手写。<br>还有最后一个<code>QSqlQuery</code>，简单地说就是用来执行sql语句的。</p><h2 id="关于pyqt6里的QChart没有axisX-这个东西">关于pyqt6里的QChart没有axisX()这个东西</h2><p>这是课件里pyqt5的做法:<code>chart.removeAxis(chart.axisX())  # 删除坐标轴</code><br>但是pyqt6他没有啊，他又没有了啊！找了半天有个可以返回全部坐标轴列表的方法，于是我改成了下边的写法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> chart.axes():<br>    <span class="hljs-keyword">for</span> axis <span class="hljs-keyword">in</span> chart.axes():<br>        chart.removeAxis(axis)  <span class="hljs-comment"># 删除坐标轴</span><br></code></pre></td></tr></table></figure><p>你以为就结束了啊？你要把坐标轴加上去用的也不是<code>setAxisX()</code>而是<code>addAxis()</code>了。详细对比下面两句：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">chart.addAxis(axisStud, Qt.AlignmentFlag.AlignLeft)  <span class="hljs-comment"># pyqt6写法</span><br>chart.setAxisY(axisStud, seriesBar)  <span class="hljs-comment"># pyqt5写法</span><br></code></pre></td></tr></table></figure><h1>结语</h1><p>做完课设人已经麻了，谢谢。</p><hr>]]></content>
    
    
    <categories>
      
      <category>Essay</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>PyQt6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python随笔-4</title>
    <link href="/2022/06/13/python-essay-4/"/>
    <url>/2022/06/13/python-essay-4/</url>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>临近期末周了，所以人也闲下来一点了。什么？你问我期末不复习吗？啊，挂科嘛，不要紧的（迫真<br>刚好Matplotlib可能在某些地方要用上，某本书上也有讲例子，就跑来学学了。这篇随笔估计非常杂，关于Matplotlib的什么东西都可能扔上来www，不过有目录应该会清晰许多。</p><h1>正文</h1><h2 id="Matplotlib的安装">Matplotlib的安装</h2><p>CMD执行pip命令：<code>pip install --user matplotlib</code><br>终端执行pip命令：<code>$ python -m pip install --user matplotlib</code></p><div class="note note-warning">            <p>在macOS系统中，若操作不成功，请尝试删去–user再次执行。</p>          </div><p>在pyCharm中，用的解释器可能是虚拟环境中的解释器，可按如下步骤安装Matplotlib：<br>File -&gt; Settings -&gt; Project: Project Name -&gt; Project Interpreter<br><img src="https://s1.ax1x.com/2022/06/13/XRmj1A.png" alt="1-1"><br><img src="https://s1.ax1x.com/2022/06/13/XRmv6I.png" alt="1-2"><br>点击 + 号，然后在搜索框中输入Matplotlib，选中后安装即可。<br><img src="https://s1.ax1x.com/2022/06/13/XRmxXt.png" alt="1-3"></p><div class="note note-info">            <p>pyCharm懒狗型安装方法：直接在python文件中先用import导入matplotlib包，会报错，鼠标放到import代码上会显示浮动窗口，有直接安装操作。</p>          </div><div class="note note-info">            <p>如果pyCharm把matplotlib默认输出到Sciview了，而你又不想这么做，那么可以通过<strong>Settings -&gt; Tools -&gt; Python Scientific</strong>找到<strong>Show plots in toolwindow</strong>选项，取消勾选即可。</p>          </div><h2 id="Matplotlib的导入">Matplotlib的导入</h2><p><code>import matplotlib.pyplot as plt</code><br>使用别名plt是因为官方这么用所以跟风（bushi）就完事了</p><h2 id="Matplotlib输出中文">Matplotlib输出中文</h2><p>建议不要使用Matplotlib输出中文（比如图表标题）以避免出现无法正确显示文字的问题，但是也不是没有办法。<br>输入这行代码即可：<code>plt.rcParams['font.sans-serif'] = ['SimHei']</code><br>SimHei是微软雅黑字体。</p><div class="note note-warning">            <p>如果还需要执行其他代码如设置样式：<code>plt.style.use('seaborn')</code>，请在这一系列代码最后面加入字体设置代码，否则有可能出现仍然无法显示中文字体的问题。</p>          </div><h2 id="使用内置样式">使用内置样式</h2><p>可以在终端执行如下命令来查看有哪些样式可供使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-meta">&gt;&gt;&gt; </span>plt.style.available<br></code></pre></td></tr></table></figure><h2 id="某些注意事项">某些注意事项</h2><ol><li>向<code>plot()</code>提供一系列数时，它假设第一个数据点对应的<strong>x</strong>坐标值为0。</li><li>使用<code>plot()</code>时可指定各种实参，还可以使用众多函数对图形进行定制。</li><li>可以使用列表解析生成需要的值，再传递列表。</li></ol><hr>]]></content>
    
    
    <categories>
      
      <category>Essay</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux随笔-1</title>
    <link href="/2022/05/27/linux-essay-1/"/>
    <url>/2022/05/27/linux-essay-1/</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>文章内容来源：《Linux命令行与shell脚本编程大全（第3版）》 [美] Richard Blum  Christine Bresnahan 著 人民邮电出版社</p>          </div><h1>前言</h1><p>虽然说是前几天在操作系统上机课上就看完想写的东西但是由于各种事情拖到了今天。。。<br>算是刚接触Linux操作系统吧，所以就写了这么一个东西自用，作为快速参考。以后学到了什么相关内容可能也会在这里补充。</p><h1>正文</h1><h2 id="Vim快速参考">Vim快速参考</h2><h3 id="启动Vim编辑器">启动Vim编辑器</h3><p>命令：<code>vim 文件名</code><br>示例：<code>vim myprog.c</code></p><h3 id="插入（文本编辑）模式">插入（文本编辑）模式</h3><p>按 <strong>i</strong> 键进入。该模式下有如下命令：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>x</td><td>删除当前光标所在位置的字符</td></tr><tr><td>dd</td><td>删除当前光标所在行</td></tr><tr><td>dw</td><td>删除当前光标所在位置的单词</td></tr><tr><td>d$</td><td>删除当前光标所在位置至行尾的内容</td></tr><tr><td>J</td><td>删除当前光标所在行行尾的换行符</td></tr><tr><td>u</td><td>撤销前一编辑命令</td></tr><tr><td>a</td><td>在当前光标后追加数据</td></tr><tr><td>A</td><td>在当前光标所在行行尾追加数据</td></tr><tr><td>r <em>char</em></td><td>用<em>char</em>替换当前光标所在位置的单个字符</td></tr><tr><td>R <em>text</em></td><td>用<em>text</em>覆盖当前光标所在位置的数据，直到按下ESC键</td></tr></tbody></table><div class="note note-info">            <p>有些编辑命令允许使用数字修饰符来指定重复该命令多少次。比如，命令<code>2x</code>会删除从光标当前位置开始的两个字符，命令<code>5dd</code>会删除从光标当前所在行开始的5行。</p>          </div><h4 id="剪切、复制和粘贴">剪切、复制和粘贴</h4><p>vim在删除数据时，实际上会将数据保存在单独的一个寄存器中，可以用<code>p</code>命令取回数据。<br>所以，vim中的剪切和粘贴操作其实就是先删除数据，再移动光标至想要粘贴的位置，然后用<code>p</code>命令。<br>vim中的复制命令是<code>y</code>（代表yank），可以在<code>y</code>后面使用和<code>d</code>命令相同的第二字符（d、w、$）。<br>为了方便复制，我们可以按下<code>v</code>键进入<strong>可视模式</strong>，<strong>可视模式</strong>会在你移动光标时高亮显示文本。在覆盖了要复制的文本后，按下<code>y</code>键就好了。</p><h3 id="普通模式">普通模式</h3><p>在插入模式下按 <strong>esc</strong> 键进入。该模式下可移动光标，命令如下：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>h</td><td>左移一个字符</td></tr><tr><td>j</td><td>下移一行（文本中的下一行）</td></tr><tr><td>k</td><td>上移一行（文本中的上一行）</td></tr><tr><td>l</td><td>右移一个字符</td></tr><tr><td>PageDown（或Ctrl+F）</td><td>下翻一屏</td></tr><tr><td>PageUp（或Ctrl+B）</td><td>下翻一屏</td></tr><tr><td>G</td><td>移到缓冲区的最后一行</td></tr><tr><td>num G</td><td>移动到缓冲区中的第num行</td></tr><tr><td>gg</td><td>移到缓冲区的第一行</td></tr></tbody></table><h3 id="命令行模式">命令行模式</h3><p>普通模式下按 <strong>:</strong> 键进入。该模式下有如下命令：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>q</td><td>如果未修改缓存区数据，退出</td></tr><tr><td>q!</td><td>取消所有对缓冲区数据的修改并退出</td></tr><tr><td>w <em>filename</em></td><td>将文件保存到另一个文件中</td></tr><tr><td>wq</td><td>将缓冲区数据保存到文件中并退出</td></tr></tbody></table><h2 id="终端快速参考">终端快速参考</h2><h3 id="访问终端">访问终端</h3><p>图形化桌面下可尝试右键桌面，看弹出的菜单选项中有无该选项。<br>利用快捷键访问（进入）不同终端：<code>Ctrl + Alt + (F1~F7)</code></p><h3 id="设置终端背景颜色">设置终端背景颜色</h3><div class="note note-warning">            <p>*终端内输入指令</p>          </div><table><thead><tr><th>说明</th><th>命令</th></tr></thead><tbody><tr><td>开启该设置选项</td><td><code>settern -inversescreen on</code></td></tr><tr><td>设置背景色</td><td><code>settern -background white</code></td></tr><tr><td>设置前景色</td><td><code>settern -foreground black</code></td></tr></tbody></table><div class="note note-info">            <p>可供选择的颜色：black、red、green、yellow、blue、magenta、cyan、white</p>          </div><h3 id="Gnome-Terminal快捷键">Gnome Terminal快捷键</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>Shift+Ctrl+N</td><td>在新的窗口启动一个新的shell会话</td></tr><tr><td>Shift+Ctrl+T</td><td>在当前窗口启动一个新的shell会话</td></tr><tr><td>Shift+Ctrl+W</td><td>关闭当前标签中的会话</td></tr><tr><td>Shift+Ctrl+Q</td><td>关闭当前的Gnome Terminal会话</td></tr><tr><td>Shift+Ctrl+C/V</td><td>复制/粘贴</td></tr><tr><td>Shift+Ctrl+F</td><td>打开Find窗口</td></tr><tr><td>Shift+Ctrl+H/G</td><td>从终端会话的当前位置开始向后/向前搜索指定文本</td></tr><tr><td>Shift+Ctrl+PageUp/PageDown</td><td>使当前标签移动到前一个标签的前面/下一个标签的后面</td></tr><tr><td>Ctrl+PageDown/PageUp</td><td>使上一个/下一个标签成为活动标签</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Essay</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python随笔-3</title>
    <link href="/2022/05/22/python-essay-3/"/>
    <url>/2022/05/22/python-essay-3/</url>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>最近挺忙的（指打游戏）所以导致摸了很久（包括学习），现在痛定思痛，于是乎毅然决然写<s>（水）</s>一篇博文来规避内疚感<s>（不是）</s>。<br>其实还是有看（一点）的，这篇随笔要介绍的都是和类与面向对象有关的，那么不（想）多说了直接进入正文了。</p><h1>正文</h1><h2 id="is-和">is 和 ==</h2><p>在python中，<code>==</code>比较的是相等性，而<code>is</code>比较的是相同性，当我们用<code>==</code>时，比较的是值，当我们用<code>is</code>时，比较的是标识符。这么说可能非常难懂，所以直接在python中写点代码会好很多。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>b = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>a == b<br><span class="hljs-literal">True</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>a <span class="hljs-keyword">is</span> b<br><span class="hljs-literal">False</span><br><br>&gt;&gt;&gt;b = a<br>&gt;&gt;&gt;a <span class="hljs-keyword">is</span> b<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>这里我们可以看到，由于 a 和 b 的值是相等的，所以<code>a == b</code>为True，但是很明显 a 和 b 的标识符是不同的，所以结果输出了False。而在执行了<code>b = a</code>后，由于标识符相同了，所以现在<code>a is b</code>的结果是True了。</p><blockquote><p>来概括一下吧，用两条定义区分is和==的区别：<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="《Python Tricks 深入理解python特性》 [德]达恩·巴德尔 人民邮电出版社">[1]</span></a></sup></p><blockquote><p>当两个变量指向同一个对象时，is表达式的结果为True；<br>当各变量指向的对象含有相同内容时，==表达式的结果为True。</p></blockquote></blockquote><h2 id="字符串转换">字符串转换</h2><p>有的时候我们想把我们实例化类的对象的内容（信息）打印出来，我们希望最好是这么做：<code>print(a_object)</code>，但是理所当然的不会像你想的那样输出你想要的结果。<br>如果直接打印的话，我们的得到的是一个包含类名和实例对象的标识符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pet</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, specie</span>):<br>        self.name = name<br>        self.specie = specie<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>my_pet = Pet(<span class="hljs-string">&#x27;white&#x27;</span>, <span class="hljs-string">&#x27;cat&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(my_pet)<br>&lt;__main__.Pet <span class="hljs-built_in">object</span> at <span class="hljs-number">0x0000019E5BDFCF40</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>my_pet<br>&lt;__main__.Pet <span class="hljs-built_in">object</span> at <span class="hljs-number">0x0000019E5BDFCF40</span>&gt;<br></code></pre></td></tr></table></figure><p>为了解决这个问题，我们可以自己在类里构建一个方法来对打印的实例对象进行字符串转换，但是我们不需要这么做（不要构建自己的字符串转换机制），因为Python提供了两个双下划线方法<code>__str__</code>和<code>__repr__</code>在不同的情况下来将对象转换成字符串。<br>现在我们在上边的类中添加一个<code>__str__</code>方法，再用print输出，这时候就可以转换成我们想要的字符串了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pet</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, specie</span>):<br>        self.name = name<br>        self.specie = specie<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;The <span class="hljs-subst">&#123;self.specie&#125;</span>\&#x27;s name is <span class="hljs-subst">&#123;self.name&#125;</span>.&#x27;</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>my_pet = Pet(<span class="hljs-string">&#x27;white&#x27;</span>, <span class="hljs-string">&#x27;cat&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(my_pet)<br>The cat<span class="hljs-string">&#x27;s name is white.</span><br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>“在Python解释器会话中查看对象得到的是对象的__repr__结果。<br>像列表和字典这样的容器总是使用__repr__的结果来表示所包含的对象，哪怕对容器本身调用str()也是如此。”</p>          </div><p>我们也可以手动选择两种方法中的一种，用<code>str()</code>或是<code>repr()</code>即可，最好不要用<code>对象名.__str__</code>或是<code>对象名.__repr__</code>。<br>那他们的具体差别在哪里呢？这里我觉得书中的例子非常好，所以摘录书中内容来介绍。</p><blockquote><p>对于这样的问题，可以看看Python标准库是怎么做的。现在再设计一个实验，创建一个datetime.date对象，看这个对象如何使用__repr__和__str__来控制字符串转换：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> datetime<br><span class="hljs-meta">&gt;&gt;&gt; </span>today = datetime.date.today()<br></code></pre></td></tr></table></figure><p>在date对象上，__str__函数的结果侧重于<strong>可读性</strong>，旨在为人们返回一个简洁的文本表示，以便放心地向用户展示。因此在date对象上调用str()时，得到的是一些看起来像ISO日期格式的东西：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">str</span>(today)<br><span class="hljs-string">&#x27;2017-02-02&#x27;</span><br></code></pre></td></tr></table></figure><p>__repr__侧重的则是得到<strong>无歧义</strong>的结果，生成的字符串更多的是帮助开发人员调试程序。为此需要尽可能明确地说明这个对象是什么，因此在对象上调用repr()会得到相对更复杂的结果，其中甚至包括完整的模块和类名称：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">repr</span>()<br><span class="hljs-string">&#x27;datetime.date(2017, 2, 2)&#x27;</span><br></code></pre></td></tr></table></figure><p>我的经验法则是只要让__repr__生成的字符串对开发人员清晰且有帮助就可以了，并不需要能从中恢复对象的完整状态。</p></blockquote><div class="note note-warning">            <p>如果没有设置__str__方法的话，那么在需要调用该方法时会转为调用__repr__方法。</p>          </div><h2 id="abc——抽象基类">abc——抽象基类</h2><p>使用抽象基类可以避免我们在之后编写代码的时候不小心实例化了基类，并且可以确保派生类实现了我们想在其中实现的基类方法。<br>先来看看普通的基类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pet</span>:<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">infor</span>(<span class="hljs-params">self</span>):<br><span class="hljs-keyword">raise</span> NotImplementedError()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">behavior</span>(<span class="hljs-params">self</span>):<br><span class="hljs-keyword">raise</span> NotImplementedError()<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-title class_ inherited__">Pet</span>):<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">infor</span>(<span class="hljs-params">self, name, specie</span>):<br><span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;A <span class="hljs-subst">&#123;specie&#125;</span> called <span class="hljs-subst">&#123;name&#125;</span>.&quot;</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>b = Pet()<br><span class="hljs-meta">&gt;&gt;&gt; </span>b.infor()<br>NotImplementedError<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>my_cat = Cat()<br><span class="hljs-meta">&gt;&gt;&gt; </span>my_cat.infor(<span class="hljs-string">&#x27;white&#x27;</span>, <span class="hljs-string">&#x27;cat&#x27;</span>)<br>A cat called white.<br><span class="hljs-meta">&gt;&gt;&gt; </span>my_cat.behavior()<br>NotImplementedError<br></code></pre></td></tr></table></figure><p>在上面的代码里，不仅基类被实例化了，而且只有在调用未实现的方法时才能发现编写了一个实现不完整的子类。<br>为了避免出现这种状况，就可以用到我们的abc模块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> abc <span class="hljs-keyword">import</span> ABCMeta, abstractmethod<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pet</span>(metaclass=ABCMeta):<br><span class="hljs-meta">@abstractmethod</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">infor</span>(<span class="hljs-params">self</span>):<br><span class="hljs-keyword">pass</span><br><br><span class="hljs-meta">@abstractmethod</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">behavior</span>(<span class="hljs-params">self</span>):<br><span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-title class_ inherited__">Pet</span>):<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">infor</span>(<span class="hljs-params">self, name, specie</span>):<br><span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;A <span class="hljs-subst">&#123;specie&#125;</span> called <span class="hljs-subst">&#123;name&#125;</span>.&quot;</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>b = Pet()<br>TypeError: Can<span class="hljs-string">&#x27;t instantiate abstract class Pet with abstract methods behavior, infor</span><br><span class="hljs-string"></span><br><span class="hljs-string">&gt;&gt;&gt; my_cat = Cat()</span><br><span class="hljs-string">TypeError: Can&#x27;</span>t instantiate abstract <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">with</span> abstract method behavior<br></code></pre></td></tr></table></figure><p>如果我们尝试实例化基类，或者实例化一个不完整的子类，那么就会引发TypeError，并且会指出子类中缺少了哪些方法（未实现哪些抽象方法）。</p><div class="note note-warning">            <p>在用多个装饰器修饰同一个方法时，<code>abstractmethod()</code>应当被应用为最内层的装饰器。</p>          </div><div class="note note-warning">            <p>不同于Java 抽象方法，这些抽象方法可能具有一个实现。这个实现可在重载它的类上通过<code>super()</code>机制来调用。这在使用协作多重继承的框架中可以被用作超调用的一个端点。</p>          </div><p>如果想进一步了解abc模块，可以阅读官方文档：<a href="https://docs.python.org/zh-cn/3.9/library/abc.html?highlight=abc#module-abc">点这里跳转</a></p><hr><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>《Python Tricks 深入理解python特性》 [德]达恩·巴德尔 人民邮电出版社<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Essay</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python随笔-2</title>
    <link href="/2022/05/13/python-essay-2/"/>
    <url>/2022/05/13/python-essay-2/</url>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>在学习装饰器的时候，其中有提到过*args和**kwargs可以让装饰器变得更加强大、有用。<br>文章也简单地说明了下他们的作用，不过想了想这部分<s>貌似也能水一篇文章</s>还是挺重要的，遂写了一篇随笔记一下。<br>当然相关的函数参数解包的内容也一起写在随笔里了。</p><h1>正文</h1><h2 id="它们有什么用">它们有什么用</h2><p>它们能让函数接受<strong>可选参数</strong>。当然，这里的可选参数可能并不像你想的那样，我是说，不是这样的可选参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a=<span class="hljs-number">0</span>, b=<span class="hljs-number">0</span></span>)<br><span class="hljs-keyword">return</span> a + b<br></code></pre></td></tr></table></figure><p>而是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">*args, **kwargs</span>):<br><span class="hljs-built_in">print</span>(args)<br><span class="hljs-built_in">print</span>(kwargs)<br></code></pre></td></tr></table></figure><p>上述函数可以传递任意多的参数，也能不传递参数。在这里arg会收集位置参数组成元组，kwargs会收集额外的关键字参数组成字典。如果不传递参数，那么args和kwargs都为空。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>test(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,k=<span class="hljs-number">1</span>,j=<span class="hljs-number">2</span>,l=<span class="hljs-number">3</span>)<br>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br>&#123;<span class="hljs-string">&#x27;k&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;j&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;l&#x27;</span>: <span class="hljs-number">3</span>&#125;<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>test()<br>()<br>&#123;&#125;<br></code></pre></td></tr></table></figure><div class="note note-info">            <p>实际起作用的是语法分别是星号（*）和双星号（**），args和kwargs只是命名约定。</p>          </div><h2 id="函数参数解包">函数参数解包</h2><p>解包操作符*和**可以用来从序列和字典中“解包”函数参数。<br>比如我们现在有这么一个函数，接受三个参数并返回他们的和。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b, c</span>):<br><span class="hljs-keyword">return</span> a + b + c<br></code></pre></td></tr></table></figure><p>如果我们需要传递的参数在一个列表中，我们得这么做才能传递过去：<code>add(a_list[0], a_list[1], a_list[2])</code><br>但是这看上去非常笨不是吗？所幸我们有解包操作符*，现在，它可以这么写了：<code>add(*a_list)</code>在函数调用时，在可迭代对象前面放一个*能<strong>解包</strong>这个参数，将其中的元素作为单独的位置参数传递给被调用的函数。<br>另一个解包操作符**则是用于从字典中解包关键字参数，比如有这么一个字典：<code>a_dict = &#123;'a' = 1, 'b' = 2, 'c' = 3&#125;</code>，那么要将它传入<code>add()</code>中，就可以这么写：<code>add(**a_dict)</code>，则其中的值会按插入顺序传递给对应位置的参数。<br>需要说明的是，解包的时候会匹配字典键和函数参数，在上边，add中的a参数会接受字典中与’a’键相关的值。<br>而如果使用*对字典进行解包的话，则是将所有的<strong>键</strong>按插入顺序传递给函数。</p><h2 id="传递可选参数">传递可选参数</h2><p>了解了函数参数解包后，我们就可以用它来从一个函数中将可选参数传递给另外一个函数了，并且，参数在传递之前还可以进行修改。<br>比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test1</span>(<span class="hljs-params">*args, **kwargs</span>):<br>new_args = args + (<span class="hljs-number">5</span>, )<br>kwargs[<span class="hljs-string">&#x27;k&#x27;</span>] = <span class="hljs-number">5</span><br>test(*new_args, **kwargs)<br></code></pre></td></tr></table></figure><blockquote><p>这种技术适用于创建子类和编写包装函数（如装饰器）。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="《Python Tricks 深入理解python特性》 [德]达恩·巴德尔 人民邮电出版社">[1]</span></a></sup><br>例如在扩展父类的行为时，子类中的构造函数不用再带有完整的参数列表，因而适用于处理那些不受我们控制的API。<br>一般情况下，自己定义的类层次中并不会用到这种技术。这通常用于修改或覆盖某些外部类中的行为，而自己又无法控制这些外部类。</p></blockquote><hr><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>《Python Tricks 深入理解python特性》 [德]达恩·巴德尔 人民邮电出版社<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Essay</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统原理——虚拟存储管理实验</title>
    <link href="/2022/04/29/page-store/"/>
    <url>/2022/04/29/page-store/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>本文章用到的语言：Python</p>          </div><h1>前言</h1><p>前排提个醒，这个程序我觉得自己写得挺复杂的（因为我懒癌犯了，没有想着优化，也没有想着跟题目走），so大家看看就好。</p><h1>原理</h1><p>老样子照搬：</p><blockquote><p>突然发现这次没得搬的我be like： :(</p></blockquote><h1>实现</h1><h2 id="一些一些一些全局变量">一些一些一些全局变量</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">input_queue = [<span class="hljs-number">7</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, ]  <span class="hljs-comment"># 输入队列</span><br>a_queue = []  <span class="hljs-comment"># 保存用于打印的结果</span><br>b_queue = []  <span class="hljs-comment"># 同上</span><br>c_queue = []  <span class="hljs-comment"># 同上</span><br>interrupt_queue = []  <span class="hljs-comment"># 中断队列，保存发生中断时候的位置</span><br>page_queue = []  <span class="hljs-comment"># 保存页表类对象的队列</span><br>ram_queue = []  <span class="hljs-comment"># 虚拟内存队列</span><br></code></pre></td></tr></table></figure><p>（小声：其实我会很大程度写出这样的程序是题目要求的输出的问题，真的</p><h2 id="一直到最后都没什么用的页表类">一直到最后都没什么用的页表类</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PageList</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;页表类&quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, status, quote</span>):<br>        self.status = status  <span class="hljs-comment"># 状态</span><br>        self.quote = quote  <span class="hljs-comment"># 引用位</span><br></code></pre></td></tr></table></figure><p>真的没用。真的没用。真的没用。直接往下看吧。我用数组下标完成工作的。</p><h2 id="获取输入、打印结果、重置各队列">获取输入、打印结果、重置各队列</h2><p>获取输入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">input_data</span>():<br>    <span class="hljs-string">&quot;&quot;&quot;获取用户输入来选择算法&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        algorithm = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请选择一个算法：A、最佳置换；B、先进先出置换；C、最近最少用置换；D、退出&quot;</span>)<br>        <span class="hljs-keyword">if</span> algorithm == <span class="hljs-string">&#x27;A&#x27;</span>:<br>            opt()<br>        <span class="hljs-keyword">elif</span> algorithm == <span class="hljs-string">&#x27;B&#x27;</span>:<br>            fifo()<br>        <span class="hljs-keyword">elif</span> algorithm == <span class="hljs-string">&#x27;C&#x27;</span>:<br>            lru()<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;程序退出！&quot;</span>)<br>            <span class="hljs-keyword">break</span><br>        reset_page()<br></code></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_result</span>():<br>    <span class="hljs-string">&quot;&quot;&quot;打印各个队列&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">global</span> input_queue, a_queue, b_queue, c_queue, interrupt_queue<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> input_queue:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;i&#125;</span>&quot;</span>.center(<span class="hljs-number">3</span>), end=<span class="hljs-string">&#x27;&#x27;</span>)<br>    <span class="hljs-built_in">print</span>()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&quot;</span>.center(<span class="hljs-number">60</span>, <span class="hljs-string">&#x27;-&#x27;</span>))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> a_queue:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;i&#125;</span>&quot;</span>.center(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;|&#x27;</span>), end=<span class="hljs-string">&#x27;&#x27;</span>)<br>    <span class="hljs-built_in">print</span>()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&quot;</span>.center(<span class="hljs-number">60</span>, <span class="hljs-string">&#x27;-&#x27;</span>))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> b_queue:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;i&#125;</span>&quot;</span>.center(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;|&#x27;</span>), end=<span class="hljs-string">&#x27;&#x27;</span>)<br>    <span class="hljs-built_in">print</span>()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&quot;</span>.center(<span class="hljs-number">60</span>, <span class="hljs-string">&#x27;-&#x27;</span>))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> c_queue:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;i&#125;</span>&quot;</span>.center(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;|&#x27;</span>), end=<span class="hljs-string">&#x27;&#x27;</span>)<br>    <span class="hljs-built_in">print</span>()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&quot;</span>.center(<span class="hljs-number">60</span>, <span class="hljs-string">&#x27;-&#x27;</span>))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> interrupt_queue:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;i&#125;</span>&quot;</span>.center(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;|&#x27;</span>), end=<span class="hljs-string">&#x27;&#x27;</span>)<br>    <span class="hljs-built_in">print</span>()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;该算法一共发生了<span class="hljs-subst">&#123;interrupt_queue.count(<span class="hljs-string">&#x27;+&#x27;</span>)&#125;</span>页面置换，缺页中断率为<span class="hljs-subst">&#123;interrupt_queue.count(<span class="hljs-string">&#x27;+&#x27;</span>)*<span class="hljs-number">100</span>/<span class="hljs-built_in">len</span>(input_queue)&#125;</span>%&quot;</span>)<br>    <span class="hljs-built_in">print</span>()<br>    <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p>重置各队列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">reset_page</span>():<br>    <span class="hljs-string">&quot;&quot;&quot;重置页表状态&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">global</span> a_queue, b_queue, c_queue, interrupt_queue, ram_queue<br>    <span class="hljs-keyword">for</span> page <span class="hljs-keyword">in</span> page_queue:<br>        page.status = <span class="hljs-number">0</span><br>        page.quote = <span class="hljs-number">0</span><br>    a_queue = []<br>    b_queue = []<br>    c_queue = []<br>    interrupt_queue = []<br>    ram_queue = []<br></code></pre></td></tr></table></figure><h2 id="最优置换算法">最优置换算法</h2><p>最优是我想了最久的，毕竟其他两个确实不难，这里仔细划分每种情况就清晰多了。<br>首先是虚拟内存当前是否满的情况，这里要注意在虚拟内存未满的时候产生缺页中断是插入队尾而不是队头（就这个OPT是这样），其实虚拟内存未满的情况下还需要考虑是否产生缺页中断，我这里写的是没有考虑的。<br>然后是虚拟内存满了后，产生缺页中断和不产生缺页中断的情况。不产生缺页中断就不需要对虚拟内存进行操作了。<br>产生缺页中断后，我首先找剩下不需要再调用的页面，这部分页面的优先级是最大的，当然这是在有python列表方法的情况下这么写简单，直接找最迟访问也行。如果都还要访问那就找最迟访问的页面。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">opt</span>():<br>    <span class="hljs-string">&quot;&quot;&quot;to do&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">global</span> input_queue, a_queue, b_queue, c_queue, interrupt_queue, page_queue, ram_queue<br>    <span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(input_queue)):  <span class="hljs-comment"># 遍历整个序列</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(ram_queue) == <span class="hljs-number">3</span>:<br>            <span class="hljs-keyword">if</span> input_queue[index] <span class="hljs-keyword">in</span> ram_queue:  <span class="hljs-comment"># 当前虚拟内存中有该页，不产生缺页中断，也不需要改变虚拟内存中的页表</span><br>                a_queue.append(ram_queue[<span class="hljs-number">0</span>])  <span class="hljs-comment"># 保存用于打印的结果</span><br>                b_queue.append(ram_queue[<span class="hljs-number">1</span>])<br>                c_queue.append(ram_queue[<span class="hljs-number">2</span>])<br>                interrupt_queue.append(<span class="hljs-string">&#x27; &#x27;</span>)  <span class="hljs-comment"># 未产生缺页中断，所以塞个&#x27; &#x27;进去</span><br>                <span class="hljs-keyword">continue</span>  <span class="hljs-comment"># 继续下次循环</span><br>            <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 虚拟内存满的情况下，调用对应页面置换算法置换页面</span><br>                find = <span class="hljs-number">0</span><br>                <span class="hljs-keyword">for</span> exchange_index <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(ram_queue)):  <span class="hljs-comment"># 找出需要置换的页面在虚拟内存队列中的下标</span><br>                    <span class="hljs-keyword">if</span> ram_queue[exchange_index] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> input_queue[index + <span class="hljs-number">1</span>:]:  <span class="hljs-comment"># 如果在剩下的序列中都找不到该页，可以直接换出去</span><br>                        find = <span class="hljs-number">1</span>  <span class="hljs-comment"># 标记是否找到了置换页面</span><br>                        exchange_page = ram_queue[exchange_index]<br>                        <span class="hljs-keyword">break</span><br>                <span class="hljs-keyword">if</span> find == <span class="hljs-number">0</span>:  <span class="hljs-comment"># 三个页在剩下的序列中还有访问</span><br>                    tmp_queue = input_queue[index + <span class="hljs-number">1</span>:]<br>                    max_index = <span class="hljs-number">0</span><br>                    exchange_page = <span class="hljs-number">0</span><br>                    <span class="hljs-keyword">for</span> tmp_index <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(ram_queue)):  <span class="hljs-comment"># 找出最迟访问的页</span><br>                        new_index = tmp_queue.index(ram_queue[tmp_index])<br>                        <span class="hljs-keyword">if</span> max_index &lt; new_index:<br>                            max_index = new_index<br>                            exchange_page = ram_queue[tmp_index]<br>                <span class="hljs-keyword">for</span> tmp_index <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(ram_queue)):<br>                    <span class="hljs-keyword">if</span> exchange_page == ram_queue[tmp_index]:  <span class="hljs-comment"># 进行页面置换</span><br>                        ram_queue[tmp_index] = input_queue[index]<br>                        <span class="hljs-keyword">break</span><br>                a_queue.append(ram_queue[<span class="hljs-number">0</span>])  <span class="hljs-comment"># 保存用于打印的结果</span><br>                b_queue.append(ram_queue[<span class="hljs-number">1</span>])<br>                c_queue.append(ram_queue[<span class="hljs-number">2</span>])<br>                interrupt_queue.append(<span class="hljs-string">&#x27;+&#x27;</span>)  <span class="hljs-comment"># 产生缺页中断，所以塞个&#x27;+&#x27;进去</span><br>                <span class="hljs-keyword">continue</span>  <span class="hljs-comment"># 继续下次循环</span><br>        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">len</span>(ram_queue) &lt;= <span class="hljs-number">2</span>:  <span class="hljs-comment"># 虚拟内存队列长度为0、1、2的情况</span><br>            ram_queue.append(input_queue[index])<br>            a_queue.append(ram_queue[<span class="hljs-number">0</span>])  <span class="hljs-comment"># 保存用于打印的结果</span><br>            b_queue.append(ram_queue[<span class="hljs-number">1</span>] <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(ram_queue) &gt;= <span class="hljs-number">2</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27; &#x27;</span>)<br>            c_queue.append(ram_queue[<span class="hljs-number">2</span>] <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(ram_queue) == <span class="hljs-number">3</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27; &#x27;</span>)<br>            interrupt_queue.append(<span class="hljs-string">&#x27;+&#x27;</span>)  <span class="hljs-comment"># 产生缺页中断，所以塞个&#x27;+&#x27;进去</span><br>            <span class="hljs-keyword">continue</span>  <span class="hljs-comment"># 继续下次循环</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;OPT页面置换算法示意图如下：&quot;</span>)<br>    print_result()<br>    <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><h2 id="先进先出置换算法">先进先出置换算法</h2><p>其实就是很简单的队列操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fifo</span>():<br>    <span class="hljs-keyword">global</span> input_queue, a_queue, b_queue, c_queue, interrupt_queue, page_queue, ram_queue<br>    <span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(input_queue)):  <span class="hljs-comment"># 遍历整个序列</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(ram_queue) == <span class="hljs-number">3</span>:<br>            <span class="hljs-keyword">if</span> input_queue[index] <span class="hljs-keyword">in</span> ram_queue:  <span class="hljs-comment"># 当前虚拟内存中有该页，不产生缺页中断，也不需要改变虚拟内存中的页表</span><br>                a_queue.append(ram_queue[<span class="hljs-number">0</span>])  <span class="hljs-comment"># 保存用于打印的结果</span><br>                b_queue.append(ram_queue[<span class="hljs-number">1</span>])<br>                c_queue.append(ram_queue[<span class="hljs-number">2</span>])<br>                interrupt_queue.append(<span class="hljs-string">&#x27; &#x27;</span>)  <span class="hljs-comment"># 未产生缺页中断，所以塞个&#x27; &#x27;进去</span><br>                <span class="hljs-keyword">continue</span>  <span class="hljs-comment"># 继续下次循环</span><br>            <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 虚拟内存满的情况下，调用对应页面置换算法置换页面</span><br>                ram_queue.insert(<span class="hljs-number">0</span>, input_queue[index])  <span class="hljs-comment"># 队列头进</span><br>                ram_queue.pop()  <span class="hljs-comment"># 队列尾出</span><br>                a_queue.append(ram_queue[<span class="hljs-number">0</span>])  <span class="hljs-comment"># 保存用于打印的结果</span><br>                b_queue.append(ram_queue[<span class="hljs-number">1</span>])<br>                c_queue.append(ram_queue[<span class="hljs-number">2</span>])<br>                interrupt_queue.append(<span class="hljs-string">&#x27;+&#x27;</span>)  <span class="hljs-comment"># 产生缺页中断，所以塞个&#x27;+&#x27;进去</span><br>                <span class="hljs-keyword">continue</span>  <span class="hljs-comment"># 继续下次循环</span><br>        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">len</span>(ram_queue) &lt;= <span class="hljs-number">2</span>:  <span class="hljs-comment"># 虚拟内存队列长度为0、1、2的情况</span><br>            ram_queue.insert(<span class="hljs-number">0</span>, input_queue[index])<br>            a_queue.append(ram_queue[<span class="hljs-number">0</span>])  <span class="hljs-comment"># 保存用于打印的结果</span><br>            b_queue.append(ram_queue[<span class="hljs-number">1</span>] <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(ram_queue) &gt;= <span class="hljs-number">2</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27; &#x27;</span>)<br>            c_queue.append(ram_queue[<span class="hljs-number">2</span>] <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(ram_queue) == <span class="hljs-number">3</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27; &#x27;</span>)<br>            interrupt_queue.append(<span class="hljs-string">&#x27;+&#x27;</span>)  <span class="hljs-comment"># 产生缺页中断，所以塞个&#x27;+&#x27;进去</span><br>            <span class="hljs-keyword">continue</span>  <span class="hljs-comment"># 继续下次循环</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;FIFO页面置换算法示意图如下：&quot;</span>)<br>    print_result()<br>    <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><h2 id="最近最少用置换算法">最近最少用置换算法</h2><p>其实和队列也没多大差，要是当前队列有对应页，就把该页和队头那一页调换位置就好了，产生缺页中断时候的操作和FIFO是一样的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">lru</span>():<br>    <span class="hljs-string">&quot;&quot;&quot;to do&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">global</span> input_queue, a_queue, b_queue, c_queue, interrupt_queue, page_queue, ram_queue<br>    <span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(input_queue)):  <span class="hljs-comment"># 遍历整个序列</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(ram_queue) == <span class="hljs-number">3</span>:<br>            <span class="hljs-keyword">if</span> input_queue[index] <span class="hljs-keyword">in</span> ram_queue:  <span class="hljs-comment"># 当前虚拟内存中有该页，不产生缺页中断，也不需要改变虚拟内存中的页表</span><br>                ram_queue.remove(input_queue[index])<br>                ram_queue.insert(<span class="hljs-number">0</span>, input_queue[index])<br>                a_queue.append(ram_queue[<span class="hljs-number">0</span>])  <span class="hljs-comment"># 保存用于打印的结果</span><br>                b_queue.append(ram_queue[<span class="hljs-number">1</span>])<br>                c_queue.append(ram_queue[<span class="hljs-number">2</span>])<br>                interrupt_queue.append(<span class="hljs-string">&#x27; &#x27;</span>)  <span class="hljs-comment"># 未产生缺页中断，所以塞个&#x27; &#x27;进去</span><br>                <span class="hljs-keyword">continue</span>  <span class="hljs-comment"># 继续下次循环</span><br>            <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 虚拟内存满的情况下，调用对应页面置换算法置换页面</span><br>                ram_queue.pop()<br>                ram_queue.insert(<span class="hljs-number">0</span>, input_queue[index])<br>                a_queue.append(ram_queue[<span class="hljs-number">0</span>])  <span class="hljs-comment"># 保存用于打印的结果</span><br>                b_queue.append(ram_queue[<span class="hljs-number">1</span>])<br>                c_queue.append(ram_queue[<span class="hljs-number">2</span>])<br>                interrupt_queue.append(<span class="hljs-string">&#x27;+&#x27;</span>)  <span class="hljs-comment"># 产生缺页中断，所以塞个&#x27;+&#x27;进去</span><br>                <span class="hljs-keyword">continue</span>  <span class="hljs-comment"># 继续下次循环</span><br>        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">len</span>(ram_queue) &lt;= <span class="hljs-number">2</span>:  <span class="hljs-comment"># 虚拟内存队列长度为0、1、2的情况</span><br>            ram_queue.append(input_queue[index])<br>            a_queue.append(ram_queue[<span class="hljs-number">0</span>])  <span class="hljs-comment"># 保存用于打印的结果</span><br>            b_queue.append(ram_queue[<span class="hljs-number">1</span>] <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(ram_queue) &gt;= <span class="hljs-number">2</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27; &#x27;</span>)<br>            c_queue.append(ram_queue[<span class="hljs-number">2</span>] <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(ram_queue) == <span class="hljs-number">3</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27; &#x27;</span>)<br>            interrupt_queue.append(<span class="hljs-string">&#x27;+&#x27;</span>)  <span class="hljs-comment"># 产生缺页中断，所以塞个&#x27;+&#x27;进去</span><br>            <span class="hljs-keyword">continue</span>  <span class="hljs-comment"># 继续下次循环</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;LRU页面置换算法示意图如下：&quot;</span>)<br>    print_result()<br>    <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><h2 id="测试代码">测试代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 初始化页表，一共有八页</span><br>    page_queue.append(PageList(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>))<br>    page_queue.append(PageList(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>))<br>    page_queue.append(PageList(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>))<br>    page_queue.append(PageList(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>))<br>    page_queue.append(PageList(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>))<br>    page_queue.append(PageList(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>))<br>    page_queue.append(PageList(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>))<br>    page_queue.append(PageList(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>))<br><br>    input_data()<br></code></pre></td></tr></table></figure><h1>运行结果</h1><p><s>没想到吧，我这次放运行结果了！</s></p><p><img src="/img/page_store/result_opt.png" alt="最优置换"></p><p><img src="/img/page_store/result_fifo.png" alt="先进先出置换"></p><p><img src="/img/page_store/result_lru.png" alt="最近最少用置换"></p><h1>一些一些一些其他垃圾话</h1><p>其实本来是想优化的，但是由于我太懒了（五一假那能叫懒吗）所以计划取消了！</p><hr>]]></content>
    
    
    <categories>
      
      <category>Learning Log</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>操作系统</tag>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python学习笔记——测试代码</title>
    <link href="/2022/04/24/python-learning-3/"/>
    <url>/2022/04/24/python-learning-3/</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>本文章尚未更新完毕</p>          </div><h1>前言</h1><p>要验证我们所编写的代码是否能像我们所想的那样工作，我们就需要对我们的代码进行测试。<br>但是一般情况下，验证都涉及到数据的输入，这可就麻烦了，为了测试我们的代码，每运行一次都得输入一次数据，这样做即低效又烦琐。<br>而且以后每修改一次函数/类，我们也要做一次这样的工作，想想就头晕，不是吗？<br>好在Python提供了一种自动测试函数输出的高效方式：通过unittest模板来测试代码。</p><h1>什么事Unittest？</h1><p>简单地说，其实就是一个提供一系列代码测试工具的一个模块。在<a href="https://docs.python.org/3.9/library/unittest.html?highlight=unittest#module-unittest">官方文档</a>中描述如下：</p><blockquote><p>The unittest unit testing framework was originally inspired by JUnit and has a similar flavor as major unit testing frameworks in other languages.<br>It supports test automation, sharing of setup and shutdown code for tests, aggregation of tests into collections, and independence of the tests from the reporting framework.</p><p>To achieve this, unittest supports some important concepts in an object-oriented way:</p><p>test fixture</p><blockquote><p>A test fixture represents the preparation needed to perform one or more tests, and any associated cleanup actions.<br>This may involve, for example, creating temporary or proxy databases, directories, or starting a server process.</p></blockquote><p>test case</p><blockquote><p>A test case is the individual unit of testing. It checks for a specific response to a particular set of inputs.<br>unittest provides a base class, TestCase, which may be used to create new test cases.</p></blockquote><p>test suite</p><blockquote><p>A test suite is a collection of test cases, test suites, or both. It is used to aggregate tests that should be executed together.</p></blockquote><p>test runner</p><blockquote><p>A test runner is a component which orchestrates the execution of tests and provides the outcome to the user.<br>The runner may use a graphical interface, a textual interface, or return a special value to indicate the results of executing the tests.</p></blockquote></blockquote><p>官方文档讲了四种概念，但在这边目前仅涉及test case，即测试用例，这一概念的使用。<br>正如官方文档所说，test case检查输入特定的数据时的响应。正因如此我们可以用它来简化我们的需要输入数据的测试。</p><h1>Unittest中的断言方法</h1><p>因为我们需要检查输出的结果，所以就要用到<code>unittest</code>中的断言方法，在这里我列举了一些方法。</p><h1>对函数进行测试</h1><p>要对函数进行测试，首先我们得有用于测试的函数，我们既可以自行定义要测试的函数，也可以利用Python自带的函数，这里我先自行定义一个函数，它用于将两数相加并返回该值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>):<br><span class="hljs-keyword">return</span> a + b<br></code></pre></td></tr></table></figure><h2 id="通过的测试">通过的测试</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> unittest<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddTestCase</span>(unittest.TestCase):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_two_num_add</span>(<span class="hljs-params">self</span>):<br>        result = add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>        self.assertEqual(result, <span class="hljs-number">3</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    unittest.main()<br></code></pre></td></tr></table></figure><p>首先导入<code>unittest</code>模块。<br>然后创建了一个名为 <code>AddTestCase</code> 的类，名字是可以随便取的，但是最好简单易懂（其实写注释就好啦）。要进行测试，这个类必须继承 <code>unittest.TsetCase</code> 类。<br>类里面目前只写了一个方法，用于测试两个数相加的情况。在运行时，所有以test_打头的方法都将自动运行。<br>在这个方法中，调用了之前编写的<code>add</code>函数并将值返回到<code>result</code>变量中，然后用<code>unittest</code>中的断言方法来判断得到的结果是否与我们预期结果一致。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">.<br>----------------------------------------------------------------------<br>Ran <span class="hljs-number">1</span> test <span class="hljs-keyword">in</span> <span class="hljs-number">0.000</span>s<br><br>OK<br></code></pre></td></tr></table></figure><p>直接运行这个文件，我们会得到如上输出。句点的数量代表了通过的测试数，在上面我们有一个句点，说明通过了一个测试。接下来的一行指出“在xxx秒内运行了xxx个测试”。最后的OK表示该测试用例中的所有单元测试都通过了。</p><h2 id="未通过的测试">未通过的测试</h2><p>如果测试未通过，控制台/终端会输出什么信息呢？试一下就知道了。这里我故意编写了一个无法通过的测试，将<strong>3</strong>改为了<strong>4</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddTestCase</span>(unittest.TestCase):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_two_num_add</span>(<span class="hljs-params">self</span>):<br>        result = add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>        self.assertEqual(result, <span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><p>报错信息如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">F<br>======================================================================<br>FAIL: test_two_num_add (__main__.AddTestCase)<br>----------------------------------------------------------------------<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;G:\example1.py&quot;</span>, line <span class="hljs-number">11</span>, <span class="hljs-keyword">in</span> test_two_num_add<br>    self.assertEqual(result, <span class="hljs-number">4</span>)<br>AssertionError: <span class="hljs-number">3</span> != <span class="hljs-number">4</span><br><br>----------------------------------------------------------------------<br>Ran <span class="hljs-number">1</span> test <span class="hljs-keyword">in</span> <span class="hljs-number">0.001</span>s<br><br>FAILED (failures=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>这里第一行显示测试用例中有一个单元测试失败，接下来告诉你具体是哪个单元测试，紧接着就是Traceback——详细的报错信息了。在最后，我们还能看到运行该测试用例时失败了多少个单元测试。<br>在这里报的错是<strong>F</strong>，还有一种报错是<strong>E</strong>，这里一并演示一下：首先改下我们的函数<code>add</code>的代码，让它从现在开始接受三个参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b, c</span>):<br>    <span class="hljs-keyword">return</span> a + b + c<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddTestCase</span>(unittest.TestCase):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_two_num_add</span>(<span class="hljs-params">self</span>):<br>        result = add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>        self.assertEqual(result, <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>然后运行，得到如下信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">E<br>======================================================================<br>ERROR: test_two_num_add (__main__.AddTestCase)<br>----------------------------------------------------------------------<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;G:\example1.py&quot;</span>, line <span class="hljs-number">10</span>, <span class="hljs-keyword">in</span> test_two_num_add<br>    result = add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>TypeError: add() missing <span class="hljs-number">1</span> required positional argument: <span class="hljs-string">&#x27;c&#x27;</span><br><br>----------------------------------------------------------------------<br>Ran <span class="hljs-number">1</span> test <span class="hljs-keyword">in</span> <span class="hljs-number">0.001</span>s<br><br>FAILED (errors=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>可以看到，在这里出的错就是E，即error了。<br>通过对比我们就能知道，E代表程序代码引发的测试错误，F代表程序输出的结果没有得到“预期的结果”（毕竟所谓预期的结果也是我们自己所定义的）。</p><h1>对类进行测试</h1><p><em><strong>to do…</strong></em></p><hr>]]></content>
    
    
    <categories>
      
      <category>Learning Log</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统原理——可变分区存储管理</title>
    <link href="/2022/04/20/variable-partition/"/>
    <url>/2022/04/20/variable-partition/</url>
    
    <content type="html"><![CDATA[<h1>原理</h1><p>进行一个实验报告的抄~</p><blockquote><p>可变分区方式是按作业需要的主存空间大小来分区。<br>当装入一个作业时，首先要查看是否有足够的空闲空间来分配，若有则按指定的分配方式进行分配；否则作业不能装入。</p><blockquote><p>可变分区的三种分配算法就是为作业分配主存空间的方法。</p><ul><li>最先适应算法：在空闲区间中查询满足作业需要的空间，并将作业装入第一个满足条件的空间中去。</li><li>最佳适应算法：在空闲区间中查询满足作业需要的空间，并将作业装入满足条件的空闲空间中最小的一个空间中去。</li><li>最坏适应算法：在空闲区间中查询满足作业需要的空间，并将作业装入满足条件的空闲空间中最大的一个空间中去。</li></ul></blockquote><blockquote><p>从三种算法的说明可以看出，分配空间的过程主要可以分两步：</p><ol><li>查询所有满足作业需求的空间块。</li><li>按照指定的算法将作业装入空间块中。</li></ol></blockquote><blockquote><p>可变分区的回收算法：</p><ul><li>回收区有下邻空闲区</li><li>回收区有上邻空闲区</li><li>归还区既有上邻空闲区又有下邻空闲区</li><li>归还区既无上邻空闲区又有下邻空闲区</li></ul></blockquote></blockquote><h1>实现</h1><h2 id="空闲表和已分配表">空闲表和已分配表</h2><p>这里其实根据我的作业要求只能用一个内存分区表（就是一个列表）来实现的，但是明显是用两个表来表示会更方便，这样就不需要标志属性了！<s>（偷懒）</s><br>所以我定义了两个全局变量，一个存空闲分区，一个存已分配分区。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">free_list = []  <span class="hljs-comment"># 空闲列表</span><br>allocated_list = []  <span class="hljs-comment"># 已分配列表</span><br></code></pre></td></tr></table></figure><h2 id="空闲空间和已分配空间">空闲空间和已分配空间</h2><p>这边用了两个类来表示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Free</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;空闲表类&quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, start, length</span>):<br>        self.start = start  <span class="hljs-comment"># 起址</span><br>        self.length = length    <span class="hljs-comment"># 长度</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Allocated</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;已分配表类&quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, start, length</span>):<br>        self.name = name    <span class="hljs-comment"># 作业名</span><br>        self.start = start  <span class="hljs-comment"># 起址</span><br>        self.length = length    <span class="hljs-comment"># 长度</span><br></code></pre></td></tr></table></figure><h2 id="读取用户输入">读取用户输入</h2><p>我先不急着实现功能，而是先做了“具有交互功能”（确信）的函数，能够让用户操作数据和读取数据！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">input_data</span>():<br>    <span class="hljs-string">&quot;&quot;&quot;读取用户输入以及操作&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">global</span> free_list, allocated_list<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        op = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请选择要进行的操作：A 分配主存； B 回收主存； C 显示主存； Q 退出；&quot;</span>)<br>        <span class="hljs-keyword">if</span> op == <span class="hljs-string">&#x27;A&#x27;</span>:<br>            job_name = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入作业名：&quot;</span>)<br>            length = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入作业长度&quot;</span>))<br>            algorithm = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入分配算法：A 最先适应； B 最优适应； C 最坏适应；&quot;</span>)<br>            <span class="hljs-keyword">if</span> algorithm == <span class="hljs-string">&#x27;A&#x27;</span>:<br>                allocate(job_name, length, algorithm)<br>            <span class="hljs-keyword">elif</span> algorithm == <span class="hljs-string">&#x27;B&#x27;</span>:<br>                allocate(job_name, length, algorithm)<br>            <span class="hljs-keyword">elif</span> algorithm == <span class="hljs-string">&#x27;C&#x27;</span>:<br>                allocate(job_name, length, algorithm)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;输入错误，请重新输入。&quot;</span>)<br>        <span class="hljs-keyword">elif</span> op == <span class="hljs-string">&#x27;B&#x27;</span>:<br>            recycle_name = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入要回收的作业名：&quot;</span>)<br>            recycle(recycle_name)<br>        <span class="hljs-keyword">elif</span> op == <span class="hljs-string">&#x27;C&#x27;</span>:<br>            display()<br>        <span class="hljs-keyword">elif</span> op == <span class="hljs-string">&#x27;Q&#x27;</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;程序退出。&quot;</span>)<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;输入错误，请重新输入。&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="显示主存空间">显示主存空间</h2><p>为了检查前面写的代码没什么问题，比如功能选择、空闲和已分配列表，我决定先实现这个函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">display</span>():<br>    <span class="hljs-string">&quot;&quot;&quot;打印两张表&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">global</span> free_list, allocated_list<br>    free_list_sort(<span class="hljs-string">&#x27;A&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;空闲表&quot;</span>.center(<span class="hljs-number">32</span>, <span class="hljs-string">&#x27;-&#x27;</span>))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;起址&quot;</span>.center(<span class="hljs-number">10</span>) + <span class="hljs-string">&quot;|&quot;</span> + <span class="hljs-string">&quot;长度&quot;</span>.center(<span class="hljs-number">10</span>) + <span class="hljs-string">&quot;|&quot;</span> + <span class="hljs-string">&quot;终址&quot;</span>.center(<span class="hljs-number">10</span>))<br>    <span class="hljs-keyword">for</span> free <span class="hljs-keyword">in</span> free_list:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;free.start&#125;</span>&quot;</span>.center(<span class="hljs-number">11</span>) + <span class="hljs-string">&quot;|&quot;</span> + <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;free.length&#125;</span>&quot;</span>.center(<br>            <span class="hljs-number">11</span>) + <span class="hljs-string">&quot;|&quot;</span> + <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;free.start + free.length - <span class="hljs-number">1</span>&#125;</span>&quot;</span>.center(<span class="hljs-number">11</span>))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&quot;</span>.center(<span class="hljs-number">34</span>, <span class="hljs-string">&#x27;-&#x27;</span>))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已分配表&quot;</span>.center(<span class="hljs-number">32</span>, <span class="hljs-string">&#x27;-&#x27;</span>))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;名字&quot;</span>.center(<span class="hljs-number">10</span>) + <span class="hljs-string">&quot;|&quot;</span> + <span class="hljs-string">&quot;起址&quot;</span>.center(<span class="hljs-number">10</span>) + <span class="hljs-string">&quot;|&quot;</span> + <span class="hljs-string">&quot;长度&quot;</span>.center(<span class="hljs-number">10</span>))<br>    <span class="hljs-keyword">for</span> job <span class="hljs-keyword">in</span> allocated_list:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;job.name&#125;</span>&quot;</span>.center(<span class="hljs-number">11</span>) + <span class="hljs-string">&quot;|&quot;</span> + <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;job.start&#125;</span>&quot;</span>.center(<br>            <span class="hljs-number">11</span>) + <span class="hljs-string">&quot;|&quot;</span> + <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;job.length&#125;</span>&quot;</span>.center(<span class="hljs-number">11</span>))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&quot;</span>.center(<span class="hljs-number">34</span>, <span class="hljs-string">&#x27;-&#x27;</span>))<br></code></pre></td></tr></table></figure><p>(请无视这粗暴的代码分行，这是我用IDEA快捷格式化出来的。。。)<br>如果不明白其中的<code>center</code>方法的话，可以看我之后的随笔（写完后会在这里放跳转链接）。<br>在这个函数第二行我调用了一个<code>free_list_sort</code>函数，作用如其名，用来对空闲分区列表中的空闲分区排序。</p><h2 id="对空闲分区列表进行排序">对空闲分区列表进行排序</h2><p>虽然看上去是写了一个函数，但其实用的还是python自带的<code>sorted</code>函数进行的排序<s>因为真的太好用啦</s><br>为什么要特地写这个函数？因为分配主存空间有三种算法，最先、最优和最坏适应，这里我就写了三个排序方式：按照起址、长度升序、长度逆序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">free_list_sort</span>(<span class="hljs-params">method</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;为空闲表选择排序方式&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">global</span> free_list<br>    <span class="hljs-keyword">if</span> method == <span class="hljs-string">&#x27;A&#x27;</span>:<br>        free_list = <span class="hljs-built_in">sorted</span>(free_list, key=<span class="hljs-keyword">lambda</span> free: free.start)  <span class="hljs-comment"># 按照起址排序</span><br>    <span class="hljs-keyword">elif</span> method == <span class="hljs-string">&#x27;B&#x27;</span>:<br>        free_list = <span class="hljs-built_in">sorted</span>(free_list, key=<span class="hljs-keyword">lambda</span> free: free.length)  <span class="hljs-comment"># 按照长度排序</span><br>    <span class="hljs-keyword">elif</span> method == <span class="hljs-string">&#x27;C&#x27;</span>:<br>        free_list = <span class="hljs-built_in">sorted</span>(free_list, key=<span class="hljs-keyword">lambda</span> free: free.length, reverse=<span class="hljs-literal">True</span>)  <span class="hljs-comment"># 按照长度排逆序</span><br></code></pre></td></tr></table></figure><p>这里的用到的<code>sorted</code>函数和<code>sort</code>方法类似，都接受两个作用一样的可选参数key和reverse，这两个参数有什么用可以看这篇文章：<a href="https://map1e-g.github.io/2022/04/17/python-essay-1/">点我跳转</a><br>而lambda表达式就是一个单表达式函数，也可以当成匿名函数。在对可迭代对象进行排序的时候，我们都可以用lambda表达式定义简短的key函数。关于lambda表达式可能之后会写在随笔或者学习笔记里。</p><h2 id="分配主存">分配主存</h2><p>虽然有三种算法，但是由于我的空闲分区和已分配分区是分开的，所以不同的地方只有排序上，剩下的找空闲分区并安排的操作是一样的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">allocate</span>(<span class="hljs-params">name, length, method</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;分配主存空间&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">global</span> free_list, allocated_list<br>    free_list_sort(method)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(free_list)):<br>        <span class="hljs-comment"># 找到可进行分配的空间</span><br>        <span class="hljs-keyword">if</span> free_list[i].length &gt;= length:<br>            allocated_list.append(Allocated(name, free_list[i].start, length))<br>            allocated_list = <span class="hljs-built_in">sorted</span>(allocated_list, key=<span class="hljs-keyword">lambda</span> job: job.start)<br>            <span class="hljs-keyword">if</span> free_list[i].length == length:<br>                <span class="hljs-keyword">del</span> free_list[i]<br>            <span class="hljs-keyword">else</span>:<br>                free_list[i].start = free_list[i].start + length<br>                free_list[i].length = free_list[i].length - length<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;分配成功！&quot;</span>)<br>            <span class="hljs-keyword">return</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;分配失败！&quot;</span>)<br></code></pre></td></tr></table></figure><p>在找空闲分区前，我们先按照给定的算法对空闲分区列表进行排序，然后再去遍历这个列表，尝试找到合适的分区并对作业进行分配。<br>这里有两种情况，一种是作业长度刚好等于找到的空闲分区长度，这时候直接删除掉对应的空闲分区即可；若作业长度小于空闲分区的长度，这个空闲分区就应该重新计算起址和长度。</p><h2 id="回收主存">回收主存</h2><p>这部分其实涉及到两个东西，一个是回收，一个是合并。<br>先来看回收：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">recycle</span>(<span class="hljs-params">name</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;回收空间&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">global</span> free_list, allocated_list<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(allocated_list)):<br>        <span class="hljs-comment"># 检查已分配表中是否有该作业</span><br>        <span class="hljs-keyword">if</span> allocated_list[i].name == name:<br>            free_list.append(Free(allocated_list[i].start, allocated_list[i].length))<br>            free_list_sort(<span class="hljs-string">&#x27;A&#x27;</span>)<br>            <span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(free_list)):<br>                <span class="hljs-comment"># 找出新加入的空闲表的索引并调用merge函数进行合并</span><br>                <span class="hljs-keyword">if</span> free_list[index].start == allocated_list[i].start:<br>                    merge(index)<br>                    <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">del</span> allocated_list[i]<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;回收成功！&quot;</span>)<br>            <span class="hljs-keyword">return</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;回收失败！&quot;</span>)<br></code></pre></td></tr></table></figure><p>可以看出遍历一遍已分配列表就好啦，找到对应名字的作业后，先在空闲分区列表中加入一个新的空闲分区，然后对这个新的空闲分区调用<code>merge</code>函数进行合并，最后使用<code>del</code>函数删除掉这个作业即可~<br>那么我们再来看看合并函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">index</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;合并空间&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">global</span> free_list<br>    <span class="hljs-keyword">if</span> index == <span class="hljs-number">0</span>:<br>        <span class="hljs-comment"># 第一个元素，只需向下合并</span><br>        <span class="hljs-keyword">if</span> free_list[index].start + free_list[index].length == free_list[index + <span class="hljs-number">1</span>].start:<br>            <span class="hljs-comment"># 当前起址加上长度等于下个起址，可以合并</span><br>            free_list[index].length = free_list[index].length + free_list[index + <span class="hljs-number">1</span>].length<br>            <span class="hljs-keyword">del</span> free_list[index + <span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">elif</span> index == <span class="hljs-built_in">len</span>(free_list) - <span class="hljs-number">1</span>:<br>        <span class="hljs-comment"># 最后一个元素，只需向上合并</span><br>        <span class="hljs-keyword">if</span> free_list[index - <span class="hljs-number">1</span>].start + free_list[index - <span class="hljs-number">1</span>].length == free_list[index].start:<br>            <span class="hljs-comment"># 上个起址加上长度等于当前起址，可以合并</span><br>            free_list[index - <span class="hljs-number">1</span>].length = free_list[index - <span class="hljs-number">1</span>].length + free_list[index].length<br>            <span class="hljs-keyword">del</span> free_list[index]<br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment"># 向上向下均要检查</span><br>        <span class="hljs-keyword">if</span> free_list[index].start + free_list[index].length == free_list[index + <span class="hljs-number">1</span>].start:<br>            <span class="hljs-comment"># 当前起址加上长度等于下个起址，可以合并</span><br>            free_list[index].length = free_list[index].length + free_list[index + <span class="hljs-number">1</span>].length<br>            <span class="hljs-keyword">del</span> free_list[index + <span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">if</span> free_list[index - <span class="hljs-number">1</span>].start + free_list[index - <span class="hljs-number">1</span>].length == free_list[index].start:<br>            <span class="hljs-comment"># 上个起址加上长度等于当前起址，可以合并</span><br>            free_list[index - <span class="hljs-number">1</span>].length = free_list[index - <span class="hljs-number">1</span>].length + free_list[index].length<br>            <span class="hljs-keyword">del</span> free_list[index]<br>        <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p>由于我们在回收的时候重新“整理”（排序）了空闲分区列表，列表中的空闲分区现在是连续（有序）的，所以可以直接用下标进行数据处理。<br>不过在上下均要回收的时候，不要搞错了数组下标以及合并先后顺序、合并的应该是哪个空闲分区。</p><h2 id="测试代码">测试代码</h2><p>为了方便提前提供了一点数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 预输入数据</span><br>    free_1 = Free(<span class="hljs-number">10</span>, <span class="hljs-number">16</span>)<br>    free_2 = Free(<span class="hljs-number">36</span>, <span class="hljs-number">14</span>)<br>    free_3 = Free(<span class="hljs-number">55</span>, <span class="hljs-number">10</span>)<br>    free_4 = Free(<span class="hljs-number">70</span>, <span class="hljs-number">30</span>)<br>    free_list.append(free_1)<br>    free_list.append(free_2)<br>    free_list.append(free_3)<br>    free_list.append(free_4)<br>    job_1 = Allocated(<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-number">26</span>, <span class="hljs-number">10</span>)<br>    job_2 = Allocated(<span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-number">50</span>, <span class="hljs-number">5</span>)<br>    job_3 = Allocated(<span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-number">65</span>, <span class="hljs-number">5</span>)<br>    allocated_list.append(job_1)<br>    allocated_list.append(job_2)<br>    allocated_list.append(job_3)<br>    input_data()<br></code></pre></td></tr></table></figure><p>那么代码部分到这就堂堂完结啦</p><h1>运行结果</h1><p>这部分还请大家自行验证（因为不想放图…）</p><h1>尾声</h1><h2 id="s-font-size-3-face-Microsoft-YaHei-尾声就是没有尾声。-font-s"><s><font size=3 face='Microsoft YaHei'>尾声就是没有尾声。</font></s></h2>]]></content>
    
    
    <categories>
      
      <category>Learning Log</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>操作系统</tag>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python学习笔记——列表中的方法</title>
    <link href="/2022/04/20/python-learning-2/"/>
    <url>/2022/04/20/python-learning-2/</url>
    
    <content type="html"><![CDATA[<h1>列表中的方法</h1><p>我们先定义(约定好)一个用于示例的列表，以方便后续调用它。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a_list = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>,]<br></code></pre></td></tr></table></figure><h2 id="append-e-方法"><code>append(e)</code>方法</h2><div class="note note-info">            <p><strong>描述：</strong><br>在尾部添加一个元素 e</p>          </div>  <p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a_list.append(<span class="hljs-number">6</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>a_list<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]<br></code></pre></td></tr></table></figure><h2 id="clear-方法"><code>clear()</code>方法</h2><div class="note note-info">            <p><strong>描述：</strong><br>删除所有元素</p>          </div>  <p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a_list.clear()<br><span class="hljs-meta">&gt;&gt;&gt; </span>a_list<br>[]<br></code></pre></td></tr></table></figure><h2 id="copy-方法"><code>copy()</code>方法</h2><div class="note note-info">            <p><strong>描述：</strong><br>对列表进行<strong>浅复制</strong></p>          </div>  <p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">class</span> <span class="hljs-title class_">stock</span>:<br><span class="hljs-meta">... </span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, num</span>):<br><span class="hljs-meta">... </span>        self.num = num<br>        <br><span class="hljs-meta">&gt;&gt;&gt; </span>A = stock(<span class="hljs-number">5</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>a_list = [A]<br><span class="hljs-meta">&gt;&gt;&gt; </span>b_list = a_list.copy()<br><span class="hljs-meta">&gt;&gt;&gt; </span>A.num = <span class="hljs-number">4</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>b_list[<span class="hljs-number">0</span>].num<br><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>说明：这里涉及到一个概念：<strong>浅复制（浅拷贝）<strong>和</strong>深复制（深拷贝）</strong>。</p><p>“<strong>浅复制</strong>是指构建一个新的容器对象，然后填充原对象中子对象的引用。本质上浅复制只执行一层，复制过程不会递归，因此不会创建子对象的副本。<br><strong>深复制</strong>是递归复制，首先构造一个新的容器对象，然后递归地填充原始对象中子对象的副本。”<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="《Python Tricks 深入理解python特性》 [德]达恩·巴德尔 人民邮电出版社">[1]</span></a></sup></p><h2 id="count-e-方法"><code>count(e)</code>方法</h2><div class="note note-info">            <p><strong>描述：</strong><br>列表中 e 元素出现的次数</p>          </div>  <p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a_list.count(<span class="hljs-number">1</span>)<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="extend-it-方法"><code>extend(it)</code>方法</h2><div class="note note-info">            <p><strong>描述：</strong><br>将可迭代对象 it 里的元素添加到尾部</p>          </div>  <p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>b_list = [<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>a_list.extend(b_list)<br><span class="hljs-meta">&gt;&gt;&gt; </span>a_list<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><h2 id="index-e-方法"><code>index(e)</code>方法</h2><div class="note note-info">            <p><strong>描述：</strong><br>找到 e 在序列中第一次出现的位置</p>          </div>  <p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a_list.index(<span class="hljs-number">4</span>)<br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h2 id="insert-i-e-方法"><code>insert(i, e)</code>方法</h2><div class="note note-info">            <p><strong>描述：</strong><br>在索引 i 处添加空间，并将 e 元素插入到这个地方</p>          </div>  <p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a_list.insert(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>a_list<br>[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><h2 id="pop-i-方法"><code>pop([i])</code>方法</h2><div class="note note-info">            <p><strong>描述：</strong><br>删除索引 i 位置的值并<strong>返回</strong>这个值，i 的默认值为最后一个元素的位置</p>          </div>  <p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a_list.pop(<span class="hljs-number">0</span>)<br><span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a_list.pop()<br><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h2 id="remove-e-方法"><code>remove(e)</code>方法</h2><div class="note note-info">            <p><strong>描述：</strong><br>删除列表里第一次出现的 e 元素</p>          </div>  <p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a_list.remove(<span class="hljs-number">3</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>a_list<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><h2 id="reverse-方法"><code>reverse()</code>方法</h2><div class="note note-info">            <p><strong>描述：</strong><br>反转列表元素的排列顺序</p>          </div>  <p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a_list.reverse()<br><span class="hljs-meta">&gt;&gt;&gt; </span>a_list<br>[<span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h2 id="sort-key-reverse-方法"><code>sort([key], [reverse])</code>方法</h2><div class="note note-info">            <p><strong>描述：</strong><br>就地对列表进行排序，reverse默认值为False</p>          </div>  <p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a_list.sort(reverse = <span class="hljs-literal">True</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>a_list<br>[<span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>说明：<br>建议配合<a href="https://map1e-g.github.io/2022/04/17/python-essay-1/">这篇随笔</a>食用</p><hr><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>《Python Tricks 深入理解python特性》 [德]达恩·巴德尔 人民邮电出版社<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Learning Log</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python随笔-1</title>
    <link href="/2022/04/17/python-essay-1/"/>
    <url>/2022/04/17/python-essay-1/</url>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>其实就是想补充下多道系统作业那篇文章里讲到的东西（指getMethod函数），补充下相关知识方便各位理解。</p><h1>正文</h1><h2 id="前后双下划线方法">前后双下划线方法</h2><p>同时具有前后双下划线的名称在Python中有特殊用途，我们最熟悉的应该就是<code>__init__</code>了，构造对象函数。当然啦，Python还是有非常多的对象属性的，如果想了解更多对象属性，可以调用<code>dir</code>函数，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">dir</span>(<span class="hljs-built_in">max</span>)<br>[<span class="hljs-string">&#x27;__call__&#x27;</span>, <span class="hljs-string">&#x27;__class__&#x27;</span>, <span class="hljs-string">&#x27;__delattr__&#x27;</span>, <span class="hljs-string">&#x27;__dir__&#x27;</span>, <span class="hljs-string">&#x27;__doc__&#x27;</span>, <br><span class="hljs-string">&#x27;__eq__&#x27;</span>, <span class="hljs-string">&#x27;__format__&#x27;</span>, <span class="hljs-string">&#x27;__ge__&#x27;</span>, <span class="hljs-string">&#x27;__getattribute__&#x27;</span>, <span class="hljs-string">&#x27;__gt__&#x27;</span>, <br><span class="hljs-string">&#x27;__hash__&#x27;</span>, <span class="hljs-string">&#x27;__init__&#x27;</span>, <span class="hljs-string">&#x27;__init_subclass__&#x27;</span>, <span class="hljs-string">&#x27;__le__&#x27;</span>, <span class="hljs-string">&#x27;__lt__&#x27;</span>, <br><span class="hljs-string">&#x27;__module__&#x27;</span>, <span class="hljs-string">&#x27;__name__&#x27;</span>, <span class="hljs-string">&#x27;__ne__&#x27;</span>, <span class="hljs-string">&#x27;__new__&#x27;</span>, <span class="hljs-string">&#x27;__qualname__&#x27;</span>,<br> <span class="hljs-string">&#x27;__reduce__&#x27;</span>, <span class="hljs-string">&#x27;__reduce_ex__&#x27;</span>, <span class="hljs-string">&#x27;__repr__&#x27;</span>, <span class="hljs-string">&#x27;__self__&#x27;</span>, <span class="hljs-string">&#x27;__setattr__&#x27;</span>,<br>  <span class="hljs-string">&#x27;__sizeof__&#x27;</span>, <span class="hljs-string">&#x27;__str__&#x27;</span>, <span class="hljs-string">&#x27;__subclasshook__&#x27;</span>, <span class="hljs-string">&#x27;__text_signature__&#x27;</span>]<br></code></pre></td></tr></table></figure><p>在这里，我直接查看了一个内置函数<code>max</code>的属性，可以看到有非常多属性，我们也不必全部知道他们都用来干嘛。<br>仔细看的话会发现，<code>__lt__</code>也在里面，那么它到底是什么呢？其实它代表的是<strong>比较运算符’&lt;'</strong>。</p><h2 id="sort函数">sort函数</h2><p>先上Python官方文档<a href="https://docs.python.org/3.9/library/stdtypes.html#list.sort">点我跳转</a>：</p><blockquote><p>sort(*, key=None, reverse=False)</p><blockquote><p>This method sorts the list in place, using only &lt; comparisons between items. Exceptions are not suppressed - if any comparison operations fail, the entire sort operation will fail (and the list will likely be left in a partially modified state).</p></blockquote></blockquote><p>也就是说，<code>sort</code>方法其实是根据 &lt; 运算符来进行排序的，也就是升序排序，如果觉得文字难以读懂，不妨写点东西试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>=[<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>.sort()<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>)<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><p>我们也应该记住一点，<code>sort</code>的排序算法是稳定的，当两个值相等的时候，即使是排序后它们的相对位置也不会变。<br><em><strong>扩展</strong></em></p><blockquote><p>从上面我们能看到<code>sort</code>还支持两个额外的参数（注意是keyword-only arguments，传入必须像这样：<code>key=xxx, reverse=xxx</code>）<br>reverse很好理解，传入一个Boolean值（True or False），如果是True则倒序排列，默认为False。<br>key则用来产生排序算法所依赖的对比关键字，比如说，在对一些字符串排序时，可以用<code>key=str.lower</code>来实现忽略大小写的排序，或者用<code>key=len</code>来实现基于字符串长度的排序。</p></blockquote><h1>小结</h1><p>看完上面这点，再结合函数学习笔记那里的一些知识，其实就应该能清楚知道<code>getMethod</code>的机制和作用什么的了，传入一个字符串，根据字符串的不同返回不同的函数对象，用来重载JCB类的<code>__lt__</code>属性（在Python中是可以重载运算符的），这样在之后，我们对含有JCB类对象的列表中调用<code>sort</code>方法，就可以按照我们想要的排序方式来排序列表了。</p><hr>]]></content>
    
    
    <categories>
      
      <category>Essay</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python学习笔记——函数</title>
    <link href="/2022/04/14/python-learning-1/"/>
    <url>/2022/04/14/python-learning-1/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>本文章用到的语言：Python</p>          </div><h1>函数作为对象</h1><p>在Python中，函数也是对象，所以我们可以把函数分配给变量、存储在数据结构中、作为参数传递给其他函数，也能作为其他函数的返回值。<br>初次看到这些内容的时候，我是挺惊讶而且发自内心的“すごい！”并且迫不及待地想要理解和掌握。<br>感觉写文章就是一个非常不错的方式，所以在这里我会尝试用自己所理解到的东西来完成这篇文章。<br>如果有什么问题的话可以尝试联系我~ <a href="https://map1e-g.github.io/about/">联系我</a></p><h2 id="怎么理解函数是对象">怎么理解函数是对象</h2><p>现在有这样一个东西：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-keyword">return</span> a + b<br></code></pre></td></tr></table></figure><p>这就是一个加法函数，传入 a 和 b 的值然后返回二者相加的值，我们可以在控制台调用它得到这样一个结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>如果我现在这么做的话（可以思考一下这段代码做了什么以及输出的结果）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>another_add = add<br><span class="hljs-meta">&gt;&gt;&gt; </span>another_add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>没错，输出的结果就是<code>5</code><br>接下来我们把原来定义的<code>add</code>函数用del删除，再调用<code>another_add</code>试试看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">del</span> add<br><span class="hljs-meta">&gt;&gt;&gt; </span>add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>NameError: name <span class="hljs-string">&#x27;add&#x27;</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> defined<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>another_add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>现在<code>add</code>用不了了，但是<code>another_add</code>还能用，为什么呢？因为函数对象及其名称是相互独立的实体：<strong>指向函数的变量和函数本身实际上是彼此独立的</strong>。<br>这边可以了解一下下面这些东西（引用<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="《Python编程 从入门到实践（第2版）》 [美]埃里克·马瑟斯 人民邮电出版社">[1]</span></a></sup>）：</p><blockquote><p>变量是标签</p><blockquote><p>变量常被描述为可用于存储值的盒子。<br><strong>一种好得多的定义是，变量是可以赋给值的标签，也可以说变量指向特定的值。</strong></p></blockquote></blockquote><p><em><strong>以下是扩展</strong></em></p><blockquote><p>Python在创建函数时都会为每个函数附加一个用于调试的字符串标识符，使用__name__属性来访问它：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>add.__name__<br><span class="hljs-string">&#x27;add&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>another.__name__<br><span class="hljs-string">&#x27;add&#x27;</span><br></code></pre></td></tr></table></figure><p>PS:当然是在<code>add</code>没被删除之前调用的，删除后调用了会报错：<code>NameError: name 'add' is not defined</code><br>由于是在创建函数的时候给出的标识符，所以即使把这个函数分配给了另一个变量，这个标识符也不会变</p></blockquote><h2 id="把函数存储在数据结构中！">把函数存储在数据结构中！</h2><p>由于函数是个对象，所以可以把函数也存储在数据结构当中，并且访问或使用他们。<br>比如把他们塞进列表里：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>funcs = [another_add, <span class="hljs-built_in">max</span>, <span class="hljs-built_in">pow</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>funcs<br>[&lt;function add at <span class="hljs-number">0x0000024777A49E50</span>&gt;, &lt;built-<span class="hljs-keyword">in</span> function <span class="hljs-built_in">max</span>&gt;, &lt;built-<span class="hljs-keyword">in</span> function <span class="hljs-built_in">pow</span>&gt;]<br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> fun <span class="hljs-keyword">in</span> funcs:<br><span class="hljs-meta">... </span>   <span class="hljs-built_in">print</span>(fun, fun(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>))<br>&lt;function add at <span class="hljs-number">0x0000024777A49E50</span>&gt; <span class="hljs-number">5</span><br>&lt;built-<span class="hljs-keyword">in</span> function <span class="hljs-built_in">max</span>&gt; <span class="hljs-number">3</span><br>&lt;built-<span class="hljs-keyword">in</span> function <span class="hljs-built_in">pow</span>&gt; <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>你也可以把它们塞进字典里，同样的，我们尝试访问这个字典，然后试着遍历这个字典并调用这些函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>dic_funcs = &#123;<span class="hljs-string">&#x27;another_add&#x27;</span>:another_add, <span class="hljs-string">&#x27;max&#x27;</span>:<span class="hljs-built_in">max</span>, <span class="hljs-string">&#x27;pow&#x27;</span>:<span class="hljs-built_in">pow</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>dic_funcs<br>&#123;<span class="hljs-string">&#x27;another_add&#x27;</span>: &lt;function add at <span class="hljs-number">0x0000024777A49E50</span>&gt;, <span class="hljs-string">&#x27;max&#x27;</span>: &lt;built-<span class="hljs-keyword">in</span> function <span class="hljs-built_in">max</span>&gt;, <span class="hljs-string">&#x27;pow&#x27;</span>: &lt;built-<span class="hljs-keyword">in</span> function <span class="hljs-built_in">pow</span>&gt;&#125;<br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> fun <span class="hljs-keyword">in</span> dic_funcs.values():<br><span class="hljs-meta">... </span>   <span class="hljs-built_in">print</span>(fun, fun(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>))<br>    <br>&lt;function add at <span class="hljs-number">0x0000024777A49E50</span>&gt; <span class="hljs-number">5</span><br>&lt;built-<span class="hljs-keyword">in</span> function <span class="hljs-built_in">max</span>&gt; <span class="hljs-number">3</span><br>&lt;built-<span class="hljs-keyword">in</span> function <span class="hljs-built_in">pow</span>&gt; <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>并且，在这些数据结构里的函数对象都可以直接调用，不需要特意为他们分配一个变量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>funcs[<span class="hljs-number">0</span>](<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><span class="hljs-number">5</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>dic_funcs[<span class="hljs-string">&#x27;max&#x27;</span>](<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<br><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p><em><strong>本小节的补充</strong></em></p><blockquote><p><code>&lt;built-in function max&gt;</code>指出<code>max</code>函数是python的一个内置函数，所以给出的不是地址<br><code>max</code>函数用于查找可迭代的最大值，关于可迭代，在之后的文章可能会介绍（也是python特性哦）<br><code>pow(x, y)</code>函数就是平方函数了，将x的值返回为y的幂</p></blockquote><h2 id="将函数传递给其他函数">将函数传递给其他函数</h2><p>由于函数是对象，因此可以将其作为参数传递给其他函数。<br>让我们通过一个例子来理解下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_max_or_min</span>(<span class="hljs-params">fun</span>):<br>value = fun(<span class="hljs-number">10</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">6</span>)<br><span class="hljs-built_in">print</span>(value)<br></code></pre></td></tr></table></figure><p><code>get_max_or_min</code>函数获取一个函数参数，并调用这个函数得到一个值，然后将它打印出来，在这里可以由函数的名称看出来，我们可以向其中传入<code>max</code>或<code>min</code>函数<br>让我们尝试一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>get_max_or_min(<span class="hljs-built_in">max</span>)<br><span class="hljs-number">10</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>get_max_or_min(<span class="hljs-built_in">min</span>)<br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>可以看到都输出了正确的结果<br>“将函数对象作为参数传递给其他函数的功能非常强大，可以用来将程序中的<strong>行为</strong>抽象出来并传递出去。”<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="《Python Tricks 深入理解python特性》 [德]达恩·巴德尔 人民邮电出版社">[2]</span></a></sup><br><em><strong>扩展</strong></em><sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="《Python Tricks 深入理解python特性》 [德]达恩·巴德尔 人民邮电出版社">[2]</span></a></sup></p><blockquote><p>“能接受其他函数作为参数的函数称为<strong>高阶函数</strong>。”<br>“比如<code>map</code>函数，<code>map</code>接受一个函数对象和一个可迭代对象，然后在可迭代对象中的每个元素上调用该函数来生成结果。”<br>这里我们调用我们的<code>add</code>函数来看看<code>map</code>函数做了什么：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(add, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]))<br>[<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>]<br></code></pre></td></tr></table></figure><p>可以看出，<code>map</code>函数遍历了整个列表并将<code>add</code>函数应用于每个元素，而且得到了一个新列表对象，存储两数相加后的结果。</p></blockquote><h2 id="嵌套函数">嵌套函数</h2><p>在Python中，甚至可以在函数中定义函数，就是之前写多道系统作业调度模拟程序提到过的东西（<a href="https://map1e-g.github.io/2022/04/13/multi-JCB/">戳我跳转文章</a>）<br>在这里我们定义一个用来计算的函数，根据传入字符串的不同返回不同的结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">cal</span>(<span class="hljs-params">text, x, y</span>):<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>):<br><span class="hljs-keyword">return</span> a + b<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sub</span>(<span class="hljs-params">a, b</span>):<br><span class="hljs-keyword">return</span> a - b<br><span class="hljs-keyword">if</span> text == <span class="hljs-string">&#x27;add&#x27;</span>:<br><span class="hljs-keyword">return</span> add(x, y)<br><span class="hljs-keyword">elif</span> text == <span class="hljs-string">&#x27;sub&#x27;</span>:<br><span class="hljs-keyword">return</span> sub(x, y)<br><span class="hljs-meta">&gt;&gt;&gt; </span>cal(<span class="hljs-string">&#x27;add&#x27;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>)<br><span class="hljs-number">8</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>cal(<span class="hljs-string">&#x27;sub&#x27;</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>)<br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>但是需要注意的是嵌套函数的作用域：<strong>仅在创建它的函数的内部</strong><br>如果我们想在函数外部使用这个函数的话，可以像我上边提到的那篇文章中那样，创建一个变量，并把嵌套函数返回给父函数的调用者。<br>在这里，我就写个根据会员等级判断打折力度的函数来作为例子吧：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">discount</span>(<span class="hljs-params">level</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">platinum</span>(<span class="hljs-params">price</span>):<br>        <span class="hljs-keyword">return</span> price*<span class="hljs-number">0.75</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">gold</span>(<span class="hljs-params">price</span>):<br>        <span class="hljs-keyword">return</span> price*<span class="hljs-number">0.8</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sliver</span>(<span class="hljs-params">price</span>):<br>        <span class="hljs-keyword">return</span> price*<span class="hljs-number">0.85</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">copper</span>(<span class="hljs-params">price</span>):<br>        <span class="hljs-keyword">return</span> price*<span class="hljs-number">0.9</span><br>    <span class="hljs-keyword">if</span> level == <span class="hljs-number">4</span>:<br>        <span class="hljs-keyword">return</span> platinum<br>    <span class="hljs-keyword">elif</span> level == <span class="hljs-number">3</span>:<br>        <span class="hljs-keyword">return</span> gold<br>    <span class="hljs-keyword">elif</span> level == <span class="hljs-number">2</span>:<br>        <span class="hljs-keyword">return</span> sliver<br>    <span class="hljs-keyword">elif</span> level == <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> copper<br></code></pre></td></tr></table></figure><p>然后再测试一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>discount(<span class="hljs-number">3</span>)<br>&lt;function discount.&lt;<span class="hljs-built_in">locals</span>&gt;.gold at <span class="hljs-number">0x000001CF0C9BE3A0</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>a_customer = discount(<span class="hljs-number">3</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>a_customer(<span class="hljs-number">100</span>)<br><span class="hljs-number">80.0</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>discount(<span class="hljs-number">3</span>)(<span class="hljs-number">100</span>)<br><span class="hljs-number">80.0</span><br></code></pre></td></tr></table></figure><p><em>“这意味着函数不仅可以通过参数<strong>接受行为</strong>，还可以<strong>返回行为</strong>。”</em><sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="《Python Tricks 深入理解python特性》 [德]达恩·巴德尔 人民邮电出版社">[2]</span></a></sup></p><h2 id="日后计划">日后计划</h2><p>以后学到的有关函数这部分的内容也会一起在这里更新。</p><hr><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>《Python编程 从入门到实践（第2版）》 [美]埃里克·马瑟斯 人民邮电出版社<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>《Python Tricks 深入理解python特性》 [德]达恩·巴德尔 人民邮电出版社<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Learning Log</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统原理——多道系统作业调度</title>
    <link href="/2022/04/13/multi-JCB/"/>
    <url>/2022/04/13/multi-JCB/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>本文章用到的语言：Python</p>          </div><h1>前言</h1><p>其实一周前就把程序写完了，但是因为博客最近才搭好以及最近才学习了一手markdown所以现在才开始写<s><em>（绝对不是我懒！）</em></s><br>操作系统课程的作业，其实挺不想写的<s>（真的）</s>，毕竟我数据结构与算法学得很垃圾www，就当顺便学习python好了</p><h1>原理</h1><p>这部分略过。（因为真的没什么好写的，以后再补充一下吧）</p><blockquote><p>复制实验说明上的原话：</p><blockquote><p>由于在多道批处理系统中，一批作业投入运行，调度作业时需要根据当前系统各类空闲资源的情况选择一个或多个作业进入内存，再按照进程调度方式选择一个作业的进程占用 CPU。<br>每个作业由一个作业控制块JCB表示，JCB可以包含如下信息：作业名、提交时间、所需的运行时间、所需的资源、作业状态、链指针等等。<br>作业的状态可以是等待W(Wait)、运行R(Run)和完成F(Finish)三种状态之一。每个作业的最初状态总是等待W。<br>各个等待的作业按照提交时刻的先后次序排队，总是首先调度等待队列中队首的作业。<br>每个作业完成后要打印该作业的开始运行时刻、完成时刻、周转时间和带权周转时间，这一组作业完成后要计算并打印这组作业的平均周转时间、带权平均周转时间。</p></blockquote></blockquote><h1>实现</h1><h2 id="核心">核心</h2><p>有两部分，先说第一部分：作业控制块（JCB）<br>其实这里存的东西过多了，但是好处就是意思都很清晰，后面计算总时间或者打印信息什么的也方便</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">JCB</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;作业控制块&quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, job_name, commit_time, run_time, source</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;初始化作业程序块&quot;&quot;&quot;</span><br>        self.job_name = job_name  <span class="hljs-comment"># 作业名字</span><br>        self.commit_time = commit_time  <span class="hljs-comment"># 作业提交时间</span><br>        self.run_time = run_time  <span class="hljs-comment"># 作业所需时间</span><br>        self.start_time = <span class="hljs-number">0</span>  <span class="hljs-comment"># 作业开始时间</span><br>        self.finish_time = <span class="hljs-number">0</span>  <span class="hljs-comment"># 作业完成时间</span><br>        self.rr = <span class="hljs-number">0</span>  <span class="hljs-comment"># 作业响应比</span><br>        self.status = <span class="hljs-string">&#x27;w&#x27;</span>  <span class="hljs-comment"># 程序状态，w为等待，r为运行，f为完成</span><br>        self.ta_time = <span class="hljs-number">0</span>  <span class="hljs-comment"># 作业周转时间</span><br>        self.wta_time = <span class="hljs-number">0</span>  <span class="hljs-comment"># 作业带权周转时间</span><br>        self.source = source  <span class="hljs-comment"># 作业所需资源</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">cul_rr</span>(<span class="hljs-params">self, clock</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;计算作业相应比&quot;&quot;&quot;</span><br>        self.rr = ((clock - self.commit_time) + self.run_time) / self.run_time<br></code></pre></td></tr></table></figure><p>然后是第二部分，这部分用到了python的特性：双下划线方法以及嵌套函数、返回函数等，这里用到的特性会放到后面要写的一些文章中更详细地介绍。<br>先看代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">getMethod</span>(<span class="hljs-params">method</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;不同算法的排序方法&quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">FCFS_lt</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-keyword">return</span> self.commit_time &lt; other.commit_time<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">SJF_lt</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-keyword">return</span> self.run_time &lt; other.run_time<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">HRRF_lt</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-keyword">return</span> self.rr &gt; other.rr<br><br>    <span class="hljs-keyword">if</span> method == <span class="hljs-string">&#x27;FCFS&#x27;</span>:<br>        <span class="hljs-keyword">return</span> FCFS_lt<br>    <span class="hljs-keyword">elif</span> method == <span class="hljs-string">&#x27;SJF&#x27;</span>:<br>        <span class="hljs-keyword">return</span> SJF_lt<br>    <span class="hljs-keyword">elif</span> method == <span class="hljs-string">&#x27;HRRF&#x27;</span>:<br>        <span class="hljs-keyword">return</span> HRRF_lt<br></code></pre></td></tr></table></figure><p>调用这个方法，传入一个字符串，根据不同的字符串返回不同的排序方法，这里一共用到了三种算法：</p><ul><li>FCFS：先来先服务</li><li>SJF：短作业优先</li><li>HRRF：响应比最高者优先</li></ul><p>比如我要用FCFS，那么就：<code>JCB.__lt__ = getMethod('FCFS')</code>，这里getMethod返回了一个函数对象，再赋值给了JCB类的<code>__lt__()</code>方法，这样<code>JCB.__lt__()</code>就和<code>FCFS_lt()</code>一样了（<strong>我省略了参数order</strong>），这个方法在之后的文章再详细说，<br>现在可以这样理解：这么做重载了JCB类的默认比较方法，两个JCB之间可以比大小了，怎么比就看<code>__lt__()</code>里了。<br>那么能比较大小了，排序就能方便起来，而python里边提供了<code>sort()</code>函数来对列表进行永久排序，这个时候即使列表里是一堆JCB对象，我们也可以进行排序。</p><h2 id="算法部分">算法部分</h2><p>注释写得算比较清楚所以在这里不多赘述了，以后有空说不定会更新<s>（实打实的懒狗）</s><br>其实写得不算好吧…自己感觉是写复杂了，某些地方凭感觉写了点东西保证不出错，比如那个删除队列，按道理来说有写判断条件的话就不会出错</p><div class="note note-warning">            <p>注意这里用到了<code>copy.deepcopy()</code>，需要导入copy模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> copy<br></code></pre></td></tr></table></figure>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">simulator</span>(<span class="hljs-params">JCB_queue, method, src</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;作业调度模拟程序&quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 系统时钟和资源数</span><br>    clock = <span class="hljs-number">0</span><br>    source = src<br>    <span class="hljs-comment"># 平均周转时间</span><br>    avg_ta_time = <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 平均带权周转时间</span><br>    avg_wta_time = <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 拷贝队列</span><br>    copy_queue = copy.deepcopy(JCB_queue)<br>    <span class="hljs-comment"># 队列长度</span><br>    queue_len = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">len</span>(copy_queue))<br>    <span class="hljs-comment"># 创建执行队列和等待队列</span><br>    wait_queue = []<br>    run_queue = []<br>    num = <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 排序</span><br>    JCB.__lt__ = getMethod(<span class="hljs-string">&#x27;FCFS&#x27;</span>)<br>    copy_queue.sort()<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-comment"># 运行队列中的作业变更</span><br>        <span class="hljs-keyword">if</span> run_queue:<br>            <span class="hljs-keyword">for</span> job <span class="hljs-keyword">in</span> run_queue:<br>                <span class="hljs-comment"># 检查作业是否完成</span><br>                <span class="hljs-keyword">if</span> job.run_time &lt;= clock - job.start_time <span class="hljs-keyword">and</span> job.status == <span class="hljs-string">&#x27;r&#x27;</span>:<br>                    job.status = <span class="hljs-string">&#x27;f&#x27;</span>  <span class="hljs-comment"># 将当前作业状态设置为完成</span><br>                    job.finish_time = clock  <span class="hljs-comment"># 作业完成（结束）时间为当前系统时间</span><br>                    job.ta_time = job.finish_time - job.commit_time  <span class="hljs-comment"># 作业周转时间 = 作业完成时间 - 作业提交时间</span><br>                    job.wta_time = job.ta_time / job.run_time  <span class="hljs-comment"># 作业带权周转时间 = 作业周转时间 / 作业所需时间</span><br>                    avg_ta_time = avg_ta_time + job.ta_time<br>                    avg_wta_time = avg_wta_time + job.wta_time<br>                    num = num + <span class="hljs-number">1</span>  <span class="hljs-comment"># 作业完成数+1</span><br>                    source = source + job.source  <span class="hljs-comment"># 归还资源</span><br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;作业名：<span class="hljs-subst">&#123;job.job_name&#125;</span>\t&quot;</span><br>                          <span class="hljs-string">f&quot;作业开始时间：<span class="hljs-subst">&#123;job.start_time&#125;</span>\t&quot;</span><br>                          <span class="hljs-string">f&quot;作业完成时间：<span class="hljs-subst">&#123;job.finish_time&#125;</span>\t&quot;</span><br>                          <span class="hljs-string">f&quot;作业周转时间：<span class="hljs-subst">&#123;job.ta_time&#125;</span>\t&quot;</span><br>                          <span class="hljs-string">f&quot;作业带权周转时间：<span class="hljs-subst">&#123;job.wta_time:<span class="hljs-number">.2</span>f&#125;</span>\t&quot;</span>)<br><br>        <span class="hljs-comment"># 检查是否有可以进入等待作业队列的作业</span><br>        <span class="hljs-keyword">for</span> job <span class="hljs-keyword">in</span> copy_queue:<br>            <span class="hljs-keyword">if</span> job.commit_time &lt;= clock <span class="hljs-keyword">and</span> job.status == <span class="hljs-string">&#x27;w&#x27;</span>:<br>                wait_queue.append(job)<br><br>        <span class="hljs-comment"># 等待队列不为空，检查是否有可以进入运行队列的作业</span><br>        <span class="hljs-keyword">if</span> wait_queue:<br>            <span class="hljs-comment"># 计算响应比</span><br>            <span class="hljs-keyword">for</span> job <span class="hljs-keyword">in</span> wait_queue:<br>                job.cul_rr(clock)<br>            JCB.__lt__ = getMethod(method)<br>            wait_queue.sort()<br>            <span class="hljs-comment"># 用于删除等待队列列表元素的列表</span><br>            del_queue = []<br>            <span class="hljs-keyword">for</span> job <span class="hljs-keyword">in</span> wait_queue:<br>                <span class="hljs-keyword">if</span> job.source &lt;= source <span class="hljs-keyword">and</span> job.status == <span class="hljs-string">&#x27;w&#x27;</span>:<br>                    run_queue.append(job)<br>                    del_queue.append(job)<br>                    job.start_time = clock  <span class="hljs-comment"># 作业开始时间为当前系统时间</span><br>                    job.status = <span class="hljs-string">&#x27;r&#x27;</span><br>                    source = source - job.source<br>            <span class="hljs-keyword">if</span> del_queue <span class="hljs-keyword">and</span> wait_queue:<br>                <span class="hljs-keyword">for</span> job <span class="hljs-keyword">in</span> del_queue:<br>                    wait_queue.remove(job)<br><br>        <span class="hljs-comment"># 跳出循环用</span><br>        <span class="hljs-keyword">if</span> num == queue_len:<br>            <span class="hljs-keyword">break</span><br><br>        <span class="hljs-comment"># 系统时钟自增</span><br>        clock = clock + <span class="hljs-number">1</span><br>    avg_ta_time = avg_ta_time / queue_len<br>    avg_wta_time = avg_wta_time / queue_len<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;平均周转时间：<span class="hljs-subst">&#123;avg_ta_time:<span class="hljs-number">.2</span>f&#125;</span>\t带权周转时间：<span class="hljs-subst">&#123;avg_wta_time:<span class="hljs-number">.2</span>f&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="其他函数">其他函数</h2><p>其实只有一个<code>input()</code>用来获取用户输入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">inputJCB</span>():<br>    <span class="hljs-string">&quot;&quot;&quot;初始化JCB队列&quot;&quot;&quot;</span><br>    JCB_queue = []<br>    src = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入系统资源数：&quot;</span>))<br>    JCB_num = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入作业数量：&quot;</span>))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(JCB_num):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前是第<span class="hljs-subst">&#123;i + <span class="hljs-number">1</span>&#125;</span>个作业；&quot;</span>)<br>        jn = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入作业名字：&quot;</span>)<br>        ct = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入作业提交时间：&quot;</span>))<br>        rt = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入作业运行时间：&quot;</span>))<br>        sc = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入作业所需资源：&quot;</span>))<br>        new_JCB = JCB(jn, ct, rt, sc)<br>        JCB_queue.append(new_JCB)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n&quot;</span>)<br>    <span class="hljs-comment"># 打印JCB队列</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(JCB_num):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;第<span class="hljs-subst">&#123;i + <span class="hljs-number">1</span>&#125;</span>个作业名字：<span class="hljs-subst">&#123;JCB_queue[i].job_name&#125;</span>\t&quot;</span><br>              <span class="hljs-string">f&quot;作业提交时间：<span class="hljs-subst">&#123;JCB_queue[i].commit_time&#125;</span>\t&quot;</span><br>              <span class="hljs-string">f&quot;作业所需运行时间：<span class="hljs-subst">&#123;JCB_queue[i].run_time&#125;</span>\t&quot;</span><br>              <span class="hljs-string">f&quot;作业所需资源数：<span class="hljs-subst">&#123;JCB_queue[i].source&#125;</span>&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;FCFS算法：&quot;</span>)<br>    simulator(JCB_queue, <span class="hljs-string">&quot;FCFS&quot;</span>, src)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;SJF算法：&quot;</span>)<br>    simulator(JCB_queue, <span class="hljs-string">&quot;SJF&quot;</span>, src)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;HRRF算法：&quot;</span>)<br>    simulator(JCB_queue, <span class="hljs-string">&quot;HRRF&quot;</span>, src)<br></code></pre></td></tr></table></figure><p>python测试代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    inputJCB()<br></code></pre></td></tr></table></figure><h1>运行结果</h1><p>暂时不贴结果，没找到一个好云图库放图，上传到github也不合适www<br>麻烦各位自己运行一下了</p><h1>结语</h1><p>日后补充<s>（兄啊一篇文章下来省略了多少啊）</s></p><hr>]]></content>
    
    
    <categories>
      
      <category>Learning Log</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>操作系统</tag>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Test my blog</title>
    <link href="/2022/04/12/Test-my-blog/"/>
    <url>/2022/04/12/Test-my-blog/</url>
    
    <content type="html"><![CDATA[<h1>这是第一篇博文，用于测试以及练习markdown语法</h1><h2 id="打两个-就是二级标题">打两个##就是二级标题</h2><h3 id="Markdown字体">Markdown字体</h3><p><em>斜体文本一个*</em><br><strong>粗体文本两个*</strong><br><em><strong>斜粗体文本三个*</strong></em></p><h3 id="分隔线">分隔线</h3><hr><h2 id="font-size-3-face-Microsoft-YaHei-用三个-或者三个-把文本围起来-上面一行下面一行-font-虽然但是为什么分割线里的文本默认挺大的（思考🤔（（这里我用-font-size-改了"><font size=3 face='Microsoft YaHei'>用三个-或者三个*把文本围起来(上面一行下面一行)</font><br>虽然但是为什么分割线里的文本默认挺大的（思考🤔（（这里我用&lt;font size&gt;改了</h2><h3 id="删除线">删除线</h3><p>两个波浪线括起来就能<s>删除</s>了</p><p><s>这样我就能乱说话乐！</s></p><p>为什么用空格不能换行啊！</p><h3 id="下划线">下划线</h3><p><u>直接用html的&lt;u&gt;标签</u></p><h3 id="脚注">脚注</h3><p>这里有一个脚注<a href="%E5%8A%A0VX%E8%AF%B7%E5%90%83KFC%E7%96%AF%E7%8B%82%E6%9C%A8%E6%9B%9C%E6%97%A5%E6%8D%8F">^<s>别点，要脸</s></a></p><h3 id="列表">列表</h3><ul><li>星号+空格+内容</li><li>或者</li><li>+号也行</li><li>-号也行</li><li>有序列表用序号</li></ul><ol><li>这是有序嵌套无序：<ul><li>我是无序</li></ul></li><li>我是有序</li></ol><h3 id="Markdown区块">Markdown区块</h3><blockquote><p>用&gt;加上一个空格再加上文本就好了</p><blockquote><p>区块嵌套就写多点&gt;</p><blockquote><ul><li>区块里边用列表也行</li></ul></blockquote></blockquote></blockquote><ul><li>反过来列表里用区块也行<blockquote><p>在最前边摁个tab就好啦</p></blockquote></li></ul><h3 id="Markdown-代码">Markdown 代码</h3><p>在一行里直接用`包起来就好啦 -&gt; <code>print()</code>函数<br>代码块就用三个`包起来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@login_required</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">topics</span>(<span class="hljs-params">request</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;显示所有的主题&quot;&quot;&quot;</span><br>    topics = Topic.objects.order_by(<span class="hljs-string">&#x27;data_added&#x27;</span>)<br>    context = &#123;<span class="hljs-string">&#x27;topics&#x27;</span>: topics&#125;<br>    <span class="hljs-keyword">return</span> render(request, <span class="hljs-string">&#x27;learning_logs/topics.html&#x27;</span>, context)<br></code></pre></td></tr></table></figure><h3 id="Markdown-链接">Markdown 链接</h3><p>休息一下，听首歌吧~ <a href="https://www.bilibili.com/video/BV1ty4y1y76V?share_source=copy_web"><s>神必链接</s></a></p><h3 id="Markdown-图片">Markdown 图片</h3><p>如图：<br><img src="https://pic1.zhimg.com/v2-e81ff8868ed8bde326ae6074eb8dab40_r.jpg" alt="野兽红茶"></p><h3 id="Markdown-表格">Markdown 表格</h3><p>用 | 来分隔不同单元格，用 - 来分隔表头和其他行</p><table><thead><tr><th style="text-align:left">114</th><th style="text-align:right">514</th><th style="text-align:center">1919810</th></tr></thead><tbody><tr><td style="text-align:left">哼</td><td style="text-align:right">哼  啊</td><td style="text-align:center">啊啊啊</td></tr></tbody></table><h3 id="数学公式">数学公式</h3><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>E</mi><mo>=</mo><mi>m</mi><msup><mi>c</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">E=mc^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8641em;"></span><span class="mord mathnormal">m</span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></p><hr><h2 id="堂堂完结">堂堂完结</h2><p>（<s>其实是想上床摆烂了</s></p><hr>]]></content>
    
    
    <categories>
      
      <category>Gossip</category>
      
    </categories>
    
    
    <tags>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
